============================================================
 Relatório Ultra-Completo do Projeto CUDA-clustalW
============================================================

Inclui:
1) Árvore de diretórios, assinaturas de função
2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.
3) Estatísticas ao final
4) Execução do 'make', com parse de warnings e errors
5) Enfim, informações detalhadas para migração/debug.


=== Informações de ambiente ===

nvcc version:
nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2024 NVIDIA Corporation
Built on Tue_Feb_27_16:19:38_PST_2024
Cuda compilation tools, release 12.4, V12.4.99
Build cuda_12.4.r12.4/compiler.33961263_0

CUDA_HOME: Not set
CUDA_PATH: Not set
PATH: /usr/local/cuda-12.4/bin:/dados/home/tesla-dados/.vscode-server/cli/servers/Stable-fabdb6a30b49f79a7aba0f2ad9df9b399473380f/server/bin/remote-cli:/usr/local/cuda-12.4/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
LD_LIBRARY_PATH: /usr/local/cuda-12.4/lib64:/usr/local/cuda-12.4/lib64:


=== Mapeando o diretório: /dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final ===


[DIRECTORY] /dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final
  |- master-read.py
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 10: 'sm_13'
         [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [   8] 
         [   9] - Mapeia diretórios, assinaturas de função
         [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  12] - Exibe TODO, FIXME, etc. com snippet
         [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 10: 'sm_86'
         [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [   8] 
         [   9] - Mapeia diretórios, assinaturas de função
         [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  12] - Exibe TODO, FIXME, etc. com snippet
         [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 10: 'NVCCFLAGS'
         [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [   8] 
         [   9] - Mapeia diretórios, assinaturas de função
         [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  12] - Exibe TODO, FIXME, etc. com snippet
         [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 51: 'gencode'
         [  48] 
         [  49] # Regex (compilado) para compute capabilities/flags
         [  50] CUDA_ARCH_REGEX = re.compile(
         [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  52] )
         [  53] 
         [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 51: 'NVCCFLAGS'
         [  48] 
         [  49] # Regex (compilado) para compute capabilities/flags
         [  50] CUDA_ARCH_REGEX = re.compile(
         [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  52] )
         [  53] 
         [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 51: 'CUDAFLAGS'
         [  48] 
         [  49] # Regex (compilado) para compute capabilities/flags
         [  50] CUDA_ARCH_REGEX = re.compile(
         [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  52] )
         [  53] 
         [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 51: '--gpu-architecture'
         [  48] 
         [  49] # Regex (compilado) para compute capabilities/flags
         [  50] CUDA_ARCH_REGEX = re.compile(
         [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  52] )
         [  53] 
         [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 51: '--gpu-code'
         [  48] 
         [  49] # Regex (compilado) para compute capabilities/flags
         [  50] CUDA_ARCH_REGEX = re.compile(
         [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  52] )
         [  53] 
         [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 212: 'sm_13'
         [ 209]     """
         [ 210]     Percorre o diretório. Para cada arquivo, busca:
         [ 211]      - assinaturas de função
         [ 212]      - references a sm_13/sm_86 (CUDA_ARCH_REGEX)
         [ 213]      - references a APIs obsoletas (CUDA_OBSOLETE_APIS)
         [ 214]      - references a marcadores (PROBLEM_MARKERS)
         [ 215]      Exibe snippet ao redor e registra contadores em summary_counts.
       [CUDA Arch / Flags] line 212: 'sm_86'
         [ 209]     """
         [ 210]     Percorre o diretório. Para cada arquivo, busca:
         [ 211]      - assinaturas de função
         [ 212]      - references a sm_13/sm_86 (CUDA_ARCH_REGEX)
         [ 213]      - references a APIs obsoletas (CUDA_OBSOLETE_APIS)
         [ 214]      - references a marcadores (PROBLEM_MARKERS)
         [ 215]      Exibe snippet ao redor e registra contadores em summary_counts.
       [CUDA Arch / Flags] line 334: 'sm_13'
         [ 331]         "============================================================\n\n"
         [ 332]         "Inclui:\n"
         [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 335]         "3) Estatísticas ao final\n"
         [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [CUDA Arch / Flags] line 334: 'sm_86'
         [ 331]         "============================================================\n\n"
         [ 332]         "Inclui:\n"
         [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 335]         "3) Estatísticas ao final\n"
         [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [API CUDA Obsoleta] line 11: 'cudaThreadSynchronize'
         [   8] 
         [   9] - Mapeia diretórios, assinaturas de função
         [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  12] - Exibe TODO, FIXME, etc. com snippet
         [  13] - Separa warnings e errors do 'make' e agrupa
         [  14] - Gera contagem estatística de cada tipo de referência
       [API CUDA Obsoleta] line 56: 'cudaThreadSynchronize'
         [  53] 
         [  54] # Listas de strings para buscas literais
         [  55] CUDA_OBSOLETE_APIS = [
         [  56]     r"cudaThreadSynchronize",
         [  57]     r"cudaThreadExit",
         [  58]     r"__syncthreadsCount",
         [  59]     r"cutil\.h",
       [API CUDA Obsoleta] line 57: 'cudaThreadExit'
         [  54] # Listas de strings para buscas literais
         [  55] CUDA_OBSOLETE_APIS = [
         [  56]     r"cudaThreadSynchronize",
         [  57]     r"cudaThreadExit",
         [  58]     r"__syncthreadsCount",
         [  59]     r"cutil\.h",
         [  60]     r"helper_cuda\.h",
       [API CUDA Obsoleta] line 58: '__syncthreadsCount'
         [  55] CUDA_OBSOLETE_APIS = [
         [  56]     r"cudaThreadSynchronize",
         [  57]     r"cudaThreadExit",
         [  58]     r"__syncthreadsCount",
         [  59]     r"cutil\.h",
         [  60]     r"helper_cuda\.h",
         [  61]     r"texture\<",
       [API CUDA Obsoleta] line 62: 'BindTexture'
         [  59]     r"cutil\.h",
         [  60]     r"helper_cuda\.h",
         [  61]     r"texture\<",
         [  62]     r"BindTexture",
         [  63] ]
         [  64] 
         [  65] PROBLEM_MARKERS = [
       [Marcador de problema] line 12: 'TODO'
         [   9] - Mapeia diretórios, assinaturas de função
         [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  12] - Exibe TODO, FIXME, etc. com snippet
         [  13] - Separa warnings e errors do 'make' e agrupa
         [  14] - Gera contagem estatística de cada tipo de referência
         [  15] 
       [Marcador de problema] line 66: 'TODO'
         [  63] ]
         [  64] 
         [  65] PROBLEM_MARKERS = [
         [  66]     r"TODO",
         [  67]     r"FIXME",
         [  68]     r"DEPRECATED",
         [  69]     r"AW:",
       [Marcador de problema] line 334: 'TODO'
         [ 331]         "============================================================\n\n"
         [ 332]         "Inclui:\n"
         [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 335]         "3) Estatísticas ao final\n"
         [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [Marcador de problema] line 12: 'FIXME'
         [   9] - Mapeia diretórios, assinaturas de função
         [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  12] - Exibe TODO, FIXME, etc. com snippet
         [  13] - Separa warnings e errors do 'make' e agrupa
         [  14] - Gera contagem estatística de cada tipo de referência
         [  15] 
       [Marcador de problema] line 67: 'FIXME'
         [  64] 
         [  65] PROBLEM_MARKERS = [
         [  66]     r"TODO",
         [  67]     r"FIXME",
         [  68]     r"DEPRECATED",
         [  69]     r"AW:",
         [  70]     r"eight[ -_]years",
       [Marcador de problema] line 68: 'DEPRECATED'
         [  65] PROBLEM_MARKERS = [
         [  66]     r"TODO",
         [  67]     r"FIXME",
         [  68]     r"DEPRECATED",
         [  69]     r"AW:",
         [  70]     r"eight[ -_]years",
         [  71] ]
       [Marcador de problema] line 69: 'AW:'
         [  66]     r"TODO",
         [  67]     r"FIXME",
         [  68]     r"DEPRECATED",
         [  69]     r"AW:",
         [  70]     r"eight[ -_]years",
         [  71] ]
         [  72] 
  |- LICENSE
  |- compile
    -> Referências importantes (com snippet):
       [Marcador de problema] line 324: 'FIXME'
         [ 321]   fi
         [ 322]   sleep 1
         [ 323] done
         [ 324] # FIXME: race condition here if user kills between mkdir and trap.
         [ 325] trap "rmdir '$lockdir'; exit 1" 1 2 15
         [ 326] 
         [ 327] # Run the compile.
  |- README
  |- intltool-merge.in
  |- depcomp
    -> Referências importantes (com snippet):
       [Marcador de problema] line 330: 'FIXME'
         [ 327] 
         [ 328] tcc)
         [ 329]   # tcc (Tiny C Compiler) understand '-MD -MF file' since version 0.9.26
         [ 330]   # FIXME: That version still under development at the moment of writing.
         [ 331]   #        Make that this statement remains true also for stable, released
         [ 332]   #        versions.
         [ 333]   # It will wrap lines (doesn't matter whether long or short) with a
  |- configure.ac
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 116: 'NVCCFLAGS'
         [ 113]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 114]     NVCC="nvcc"
         [ 115] fi
         [ 116] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 117] AC_SUBST(CUDA_CFLAGS)
         [ 118] AC_SUBST(CUDA_LIBS)
         [ 119] AC_SUBST(NVCC)
       [CUDA Arch / Flags] line 116: 'arch=sm_86'
         [ 113]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 114]     NVCC="nvcc"
         [ 115] fi
         [ 116] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 117] AC_SUBST(CUDA_CFLAGS)
         [ 118] AC_SUBST(CUDA_LIBS)
         [ 119] AC_SUBST(NVCC)
       [CUDA Arch / Flags] line 120: 'NVCCFLAGS'
         [ 117] AC_SUBST(CUDA_CFLAGS)
         [ 118] AC_SUBST(CUDA_LIBS)
         [ 119] AC_SUBST(NVCC)
         [ 120] AC_SUBST(NVCCFLAGS)
         [ 121] 
         [ 122] 
         [ 123] 
  |- clustalw_help
  |- Makefile.in
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 250: 'NVCCFLAGS'
         [ 247] MAKEINFO = @MAKEINFO@
         [ 248] MKDIR_P = @MKDIR_P@
         [ 249] NVCC = @NVCC@
         [ 250] NVCCFLAGS = @NVCCFLAGS@
         [ 251] OBJEXT = @OBJEXT@
         [ 252] PACKAGE = @PACKAGE@
         [ 253] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 250: 'NVCCFLAGS'
         [ 247] MAKEINFO = @MAKEINFO@
         [ 248] MKDIR_P = @MKDIR_P@
         [ 249] NVCC = @NVCC@
         [ 250] NVCCFLAGS = @NVCCFLAGS@
         [ 251] OBJEXT = @OBJEXT@
         [ 252] PACKAGE = @PACKAGE@
         [ 253] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
  |- missing
  |- config.sub
    -> Referências importantes (com snippet):
       [Marcador de problema] line 769: 'FIXME'
         [ 766] 		vendor=hp
         [ 767] 		;;
         [ 768] 	hp9k78[0-9] | hp78[0-9])
         [ 769] 		# FIXME: really hppa2.0-hp
         [ 770] 		cpu=hppa1.1
         [ 771] 		vendor=hp
         [ 772] 		;;
       [Marcador de problema] line 774: 'FIXME'
         [ 771] 		vendor=hp
         [ 772] 		;;
         [ 773] 	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
         [ 774] 		# FIXME: really hppa2.0-hp
         [ 775] 		cpu=hppa1.1
         [ 776] 		vendor=hp
         [ 777] 		;;
  |- Makefile
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 250: 'NVCCFLAGS'
         [ 247] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 248] MKDIR_P = /usr/bin/mkdir -p
         [ 249] NVCC = nvcc
         [ 250] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 251] OBJEXT = o
         [ 252] PACKAGE = clustalw
         [ 253] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 250: 'arch=sm_86'
         [ 247] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 248] MKDIR_P = /usr/bin/mkdir -p
         [ 249] NVCC = nvcc
         [ 250] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 251] OBJEXT = o
         [ 252] PACKAGE = clustalw
         [ 253] PACKAGE_BUGREPORT = clustalw@ucd.ie
  |- config.h.in
  |- intltool-extract.in
  |- config.guess
  |- install-sh
  |- config.h
  |- configure
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 658: 'NVCCFLAGS'
         [ 655] EGREP
         [ 656] GREP
         [ 657] RANLIB
         [ 658] NVCCFLAGS
         [ 659] NVCC
         [ 660] CUDA_LIBS
         [ 661] CUDA_CFLAGS
       [CUDA Arch / Flags] line 5464: 'NVCCFLAGS'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [CUDA Arch / Flags] line 5464: 'arch=sm_86'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [Marcador de problema] line 7486: 'TODO'
         [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [7485]   # if we detect the quoting.
         [7486]   # TODO: see whether this extra hack can be removed once we start
         [7487]   # requiring Autoconf 2.70 or later.
         [7488]   case $CONFIG_FILES in #(
         [7489]   *\'*) :
       [Marcador de problema] line 1199: 'FIXME'
         [1196]     export $ac_envvar ;;
         [1197] 
         [1198]   *)
         [1199]     # FIXME: should be removed in autoconf 3.0.
         [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 1245: 'FIXME'
         [1242] 
         [1243] # There might be people who depend on the old broken behavior: `$host'
         [1244] # used to hold the argument of --host etc.
         [1245] # FIXME: To remove some day.
         [1246] build=$build_alias
         [1247] host=$host_alias
         [1248] target=$target_alias
       [Marcador de problema] line 1250: 'FIXME'
         [1247] host=$host_alias
         [1248] target=$target_alias
         [1249] 
         [1250] # FIXME: To remove some day.
         [1251] if test "x$host_alias" != x; then
         [1252]   if test "x$build_alias" = x; then
         [1253]     cross_compiling=maybe
       [Marcador de problema] line 4654: 'FIXME'
         [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [4653]    # Losing compiler, so override with the script.
         [4654]    # FIXME: It is wrong to rewrite CC.
         [4655]    # But if we don't then we get into trouble of one sort or another.
         [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
       [Marcador de problema] line 7344: 'FIXME'
         [7341] 
         [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [7343] # If the template does not know about datarootdir, expand it.
         [7344] # FIXME: This hack should be removed a few years after 2.60.
         [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [7346] ac_sed_dataroot='
         [7347] /datarootdir/ {
       [Marcador de problema] line 7375: 'FIXME'
         [7372] 
         [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [7374] # Shell code in configure.ac might set extrasub.
         [7375] # FIXME: do we really want to maintain this feature?
         [7376] cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
         [7377] ac_sed_extra="$ac_vpsub
         [7378] $extrasub
  |- stamp-h1
  |- Makefile.am
  |- intltool-update.in
  |- configure~
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 718: 'NVCCFLAGS'
         [ 715] CUDA_CFLAGS
         [ 716] CUDA_LIBS
         [ 717] NVCC
         [ 718] NVCCFLAGS
         [ 719] RANLIB
         [ 720] CPP
         [ 721] GREP
       [CUDA Arch / Flags] line 4176: 'NVCCFLAGS'
         [4173]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [4174]     NVCC="nvcc"
         [4175] fi
         [4176] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [4177] 
         [4178] 
         [4179] 
       [CUDA Arch / Flags] line 4176: 'arch=sm_13'
         [4173]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [4174]     NVCC="nvcc"
         [4175] fi
         [4176] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [4177] 
         [4178] 
         [4179] 
       [CUDA Arch / Flags] line 6657: 'NVCCFLAGS'
         [6654] CUDA_CFLAGS!$CUDA_CFLAGS$ac_delim
         [6655] CUDA_LIBS!$CUDA_LIBS$ac_delim
         [6656] NVCC!$NVCC$ac_delim
         [6657] NVCCFLAGS!$NVCCFLAGS$ac_delim
         [6658] RANLIB!$RANLIB$ac_delim
         [6659] CPP!$CPP$ac_delim
         [6660] GREP!$GREP$ac_delim
       [CUDA Arch / Flags] line 6657: 'NVCCFLAGS'
         [6654] CUDA_CFLAGS!$CUDA_CFLAGS$ac_delim
         [6655] CUDA_LIBS!$CUDA_LIBS$ac_delim
         [6656] NVCC!$NVCC$ac_delim
         [6657] NVCCFLAGS!$NVCCFLAGS$ac_delim
         [6658] RANLIB!$RANLIB$ac_delim
         [6659] CPP!$CPP$ac_delim
         [6660] GREP!$GREP$ac_delim
       [Marcador de problema] line 1107: 'FIXME'
         [1104]     export $ac_envvar ;;
         [1105] 
         [1106]   *)
         [1107]     # FIXME: should be removed in autoconf 3.0.
         [1108]     echo "$as_me: WARNING: you should use --build, --host, --target" >&2
         [1109]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [1110]       echo "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 1140: 'FIXME'
         [1137] 
         [1138] # There might be people who depend on the old broken behavior: `$host'
         [1139] # used to hold the argument of --host etc.
         [1140] # FIXME: To remove some day.
         [1141] build=$build_alias
         [1142] host=$host_alias
         [1143] target=$target_alias
       [Marcador de problema] line 1145: 'FIXME'
         [1142] host=$host_alias
         [1143] target=$target_alias
         [1144] 
         [1145] # FIXME: To remove some day.
         [1146] if test "x$host_alias" != x; then
         [1147]   if test "x$build_alias" = x; then
         [1148]     cross_compiling=maybe
       [Marcador de problema] line 2942: 'FIXME'
         [2939] # the compiler is broken, or we cross compile.
         [2940] { echo "$as_me:$LINENO: checking whether the C compiler works" >&5
         [2941] echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6; }
         [2942] # FIXME: These cross compiler hacks should be removed for Autoconf 3.0
         [2943] # If not cross compiling, check that we can run a simple program.
         [2944] if test "$cross_compiling" != yes; then
         [2945]   if { ac_try='./$ac_file'
       [Marcador de problema] line 5210: 'FIXME'
         [5207] int
         [5208] main ()
         [5209] {
         [5210] /* FIXME: Include the comments suggested by Paul. */
         [5211] #ifndef __cplusplus
         [5212]   /* Ultrix mips cc rejects this.  */
         [5213]   typedef int charset[2];
       [Marcador de problema] line 6902: 'FIXME'
         [6899] 
         [6900] cat >>$CONFIG_STATUS <<\_ACEOF
         [6901] # If the template does not know about datarootdir, expand it.
         [6902] # FIXME: This hack should be removed a few years after 2.60.
         [6903] ac_datarootdir_hack=; ac_datarootdir_seen=
         [6904] 
         [6905] case `sed -n '/datarootdir/ {
       [Marcador de problema] line 6933: 'FIXME'
         [6930] 
         [6931] # Neutralize VPATH when `$srcdir' = `.'.
         [6932] # Shell code in configure.ac might set extrasub.
         [6933] # FIXME: do we really want to maintain this feature?
         [6934] cat >>$CONFIG_STATUS <<_ACEOF
         [6935]   sed "$ac_vpsub
         [6936] $extrasub
  |- config.status
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 620: 'NVCCFLAGS'
         [ 617] S["EGREP"]="/usr/bin/grep -E"
         [ 618] S["GREP"]="/usr/bin/grep"
         [ 619] S["RANLIB"]="ranlib"
         [ 620] S["NVCCFLAGS"]="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 621] S["NVCC"]="nvcc"
         [ 622] S["CUDA_LIBS"]="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 623] S["CUDA_CFLAGS"]="-I/usr/local/cuda/include"
       [CUDA Arch / Flags] line 620: 'arch=sm_86'
         [ 617] S["EGREP"]="/usr/bin/grep -E"
         [ 618] S["GREP"]="/usr/bin/grep"
         [ 619] S["RANLIB"]="ranlib"
         [ 620] S["NVCCFLAGS"]="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 621] S["NVCC"]="nvcc"
         [ 622] S["CUDA_LIBS"]="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 623] S["CUDA_CFLAGS"]="-I/usr/local/cuda/include"
       [Marcador de problema] line 1124: 'TODO'
         [1121]   # Older Autoconf quotes --file arguments for eval, but not when files
         [1122]   # are listed without --file.  Let's play safe and only enable the eval
         [1123]   # if we detect the quoting.
         [1124]   # TODO: see whether this extra hack can be removed once we start
         [1125]   # requiring Autoconf 2.70 or later.
         [1126]   case $CONFIG_FILES in #(
         [1127]   *\'*) :
       [Marcador de problema] line 977: 'FIXME'
         [ 974]   */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
         [ 975]   esac
         [ 976] # If the template does not know about datarootdir, expand it.
         [ 977] # FIXME: This hack should be removed a few years after 2.60.
         [ 978] ac_datarootdir_hack=; ac_datarootdir_seen=
         [ 979] ac_sed_dataroot='
         [ 980] /datarootdir/ {
  |- config.log
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 566: 'NVCCFLAGS'
         [ 563] MAKEINFO='${SHELL} '\''/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing'\'' makeinfo'
         [ 564] MKDIR_P='/usr/bin/mkdir -p'
         [ 565] NVCC='nvcc'
         [ 566] NVCCFLAGS='-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp '
         [ 567] OBJEXT='o'
         [ 568] PACKAGE='clustalw'
         [ 569] PACKAGE_BUGREPORT='clustalw@ucd.ie'
       [CUDA Arch / Flags] line 566: 'arch=sm_86'
         [ 563] MAKEINFO='${SHELL} '\''/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing'\'' makeinfo'
         [ 564] MKDIR_P='/usr/bin/mkdir -p'
         [ 565] NVCC='nvcc'
         [ 566] NVCCFLAGS='-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp '
         [ 567] OBJEXT='o'
         [ 568] PACKAGE='clustalw'
         [ 569] PACKAGE_BUGREPORT='clustalw@ucd.ie'
  |- aclocal.m4
    -> Referências importantes (com snippet):
       [Marcador de problema] line 348: 'TODO'
         [ 345]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 346]   # are listed without --file.  Let's play safe and only enable the eval
         [ 347]   # if we detect the quoting.
         [ 348]   # TODO: see whether this extra hack can be removed once we start
         [ 349]   # requiring Autoconf 2.70 or later.
         [ 350]   AS_CASE([$CONFIG_FILES],
         [ 351]           [*\'*], [eval set x "$CONFIG_FILES"],
       [Marcador de problema] line 831: 'FIXME'
         [ 828]   unset am_i])
         [ 829] if test "$am_cv_prog_cc_c_o" != yes; then
         [ 830]    # Losing compiler, so override with the script.
         [ 831]    # FIXME: It is wrong to rewrite CC.
         [ 832]    # But if we don't then we get into trouble of one sort or another.
         [ 833]    # A longer-term fix would be to have automake use am__CC in this case,
         [ 834]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"

[DIRECTORY] m4
  |- Makefile.in
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 195: 'NVCCFLAGS'
         [ 192] MAKEINFO = @MAKEINFO@
         [ 193] MKDIR_P = @MKDIR_P@
         [ 194] NVCC = @NVCC@
         [ 195] NVCCFLAGS = @NVCCFLAGS@
         [ 196] OBJEXT = @OBJEXT@
         [ 197] PACKAGE = @PACKAGE@
         [ 198] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 195: 'NVCCFLAGS'
         [ 192] MAKEINFO = @MAKEINFO@
         [ 193] MKDIR_P = @MKDIR_P@
         [ 194] NVCC = @NVCC@
         [ 195] NVCCFLAGS = @NVCCFLAGS@
         [ 196] OBJEXT = @OBJEXT@
         [ 197] PACKAGE = @PACKAGE@
         [ 198] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
  |- Makefile
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 195: 'NVCCFLAGS'
         [ 192] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 193] MKDIR_P = /usr/bin/mkdir -p
         [ 194] NVCC = nvcc
         [ 195] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 196] OBJEXT = o
         [ 197] PACKAGE = clustalw
         [ 198] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 195: 'arch=sm_86'
         [ 192] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 193] MKDIR_P = /usr/bin/mkdir -p
         [ 194] NVCC = nvcc
         [ 195] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 196] OBJEXT = o
         [ 197] PACKAGE = clustalw
         [ 198] PACKAGE_BUGREPORT = clustalw@ucd.ie
  |- Makefile.am

[DIRECTORY] autom4te.cache
  |- output.0
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 658: 'NVCCFLAGS'
         [ 655] EGREP
         [ 656] GREP
         [ 657] RANLIB
         [ 658] NVCCFLAGS
         [ 659] NVCC
         [ 660] CUDA_LIBS
         [ 661] CUDA_CFLAGS
       [CUDA Arch / Flags] line 5464: 'NVCCFLAGS'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [CUDA Arch / Flags] line 5464: 'arch=sm_86'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [Marcador de problema] line 7486: 'TODO'
         [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [7485]   # if we detect the quoting.
         [7486]   # TODO: see whether this extra hack can be removed once we start
         [7487]   # requiring Autoconf 2.70 or later.
         [7488]   case $CONFIG_FILES in @%:@(
         [7489]   *\'*) :
       [Marcador de problema] line 1199: 'FIXME'
         [1196]     export $ac_envvar ;;
         [1197] 
         [1198]   *)
         [1199]     # FIXME: should be removed in autoconf 3.0.
         [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 1245: 'FIXME'
         [1242] 
         [1243] # There might be people who depend on the old broken behavior: `$host'
         [1244] # used to hold the argument of --host etc.
         [1245] # FIXME: To remove some day.
         [1246] build=$build_alias
         [1247] host=$host_alias
         [1248] target=$target_alias
       [Marcador de problema] line 1250: 'FIXME'
         [1247] host=$host_alias
         [1248] target=$target_alias
         [1249] 
         [1250] # FIXME: To remove some day.
         [1251] if test "x$host_alias" != x; then
         [1252]   if test "x$build_alias" = x; then
         [1253]     cross_compiling=maybe
       [Marcador de problema] line 4654: 'FIXME'
         [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [4653]    # Losing compiler, so override with the script.
         [4654]    # FIXME: It is wrong to rewrite CC.
         [4655]    # But if we don't then we get into trouble of one sort or another.
         [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
       [Marcador de problema] line 7344: 'FIXME'
         [7341] 
         [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [7343] # If the template does not know about datarootdir, expand it.
         [7344] # FIXME: This hack should be removed a few years after 2.60.
         [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [7346] ac_sed_dataroot='
         [7347] /datarootdir/ {
       [Marcador de problema] line 7375: 'FIXME'
         [7372] 
         [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [7374] # Shell code in configure.ac might set extrasub.
         [7375] # FIXME: do we really want to maintain this feature?
         [7376] cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
         [7377] ac_sed_extra="$ac_vpsub
         [7378] $extrasub
  |- traces.0
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 992: 'NVCCFLAGS'
         [ 989] m4trace:configure.ac:117: -1- m4_pattern_allow([^CUDA_CFLAGS$])
         [ 990] m4trace:configure.ac:118: -1- m4_pattern_allow([^CUDA_LIBS$])
         [ 991] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 992] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 993] m4trace:configure.ac:129: -1- m4_pattern_allow([^RANLIB$])
         [ 994] m4trace:configure.ac:136: -1- _m4_warn([obsolete], [The macro `AC_HEADER_STDC' is obsolete.
         [ 995] You should run autoupdate.], [./lib/autoconf/headers.m4:704: AC_HEADER_STDC is expanded from...
       [Marcador de problema] line 190: 'TODO'
         [ 187]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 188]   # are listed without --file.  Let's play safe and only enable the eval
         [ 189]   # if we detect the quoting.
         [ 190]   # TODO: see whether this extra hack can be removed once we start
         [ 191]   # requiring Autoconf 2.70 or later.
         [ 192]   AS_CASE([$CONFIG_FILES],
         [ 193]           [*\'*], [eval set x "$CONFIG_FILES"],
       [Marcador de problema] line 513: 'FIXME'
         [ 510]   unset am_i])
         [ 511] if test "$am_cv_prog_cc_c_o" != yes; then
         [ 512]    # Losing compiler, so override with the script.
         [ 513]    # FIXME: It is wrong to rewrite CC.
         [ 514]    # But if we don't then we get into trouble of one sort or another.
         [ 515]    # A longer-term fix would be to have automake use am__CC in this case,
         [ 516]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
  |- traces.4t
  |- traces.2
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 478: 'NVCCFLAGS'
         [ 475] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
         [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
       [CUDA Arch / Flags] line 479: 'NVCCFLAGS'
         [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
       [CUDA Arch / Flags] line 480: 'NVCCFLAGS'
         [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
         [ 483] m4trace:configure.ac:129: -1- m4_pattern_allow([^RANLIB$])
  |- output.2
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 658: 'NVCCFLAGS'
         [ 655] EGREP
         [ 656] GREP
         [ 657] RANLIB
         [ 658] NVCCFLAGS
         [ 659] NVCC
         [ 660] CUDA_LIBS
         [ 661] CUDA_CFLAGS
       [CUDA Arch / Flags] line 5464: 'NVCCFLAGS'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [CUDA Arch / Flags] line 5464: 'arch=sm_86'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [Marcador de problema] line 7486: 'TODO'
         [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [7485]   # if we detect the quoting.
         [7486]   # TODO: see whether this extra hack can be removed once we start
         [7487]   # requiring Autoconf 2.70 or later.
         [7488]   case $CONFIG_FILES in @%:@(
         [7489]   *\'*) :
       [Marcador de problema] line 1199: 'FIXME'
         [1196]     export $ac_envvar ;;
         [1197] 
         [1198]   *)
         [1199]     # FIXME: should be removed in autoconf 3.0.
         [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 1245: 'FIXME'
         [1242] 
         [1243] # There might be people who depend on the old broken behavior: `$host'
         [1244] # used to hold the argument of --host etc.
         [1245] # FIXME: To remove some day.
         [1246] build=$build_alias
         [1247] host=$host_alias
         [1248] target=$target_alias
       [Marcador de problema] line 1250: 'FIXME'
         [1247] host=$host_alias
         [1248] target=$target_alias
         [1249] 
         [1250] # FIXME: To remove some day.
         [1251] if test "x$host_alias" != x; then
         [1252]   if test "x$build_alias" = x; then
         [1253]     cross_compiling=maybe
       [Marcador de problema] line 4654: 'FIXME'
         [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [4653]    # Losing compiler, so override with the script.
         [4654]    # FIXME: It is wrong to rewrite CC.
         [4655]    # But if we don't then we get into trouble of one sort or another.
         [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
       [Marcador de problema] line 7344: 'FIXME'
         [7341] 
         [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [7343] # If the template does not know about datarootdir, expand it.
         [7344] # FIXME: This hack should be removed a few years after 2.60.
         [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [7346] ac_sed_dataroot='
         [7347] /datarootdir/ {
       [Marcador de problema] line 7375: 'FIXME'
         [7372] 
         [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [7374] # Shell code in configure.ac might set extrasub.
         [7375] # FIXME: do we really want to maintain this feature?
         [7376] cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
         [7377] ac_sed_extra="$ac_vpsub
         [7378] $extrasub
  |- output.3
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 313: 'NVCCFLAGS'
         [ 310] # include <unistd.h>
         [ 311] #endif"
         [ 312] 
         [ 313] ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CLUSTALW_VERSION CLUSTALW_NAME INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CXX CXXFLAGS ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE noopenmp noopenmp_TRUE noopenmp_FALSE CUDA_CFLAGS CUDA_LIBS NVCC NVCCFLAGS RANLIB ac_ct_RANLIB CPP EGREP LIB@&t@OBJS LTLIBOBJS'
         [ 314] ac_subst_files=''
         [ 315] 
         [ 316] # Initialize some variables set by options.
       [CUDA Arch / Flags] line 3660: 'NVCCFLAGS'
         [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [3658]     NVCC="nvcc"
         [3659] fi
         [3660] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [3661] 
         [3662] 
         [3663] 
       [CUDA Arch / Flags] line 3660: 'arch=sm_13'
         [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [3658]     NVCC="nvcc"
         [3659] fi
         [3660] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [3661] 
         [3662] 
         [3663] 
       [CUDA Arch / Flags] line 5872: 'NVCCFLAGS'
         [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [5871] s,@NVCC@,$NVCC,;t t
         [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [5873] s,@RANLIB@,$RANLIB,;t t
         [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [5875] s,@CPP@,$CPP,;t t
       [CUDA Arch / Flags] line 5872: 'NVCCFLAGS'
         [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [5871] s,@NVCC@,$NVCC,;t t
         [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [5873] s,@RANLIB@,$RANLIB,;t t
         [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [5875] s,@CPP@,$CPP,;t t
       [Marcador de problema] line 643: 'FIXME'
         [ 640]     export $ac_envvar ;;
         [ 641] 
         [ 642]   *)
         [ 643]     # FIXME: should be removed in autoconf 3.0.
         [ 644]     echo "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 645]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 646]       echo "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 684: 'FIXME'
         [ 681] 
         [ 682] # There might be people who depend on the old broken behavior: `$host'
         [ 683] # used to hold the argument of --host etc.
         [ 684] # FIXME: To remove some day.
         [ 685] build=$build_alias
         [ 686] host=$host_alias
         [ 687] target=$target_alias
       [Marcador de problema] line 689: 'FIXME'
         [ 686] host=$host_alias
         [ 687] target=$target_alias
         [ 688] 
         [ 689] # FIXME: To remove some day.
         [ 690] if test "x$host_alias" != x; then
         [ 691]   if test "x$build_alias" = x; then
         [ 692]     cross_compiling=maybe
       [Marcador de problema] line 2347: 'FIXME'
         [2344] 	break;;
         [2345]     *.* )
         [2346] 	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
         [2347] 	# FIXME: I believe we export ac_cv_exeext for Libtool,
         [2348] 	# but it would be cool to find out if it's true.  Does anybody
         [2349] 	# maintain Libtool? --akim.
         [2350] 	export ac_cv_exeext
       [Marcador de problema] line 2375: 'FIXME'
         [2372] # the compiler is broken, or we cross compile.
         [2373] echo "$as_me:$LINENO: checking whether the C compiler works" >&5
         [2374] echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
         [2375] # FIXME: These cross compiler hacks should be removed for Autoconf 3.0
         [2376] # If not cross compiling, check that we can run a simple program.
         [2377] if test "$cross_compiling" != yes; then
         [2378]   if { ac_try='./$ac_file'
       [Marcador de problema] line 4501: 'FIXME'
         [4498] int
         [4499] main ()
         [4500] {
         [4501] /* FIXME: Include the comments suggested by Paul. */
         [4502] #ifndef __cplusplus
         [4503]   /* Ultrix mips cc rejects this.  */
         [4504]   typedef int charset[2];
  |- traces.3
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 179: 'NVCCFLAGS'
         [ 176] m4trace:configure.ac:117: -1- AC_SUBST([CUDA_CFLAGS])
         [ 177] m4trace:configure.ac:118: -1- AC_SUBST([CUDA_LIBS])
         [ 178] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
         [ 179] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 180] m4trace:configure.ac:129: -1- AC_PROG_RANLIB
         [ 181] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 182] m4trace:configure.ac:129: -1- AC_SUBST([ac_ct_RANLIB])
  |- requests
  |- output.4t
  |- output.1
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 658: 'NVCCFLAGS'
         [ 655] EGREP
         [ 656] GREP
         [ 657] RANLIB
         [ 658] NVCCFLAGS
         [ 659] NVCC
         [ 660] CUDA_LIBS
         [ 661] CUDA_CFLAGS
       [CUDA Arch / Flags] line 5464: 'NVCCFLAGS'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [CUDA Arch / Flags] line 5464: 'arch=sm_86'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [Marcador de problema] line 7486: 'TODO'
         [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [7485]   # if we detect the quoting.
         [7486]   # TODO: see whether this extra hack can be removed once we start
         [7487]   # requiring Autoconf 2.70 or later.
         [7488]   case $CONFIG_FILES in @%:@(
         [7489]   *\'*) :
       [Marcador de problema] line 1199: 'FIXME'
         [1196]     export $ac_envvar ;;
         [1197] 
         [1198]   *)
         [1199]     # FIXME: should be removed in autoconf 3.0.
         [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 1245: 'FIXME'
         [1242] 
         [1243] # There might be people who depend on the old broken behavior: `$host'
         [1244] # used to hold the argument of --host etc.
         [1245] # FIXME: To remove some day.
         [1246] build=$build_alias
         [1247] host=$host_alias
         [1248] target=$target_alias
       [Marcador de problema] line 1250: 'FIXME'
         [1247] host=$host_alias
         [1248] target=$target_alias
         [1249] 
         [1250] # FIXME: To remove some day.
         [1251] if test "x$host_alias" != x; then
         [1252]   if test "x$build_alias" = x; then
         [1253]     cross_compiling=maybe
       [Marcador de problema] line 4654: 'FIXME'
         [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [4653]    # Losing compiler, so override with the script.
         [4654]    # FIXME: It is wrong to rewrite CC.
         [4655]    # But if we don't then we get into trouble of one sort or another.
         [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
       [Marcador de problema] line 7344: 'FIXME'
         [7341] 
         [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [7343] # If the template does not know about datarootdir, expand it.
         [7344] # FIXME: This hack should be removed a few years after 2.60.
         [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [7346] ac_sed_dataroot='
         [7347] /datarootdir/ {
       [Marcador de problema] line 7375: 'FIXME'
         [7372] 
         [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [7374] # Shell code in configure.ac might set extrasub.
         [7375] # FIXME: do we really want to maintain this feature?
         [7376] cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
         [7377] ac_sed_extra="$ac_vpsub
         [7378] $extrasub
  |- output.4
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 313: 'NVCCFLAGS'
         [ 310] # include <unistd.h>
         [ 311] #endif"
         [ 312] 
         [ 313] ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CLUSTALW_VERSION CLUSTALW_NAME INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CXX CXXFLAGS ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE noopenmp noopenmp_TRUE noopenmp_FALSE CUDA_CFLAGS CUDA_LIBS NVCC NVCCFLAGS RANLIB ac_ct_RANLIB CPP EGREP LIB@&t@OBJS LTLIBOBJS'
         [ 314] ac_subst_files=''
         [ 315] 
         [ 316] # Initialize some variables set by options.
       [CUDA Arch / Flags] line 3660: 'NVCCFLAGS'
         [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [3658]     NVCC="nvcc"
         [3659] fi
         [3660] NVCCFLAGS="-use_fast_math -arch=sm_86  -Xptxas -v -Xcompiler -fopenmp "
         [3661] 
         [3662] 
         [3663] 
       [CUDA Arch / Flags] line 3660: 'arch=sm_13'
         [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [3658]     NVCC="nvcc"
         [3659] fi
         [3660] NVCCFLAGS="-use_fast_math -arch=sm_86  -Xptxas -v -Xcompiler -fopenmp "
         [3661] 
         [3662] 
         [3663] 
       [CUDA Arch / Flags] line 5872: 'NVCCFLAGS'
         [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [5871] s,@NVCC@,$NVCC,;t t
         [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [5873] s,@RANLIB@,$RANLIB,;t t
         [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [5875] s,@CPP@,$CPP,;t t
       [CUDA Arch / Flags] line 5872: 'NVCCFLAGS'
         [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [5871] s,@NVCC@,$NVCC,;t t
         [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [5873] s,@RANLIB@,$RANLIB,;t t
         [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [5875] s,@CPP@,$CPP,;t t
       [Marcador de problema] line 643: 'FIXME'
         [ 640]     export $ac_envvar ;;
         [ 641] 
         [ 642]   *)
         [ 643]     # FIXME: should be removed in autoconf 3.0.
         [ 644]     echo "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 645]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 646]       echo "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 684: 'FIXME'
         [ 681] 
         [ 682] # There might be people who depend on the old broken behavior: `$host'
         [ 683] # used to hold the argument of --host etc.
         [ 684] # FIXME: To remove some day.
         [ 685] build=$build_alias
         [ 686] host=$host_alias
         [ 687] target=$target_alias
       [Marcador de problema] line 689: 'FIXME'
         [ 686] host=$host_alias
         [ 687] target=$target_alias
         [ 688] 
         [ 689] # FIXME: To remove some day.
         [ 690] if test "x$host_alias" != x; then
         [ 691]   if test "x$build_alias" = x; then
         [ 692]     cross_compiling=maybe
       [Marcador de problema] line 2347: 'FIXME'
         [2344] 	break;;
         [2345]     *.* )
         [2346] 	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
         [2347] 	# FIXME: I believe we export ac_cv_exeext for Libtool,
         [2348] 	# but it would be cool to find out if it's true.  Does anybody
         [2349] 	# maintain Libtool? --akim.
         [2350] 	export ac_cv_exeext
       [Marcador de problema] line 2375: 'FIXME'
         [2372] # the compiler is broken, or we cross compile.
         [2373] echo "$as_me:$LINENO: checking whether the C compiler works" >&5
         [2374] echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
         [2375] # FIXME: These cross compiler hacks should be removed for Autoconf 3.0
         [2376] # If not cross compiling, check that we can run a simple program.
         [2377] if test "$cross_compiling" != yes; then
         [2378]   if { ac_try='./$ac_file'
       [Marcador de problema] line 4501: 'FIXME'
         [4498] int
         [4499] main ()
         [4500] {
         [4501] /* FIXME: Include the comments suggested by Paul. */
         [4502] #ifndef __cplusplus
         [4503]   /* Ultrix mips cc rejects this.  */
         [4504]   typedef int charset[2];
  |- traces.4
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 177: 'NVCCFLAGS'
         [ 174] m4trace:configure.ac:117: -1- AC_SUBST([CUDA_CFLAGS])
         [ 175] m4trace:configure.ac:118: -1- AC_SUBST([CUDA_LIBS])
         [ 176] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
         [ 177] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 178] m4trace:configure.ac:129: -1- AC_PROG_RANLIB
         [ 179] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 180] m4trace:configure.ac:129: -1- AC_SUBST([ac_ct_RANLIB])
  |- traces.1
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 478: 'NVCCFLAGS'
         [ 475] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
         [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
       [CUDA Arch / Flags] line 479: 'NVCCFLAGS'
         [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
       [CUDA Arch / Flags] line 480: 'NVCCFLAGS'
         [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
         [ 483] m4trace:configure.ac:129: -1- m4_pattern_allow([^RANLIB$])

[DIRECTORY] src
  |- Clustal.cpp
    -> Found 51 function(s):
       [line 2]  Author: Mark Larkin
 *
 * Copyright (c)
       [line 17]  added call to calculateMaxLengths()
       [line 118] 
    else if(createOutput)
       [line 182]  new FastPairwiseAlign()
       [line 186]  new FullPairwiseAlign()
       [line 199] 
    vector<int> seqWeight(_numSeqs + 1)
       [line 202]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 228]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 236]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 252]  new MSA()
       [line 294]  STEP 4: OUTPUT THE ALIGNMENT 
    if(createOutput)
       [line 374] 
        else if (userParameters->getStructPenalties2()
       [line 440] 
    vector<int> seqWeights(_numSeqs + 1)
       [line 466]  new FastPairwiseAlign()
       [line 470]  new FullPairwiseAlign()
       [line 503]  new MSA()
       [line 639]  new string(treeName)
       [line 667]  new string(treeName)
       [line 689]  new MSA()
       [line 769]  new FastPairwiseAlign()
       [line 773]  new FullPairwiseAlign()
       [line 842]  new string(path)
       [line 851]  new string(answer)
       [line 886]  new FastPairwiseAlign()
       [line 890]  new FullPairwiseAlign()
       [line 901] 
    vector<int> seqWeights(_numSeqs + 1)
       [line 913]  new MSA()
       [line 929]  new string("")
       [line 957]  Andreas Wilm (UCD)
       [line 957]  edited to support new help system (separate
 * file now which is compiled in)
       [line 1125] 
        else if(code == NOSEQUENCESINFILE)
       [line 1129] 
        else if(code == ALLNAMESNOTDIFFERENT)
       [line 1133] 
        else if(code == EMPTYSEQUENCE)
       [line 1137] 
        else if(code == SEQUENCETOOBIG)
       [line 1141] 
        else if(code == BADFORMAT)
       [line 1290] 
        else if (tolower((*mask)
       [line 1399]  STEP 1: Calculate the sequence weights
    QTcalcWeightsForLowScoreSeg(params)
       [line 1423]  STEP 2: Calculate the profile
    LowScoreSegProfile lowScoreProfile(params->nCols, params->firstSeq,
                                       params->firstSeq + params->nSeqs)
       [line 1528]  the cutoff 

    QTremoveShortSegments(params)
       [line 1545]  are temporarily hidden in the display

    for(i = 0; i < params->nSeqs; i++)
       [line 1595] 
    DistMatrix distMat(alignmentObj.getNumSeqs()
       [line 1610]  it again (it takes too long)
       [line 1621]  nSeqs
        for (i = params->firstSeq + 1; i <= params->firstSeq + params->nSeqs; i++)
       [line 1623]  nSeqs
            for (j = i + 1; j <= params->firstSeq + params->nSeqs; j++)
       [line 1676]  the alignment
    if(alignmentObj.getNumSeqs()
       [line 1756] 
    else if(type == Profile1)
       [line 1761] 
    else if(type == Profile2)
       [line 1790]  new string(treeName)
       [line 1800] 
    else if (!userParameters->getMenuFlag()
       [line 1815] 
    else if(type == Profile2)
       [line 1827]  new string("")
  |- config.h.in~
  |- clustalw_version.h.in
  |- Help.cpp
    -> Found 58 function(s):
       [line 2]  Author: Andreas Wilm
 *
 * Copyright (c)
       [line 8]  Andreas Wilm (UCD)
       [line 84]  help for CLUSTAL W (" + version + ")
       [line 91]  which is used to indicate a GAP (\".\" in MSF-RSF)
       [line 102]  can be calculated from old alignments (read in\n"
"with \"-\" characters to indicate gaps)
       [line 115]  at the start of the file (the token for the entry name field)
       [line 144]  alignments are carried out in 3 stages (automatically done from menu\n"
"item 1 ...Do complete multiple alignments now)
       [line 147]  all sequences are compared to each other (pairwise alignments)
       [line 149]  a dendrogram (like a phylogenetic tree)
       [line 150]  groupings of the sequences by similarity (stored in a file)
       [line 172]  can skip the first stages (pairwise alignments; dendrogram)
       [line 173]  dendrogram file (menu item 3)
       [line 174]  no final multiple alignment (menu item 2)
       [line 178]  alignment formats (CLUSTAL, GCG, NBRF-PIR, PHYLIP, GDE, NEXUS, and FASTA)
       [line 189]  methods: dynamic programming (slow but accurate)
       [line 214]  only exactly matching fragments (k-tuples)
       [line 219]  for speed (max= 2 for proteins; 4 for DNA)
       [line 220]  longer sequences (e.g. >1000 residues)
       [line 225]  matches on each diagonal (in an imaginary\n"
"dot-matrix plot)
       [line 226]   Only the best ones (with most matches)
       [line 261]  The TRANSITION WEIGHT gives transitions (A <--> G or C <--> T \n"
"i.e. purine-purine or pyrimidine-pyrimidine substitutions)
       [line 276]  DNA WEIGHT MATRIX leads to a new menu where a single matrix (not a series)
       [line 312]  avoiding gaps that are too close (set by GAP SEPARATION DISTANCE above)
       [line 322]  You can choose any (or all 6 if you wish)
       [line 331]  format files (multiple sequence file)
       [line 335]  form of phylogenetic analysis (MUCH more than the the modest intro-\n"
"duction offered by this program)
       [line 356]  were aligned (from the guide tree-dendrogram)
       [line 372]  of one or more sequences (e.g. an alignment output file from CLUSTAL\n"
"W)
       [line 378]  to specify gaps (except for MSF-RSF where \".\" is used)
       [line 405]  at that position (raised by multiplying the basic gap opening penalty\n"
"by the number)
       [line 421]  in specified regions (typically secondary structure elements)
       [line 422]  are preferentially opened in the less well conserved regions (typically \n"
"surface loops)
       [line 432]  and Beta Strand (B)
       [line 470]  to the residue(s)
       [line 502]  methods used are NJ (Neighbour Joining)
       [line 503]  calculate distances (percent divergence)
       [line 510]  around gaps (usually)
       [line 511]  of the data if there are many gaps (which is why it is difficult for us to\n"
"make it the default)
       [line 516]  For small divergence (say <10%)
       [line 522]  The corrections used here (for DNA or\n"
"proteins)
       [line 533]  an outgroup (a sequence that you are certain branches at the outside\n"
"of the tree .... certain on biological grounds)
       [line 536]  the tree (roughly equidistant from all tips)
       [line 541]  but some display packages (e.g. TreeTool, TreeView\n"
"and Phylowin)
       [line 564]  spanning the full range of amino acid distance (from almost\n"
"identical sequences to highly divergent ones)
       [line 572]  out database similarity (homology searches)
       [line 587]  you can read in your own (just one matrix, not a series)
       [line 597]  a single matrix (not a series)
       [line 614]  row and column of the matrix (corresponding to the * character)
       [line 635]  a NJ tree (n= number of bootstraps; def. = 1000)
       [line 649]  or UPPER (for GDE output only)
       [line 650]  or ON (for Clustal output only)
       [line 651]  or ON (NEW: for all output formats)
       [line 757]  this format with NJplot (Manolo Gouy)
       [line 758]  that can read and display New Hampshire format are TreeView (Mac/PC)
       [line 809] 
    string s(1, marker)
       [line 810] 
    return GetSection(s)
       [line 825] 
    string s(1, marker)
       [line 826] 
    return GetSectionTitle(s)
  |- FastPairwiseAlign.o
  |- clustalw_version.h
  |- Makefile.in
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 329: 'NVCCFLAGS'
         [ 326] MAKEINFO = @MAKEINFO@
         [ 327] MKDIR_P = @MKDIR_P@
         [ 328] NVCC = @NVCC@
         [ 329] NVCCFLAGS = @NVCCFLAGS@
         [ 330] OBJEXT = @OBJEXT@
         [ 331] PACKAGE = @PACKAGE@
         [ 332] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 329: 'NVCCFLAGS'
         [ 326] MAKEINFO = @MAKEINFO@
         [ 327] MKDIR_P = @MKDIR_P@
         [ 328] NVCC = @NVCC@
         [ 329] NVCCFLAGS = @NVCCFLAGS@
         [ 330] OBJEXT = @OBJEXT@
         [ 331] PACKAGE = @PACKAGE@
         [ 332] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 1843: 'NVCCFLAGS'
         [1840] 
         [1841] 
         [1842] .cu.o:
         [1843] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1844] .o:
         [1845] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1846] 
       [CUDA Arch / Flags] line 1845: 'NVCCFLAGS'
         [1842] .cu.o:
         [1843] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1844] .o:
         [1845] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1846] 
         [1847] # Tell versions [3.59,3.63) of GNU make to not export all variables.
         [1848] # Otherwise a system limit (for SysV at least) may be exceeded.
  |- Makefile
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 329: 'NVCCFLAGS'
         [ 326] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 327] MKDIR_P = /usr/bin/mkdir -p
         [ 328] NVCC = nvcc
         [ 329] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 330] OBJEXT = o
         [ 331] PACKAGE = clustalw
         [ 332] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 329: 'arch=sm_86'
         [ 326] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 327] MKDIR_P = /usr/bin/mkdir -p
         [ 328] NVCC = nvcc
         [ 329] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 330] OBJEXT = o
         [ 331] PACKAGE = clustalw
         [ 332] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 1843: 'NVCCFLAGS'
         [1840] 
         [1841] 
         [1842] .cu.o:
         [1843] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1844] .o:
         [1845] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1846] 
       [CUDA Arch / Flags] line 1845: 'NVCCFLAGS'
         [1842] .cu.o:
         [1843] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1844] .o:
         [1845] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1846] 
         [1847] # Tell versions [3.59,3.63) of GNU make to not export all variables.
         [1848] # Otherwise a system limit (for SysV at least) may be exceeded.
  |- config.h.in
  |- main.cpp
    -> Found 9 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 32] 

int main(int argc, char **argv)
       [line 36]  new UserParameters(false)
       [line 37]  new Utility()
       [line 38]  new SubMatrix()
       [line 39]  new Stats()
       [line 45]  DEBUGFULL    
        if(DEBUGLOG)
       [line 49]  new DebugLog("logfile.txt")
       [line 64] 
        CommandLineParser cmdLineParser(&args, false)
    -> Referências importantes (com snippet):
       [Marcador de problema] line 76: 'FIXME'
         [  73]     }
         [  74]     if (argc<=1 || userParameters->getInteractive())
         [  75]     {
         [  76]         // FIXME: additional parameters like infile are ignored!
         [  77]         InteractiveMenu menu;
         [  78]         userParameters->setMenuFlag(true);
         [  79]         userParameters->setInteractive(true);
  |- Help.h
    -> Found 6 function(s):
       [line 2]  Author: Andreas Wilm
 *
 * Copyright (c)
       [line 30] 
    string GetSection(string marker)
       [line 31] 
    string GetSection(char marker)
       [line 32] 
    string GetSectionTitle(string marker)
       [line 33] 
    string GetSectionTitle(char marker)
       [line 34] 
    vector<string> ListSectionMarkers()
  |- Clustal.h
    -> Found 27 function(s):
       [line 2]  Author: Mark Larkin
 *
 * Copyright (c)
       [line 31] 
        void align(string* phylipName, bool createOutput = true)
       [line 32] 
        void sequencesAlignToProfile(string* phylipName)
       [line 33] 
        void profileAlign(string* p1TreeName, string* p2TreeName)
       [line 34] 
        void doGuideTreeOnly(string* phylipName)
       [line 35] 
        void doAlignUseOldTree(string* phylipName)
       [line 36]         
        void getHelp(string helpPointer, bool printTitle = false)
       [line 37] 
        void getHelp(char helpPointer, bool printTitle = false)
       [line 38] 
        void getFullHelp()
       [line 39] 
        int sequenceInput(bool append)
       [line 40] 
        int profile1Input(string profile1Name = "")
       [line 41] 
        int profile2Input(string profile2Name = "")
       [line 42] 
        int commandLineReadSeq(int firstSeq)
       [line 43] 
        void outputNow()
       [line 44] 
        void phylogeneticTree(string* phylip_name, string* clustal_name, string* dist_name,
                              string* nexus_name, string pimName)
       [line 46] 
        void bootstrapTree(string* phylip_name, string* clustal_name, string* nexus_name)
       [line 47] 
        Alignment* getAlignmentPtr()
       [line 48]  
        void QTcalcLowScoreSegments(LowScoreSegParams* params)
       [line 49] 
        void QTcalcWeightsForLowScoreSeg(LowScoreSegParams* params)
       [line 50] 
        void QTremoveShortSegments(LowScoreSegParams* params)
       [line 51] 
        void QTSetFileNamesForOutput(AlignmentFileNames fileNames)
       [line 52] 
        bool QTRealignSelectedRange(AlignmentFileNames fileNames, int beginPos, int endPos,
        bool realignEndGapPen)
       [line 54] 
        void test()
       [line 59] 
        void initInterface()
       [line 60] 
        void calcGapPenaltyMask(int prfLength, vector<char>* mask, vector<char>* gapMask)
       [line 61] 
        bool useExistingGuideTree(int type, string* phylipName, const string& path)
       [line 62] 
        void promptForNewGuideTreeName(int type, string* treeName, const string& path)
  |- config.h
    -> Found 1 function(s):
       [line 80]  Define to 1 if all of the C90 standard headers exist (not just the ones
   required in a freestanding environment)
  |- stamp-h1
  |- Makefile.am
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 22: 'NVCCFLAGS'
         [  19] bin_PROGRAMS = clustalw2
         [  20] 
         [  21] .cu.o:
         [  22] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [  23] .o:
         [  24] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [  25] 
       [CUDA Arch / Flags] line 24: 'NVCCFLAGS'
         [  21] .cu.o:
         [  22] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [  23] .o:
         [  24] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [  25] 
         [  26] 
         [  27] 
  |- FullPairwiseAlign.o

[DIRECTORY] src/tree
  |- NJTree.cpp
    -> Found 14 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 16]  Improvement ideas in fast_nj_tree()
       [line 84]  zero
     *
     *    And we use (sum_rows[i] + sum_cols[i])
       [line 93]  flag array (set to 1 when killed)
       [line 138]  total is
     * divided by (2.0*fnseqs2)
       [line 140]  that division happen (N*(N-1)
       [line 143]  is equal to the comparison relation between (tmin*2.0*fnseqs2)
       [line 144]  Calculation of (tmin*2.0*fnseqs2)
       [line 144]  so we stop dividing
     * a total value and multiply tmin and (tmin*2.0*fnseqs2)
       [line 148]  some transformation of the equation (to cut operations)
       [line 562] 
            else if (j > minj)
       [line 578] 
            else if (j > mini)
       [line 594]  Set the score values (stored in join[])
       [line 606] 
            else if (j > mini)
  |- TreeInterface.h
    -> Found 22 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 37] 
        auto_ptr<AlignmentSteps> getWeightsAndStepsFromDistMat(vector<int>* seqWeights, 
                                                          DistMatrix* distMat, 
                                                          Alignment *alignPtr, 
                                                          int seq1, int nSeqs, 
                                                          string* phylipName, bool* success)
       [line 45]         
        void getWeightsFromDistMat(vector<int>* seqWeights, DistMatrix* distMat, 
                                   Alignment *alignPtr, int seq1, int nSeqs, 
                                   string* phylipName, bool* success)
       [line 48] 
                                   
        void getWeightsForQtLowScore(vector<int>* seqWeights, DistMatrix* distMat, 
                                   Alignment *alignPtr, int seq1, int nSeqs, 
                                   string* phylipName, bool* success)
       [line 56]                                                   
        auto_ptr<AlignmentSteps> getWeightsAndStepsFromTree(Alignment* alignPtr, 
                                                DistMatrix* distMat, string* treeName,
                                                vector<int>* seqWeights, int fSeq, 
                                                int numSeqs, bool* success)
       [line 65]                                                      
        int getWeightsFromGuideTree(Alignment* alignPtr, DistMatrix* distMat,
                                    string* treeName, vector<int>* seqWeights, int fSeq,
                                    int nSeqs, bool* success)
       [line 73] 
        void getWeightsForProfileAlign(Alignment* alignPtr, DistMatrix* distMat, 
                             string* p1TreeName, vector<int>* p1Weights, string* p2TreeName, 
                    vector<int>* p2Weights, int numSeqs, int profile1NumSeqs, bool useTree1, 
                    bool useTree2, bool* success)
       [line 82] 
        void generateTreeFromDistMat(DistMatrix* distMat, Alignment *alignPtr, 
                                                          int seq1, int nSeqs, 
                                                          string* phylipName, bool* success)
       [line 91]                                                   
        void treeFromAlignment(TreeNames* treeNames, Alignment *alignPtr)
       [line 98] 
        void bootstrapTree(TreeNames* treeNames, Alignment *alignPtr)
       [line 99] 
         
    private:
        auto_ptr<AlignmentSteps> getWeightsAndStepsFromDistMatNJ(vector<int>* seqWeights, 
                                                          DistMatrix* distMat, 
                                                          Alignment *alignPtr, 
                                                          int seq1, int nSeqs, 
                                                          string* phylipName, bool* success)
       [line 106] 
        
        auto_ptr<AlignmentSteps> getWeightsAndStepsUseOldGuideTreeNJ(DistMatrix* distMat, 
                                                   Alignment *alignPtr,  string* treeName,
                                                   vector<int>* seqWeights, 
                                                   int fSeq, int nSeqs, bool* success)
       [line 111] 
                                                             
        int readTreeAndCalcWeightsNJ(Tree* groupTree, Alignment* alignPtr, 
                            DistMatrix* distMat, string* treeName, vector<int>* seqWeights,
                            int fSeq, int nSeqs)
       [line 115] 
        
        int getWeightsFromGuideTreeNJ(Alignment* alignPtr, DistMatrix* distMat,
                                      string* treeName, vector<int>* seqWeights, int fSeq,
                                      int nSeqs, bool* success)
       [line 119] 
        
        void getWeightsFromDistMatNJ(vector<int>* seqWeights, DistMatrix* distMat, 
                                   Alignment *alignPtr, int seq1, int nSeqs, 
                                   string* phylipName, bool* success)
       [line 123]  
        
        void getWeightsForProfileAlignNJ(Alignment* alignPtr, DistMatrix* distMat, 
                             string* p1TreeName, vector<int>* p1Weights, string* p2TreeName, 
                    vector<int>* p2Weights, int numSeqs, int profile1NumSeqs, bool useTree1, 
                    bool useTree2, bool* success)
       [line 128] 
                    
        void generateTreeFromDistMatNJ(DistMatrix* distMat, Alignment *alignPtr, 
                                 int seq1, int nSeqs, string* phylipName, bool* success)
       [line 131] 
        
        auto_ptr<AlignmentSteps> getWeightsAndStepsFromTreeNJ(Alignment* alignPtr, 
                               DistMatrix* distMat, string* treeName,
                               vector<int>* seqWeights, int fSeq, int numSeqs, bool* success)
       [line 137] 
        auto_ptr<AlignmentSteps> getWeightsAndStepsFromDistMatUPGMA(vector<int>* seqWeights, 
                                 DistMatrix* distMat, Alignment *alignPtr, 
                                 int seq1, int nSeqs, string* phylipName, bool* success)
       [line 140] 
                                 
        auto_ptr<AlignmentSteps> generateTreeFromDistMatUPGMA(RootedGuideTree* guideTree,
                             DistMatrix* distMat, Alignment *alignPtr, int seq1, int nSeqs, 
                                            string* phylipName, bool* success)
       [line 144] 
                                 
        void getWeightsFromDistMatUPGMA(vector<int>* seqWeights, DistMatrix* distMat, 
                                   Alignment *alignPtr, int seq1, int nSeqs, 
                                   string* phylipName, bool* success)
       [line 148]  
                                   
        void getWeightsForProfileAlignUPGMA(Alignment* alignPtr, DistMatrix* distMat, 
                             string* p1TreeName, vector<int>* p1Weights, string* p2TreeName, 
                    vector<int>* p2Weights, int numSeqs, int profile1NumSeqs, bool useTree1, 
                    bool useTree2, bool* success)
  |- UnRootedClusterTree.h
    -> Found 5 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 14] 
    public:    
        UnRootedClusterTree()
       [line 16] 
        void treeFromAlignment(TreeNames* treeNames, Alignment *alignPtr)
       [line 17] 
        void treeFromDistMatrix(DistMatrix* distMat, Alignment *alignPtr, int seq1, 
                                int nSeqs, string& phylipName)
       [line 19] 
        void bootstrapTree(TreeNames* treeNames, Alignment *alignPtr)
  |- RandomGenerator.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- ClusterTreeOutput.h
    -> Found 9 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18] 
    public:
        ClusterTreeOutput(clustalw::SeqInfo* seqInfo, int boot)
       [line 20] 
        void printNexusTree(clustalw::PhyloTree* phyloTree, ofstream* tree,
                   clustalw::Alignment *alignPtr, clustalw::DistMatrix* distMat, vector<int>* bootTotals)
       [line 22] 
        void printTree(clustalw::PhyloTree* phyloTree, ofstream* tree, vector<int>* totals)
       [line 23] 
        void printPhylipTree(clustalw::PhyloTree* phyloTree, ofstream* tree,
                   clustalw::Alignment *alignPtr, clustalw::DistMatrix* distMat, vector<int>* bootTotals)
       [line 25] 
        void printTreeDesc(clustalw::PhyloTree* phyloTree)
       [line 26] 
          
    private:
        ClusterTreeOutput()
       [line 29] 
        int twoWaySplit(clustalw::PhyloTree* phyloTree, ofstream* tree, int startRow, 
                    int flag, clustalw::Alignment *alignPtr, vector<int>* bootTotals)
       [line 31] 
        int twoWaySplitNexus(clustalw::PhyloTree* phyloTree, ofstream* tree, int startRow,
                    int flag, clustalw::Alignment *alignPtr, vector<int>* bootTotals)
  |- dayhoff.h
    -> Found 4 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 9] 
   
   Table of estimated PAMS (actual no. of substitutions per 100 residues)
       [line 17]  an arbitrary value of 1000 PAMS (1000% substitution)
       [line 17]   

   These values are derived from a Dayhoff model (1978)
  |- AlignmentSteps.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- NJTree.h
    -> Found 4 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18] 
    public:
        NJTree()
       [line 20] 
        virtual void generateTree(clustalw::PhyloTree* phyTree, clustalw::DistMatrix* distMat, clustalw::SeqInfo* seqInfo,
                                  ofstream* tree = 0)
       [line 22] 
        virtual void setVerbose(bool choice)
  |- AlignmentSteps.h
    -> Found 9 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 31]  Empty vector 
        void saveSet(int n, int *groups)
       [line 32] 
        void saveSet(vector<int>* groups)
       [line 33] 
        int getNumSteps()
       [line 34] 
        string getNextStep()
       [line 35] 
        void printAlignSteps()
       [line 36] 
        const vector<vector<int> >* getSteps()
       [line 37] 
        vector<int>* getStep(int i)
       [line 38] 
        void clear()
  |- Tree.cpp
    -> Found 7 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 203]  assign the sequence nodes (in the same order as in the alignment file)
       [line 213]  is too long for PHYLIP tree format (max " 
                   << clustalw::MAXNAMES << " chars)
       [line 302] 
                else if (j == i + 1)
       [line 680]  same design as TreeNode
        if (p->parent == NULL)
       [line 716]  must be chosen as rootNode
               (non-optimized executables (-O0)
       [line 1216] 
        else if (groups[i] != 0)
  |- UnRootedClusterTree.cpp
    -> Found 15 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 63]  new ClusterTreeOutput(&info, 0)
       [line 65] 
    
        TreeGroups saveTree(numSeqs + 1, vector<int>(numSeqs + 1)
       [line 71]  new NJTree()
       [line 101]  check if any distances overflowed the distance corrections 
        if (overspill > 0)
       [line 112]  Turn on file output 
    

        if (userParameters->getOutputTreeClustal()
       [line 179]  Test to see if the inputs are valid
        if(seq1 < 1 || nSeqs < 1)
       [line 223]  new NJTree()
       [line 224]  new ClusterTreeOutput(&info, 0)
       [line 297]  new NJTree()
       [line 343]  check if any distances overflowed the distance corrections
        if (overspill > 0)
       [line 359]  compute the standard tree 

        if (userParameters->getOutputTreeClustal()
       [line 371] 

        RandomGenerator randGenerator(userParameters->getBootRanSeed()
       [line 443]  check if any distances overflowed the distance corrections 
        if (nfails > 0)
       [line 452]  new ClusterTreeOutput(&info, userParameters->getBootstrapFormat()
  |- ClusterTreeAlgorithm.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18] 
    public:
        virtual void generateTree(clustalw::PhyloTree* phyTree, clustalw::DistMatrix* distMat, clustalw::SeqInfo* seqInfo,
                                  ofstream* tree = 0)
       [line 21] 
        virtual void setVerbose(bool choice)
  |- TreeInterface.cpp
    -> Found 10 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 36]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 43] 
        return getWeightsAndStepsFromDistMatUPGMA(seqWeights, distMat, alignPtr, 
                                                seq1, nSeqs, phylipName, success)
       [line 48] 
        return getWeightsAndStepsFromDistMatNJ(seqWeights, distMat, alignPtr, 
                                                seq1, nSeqs, phylipName, success)
       [line 111] 
    return getWeightsAndStepsFromTreeNJ(alignPtr, distMat, treeName, seqWeights, 
                                        fSeq, numSeqs, success)
       [line 126]     
    return getWeightsFromGuideTreeNJ(alignPtr, distMat, treeName, seqWeights, fSeq, nSeqs, 
                                      success)
       [line 238]  clear the memory used for the phylogenetic tree

    if (nSeqs >= 2)
       [line 352]  new MSA()
       [line 466]  clear the memory used for the phylogenetic tree

    if (numSeqs >= 2)
       [line 614]  new MSA()
    -> Referências importantes (com snippet):
       [Marcador de problema] line 431: 'AW:'
         [ 428]         clusterTree->treeFromDistMatrix(distMat, alignPtr, seq1, nSeqs, copyOfPhylipName);
         [ 429] 
         [ 430]         *phylipName = copyOfPhylipName;
         [ 431]         // AW: message outputted by OutputFile function
         [ 432]         // utilityObject->info("Guide tree        file created:   [%s]",
         [ 433]         //                              phylipName->c_str());
         [ 434]         delete clusterTree;
       [Marcador de problema] line 516: 'AW:'
         [ 513]                                                    nSeqs, copyOfPhylipName);
         [ 514] 
         [ 515]         *phylipName = copyOfPhylipName;
         [ 516]         // AW: message outputted by OutputFile function
         [ 517]         // utilityObject->info("Guide tree        file created:   [%s]",
         [ 518]         //                              phylipName->c_str());
         [ 519]     }
  |- Tree.h
    -> Found 23 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 22] 
        void calcSeqWeights(int firstSeq, int lastSeq, vector<int>* sweight)
       [line 23] 
        int readTree(Alignment* alignPtr, const string& treeFileName, int firstSeq, 
                     int lastSeq)
       [line 25] 
        auto_ptr<AlignmentSteps> createSets(int firstSeq, int lastSeq)
       [line 26] 
        int calcSimilarities(Alignment* alignPtr, DistMatrix* distMat)
       [line 27] 
        void clearTree(TreeNode* p)
       [line 32] 
        void createTree(TreeNode* ptree, TreeNode* parent, ifstream* file)
       [line 33] 
        void createNode(TreeNode* pptr, TreeNode* parent)
       [line 34] 
        TreeNode* insertNode(TreeNode* pptr)
       [line 35] 
        void clearTreeNodes(TreeNode* p)
       [line 36] 
        TreeNode* reRoot(TreeNode* ptree, int nseqs)
       [line 37] 
        TreeNode* insertRoot(TreeNode* p, float diff)
       [line 38] 
        float calcRootMean(TreeNode* root, float *maxDist)
       [line 39] 
        float calcMean(TreeNode* nptr, float *maxDist, int nSeqs)
       [line 40] 
        void orderNodes()
       [line 41] 
        int calcWeight(int leaf)
       [line 42] 
        void skipSpace(ifstream* file)
       [line 43] 
        void groupSeqs(TreeNode* p, int *nextGroups, int nSeqs, AlignmentSteps* stepsPtr)
       [line 44] 
        void markGroup1(TreeNode* p, int *groups, int n)
       [line 45] 
        void markGroup2(TreeNode* p, int *groups, int n)
       [line 46] 
        TreeNode* avail()
       [line 47] 
        void setInfo(TreeNode* p, TreeNode* parent, int pleaf, string pname, float
                     pdist)
       [line 49] 
        void debugReportAllNodes(int nseqs)
  |- ClusterTree.cpp
    -> Found 32 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 55]  left << setw(_maxNames)
       [line 134]  flag positions with gaps (tree_gaps[i] = 1 )
       [line 139]  percentage divergence (/100)
       [line 140]  rate of transition (A <-> G; C <-> T)
       [line 146]  All sites with gaps (in any sequence)
       [line 168]  for every pair of sequence 
    for (m = 1; m < lastSeq - firstSeq + 1; ++m)
       [line 235]  gap in a seq
                if (!clustalw::userParameters->getUseAmbiguities()
       [line 260]  parameter correction for multiple substitutions

            if (!clustalw::userParameters->getKimura()
       [line 297]  fixed << setprecision(4)
       [line 298]  fixed << setprecision(4)
       [line 299]  fixed << setprecision(4)
       [line 300]  fixed << setprecision(0)
       [line 366]  fixed << setprecision(4)
       [line 367]  fixed <<  setprecision(4)
       [line 368]  fixed << setprecision(4)
       [line 369]  fixed << setprecision(0)
       [line 386]  flag positions with gaps (tree_gaps[i] = 1 )
       [line 391]  percentage divergence (/100)
       [line 396]  All sites with gaps (in any sequence)
       [line 416]  for every pair of sequence 
    for (m = 1; m < _numSeqs; ++m)
       [line 502]  formula
                    if (k > 0.0)
       [line 529]  fixed << setprecision(4)
       [line 650]  right << setw(5)
       [line 651]  left << setw(_maxNameSize)
       [line 655]  right << fixed << setprecision(0)
       [line 717] 
    else if (clustalw::userParameters->getMenuFlag()
       [line 742]  G 
    if (((base1 == 17)
       [line 854]  Turn off file output
        if (_DNAFlag)
       [line 868]  Turn off file output
        if (_DNAFlag)
       [line 912]  Turn off file output 
        if (_DNAFlag)
       [line 925]  Turn off file output 
        if (_DNAFlag)
  |- ClusterTree.h
    -> Found 21 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 8]  Generate a tree from alignment (treeFromAlignment)
       [line 9]  Generate a tree from a distance matrix (treeFromDistMatrix)
       [line 10]  Bootstrap a tree (bootstrapTree)
       [line 39] 
        void overspillMessage(int overspill,int total_dists)
       [line 40] 
        void treeGapDelete(clustalw::Alignment *alignPtr)
       [line 41]    
        int dnaDistanceMatrix(ofstream* treeFile, clustalw::Alignment *alignPtr)
       [line 42] 
        int protDistanceMatrix(ofstream* treeFile, clustalw::Alignment *alignPtr)
       [line 43] 
        bool isAmbiguity(int c)
       [line 44] 
        void calcPercIdentity(ofstream* pfile, clustalw::Alignment *alignPtr)
       [line 45] 
        void compareTree(clustalw::PhyloTree* tree1, clustalw::PhyloTree* tree2, vector<int>* hits, int n)
       [line 48] 
        bool transition(int base1, int base2)
       [line 49] 
        void distanceMatrixOutput(ofstream* outFile, clustalw::DistMatrix* matToPrint,
                                  clustalw::Alignment *alignPtr)
       [line 51] 
        bool openFilesForBootstrap(clustalw::OutputFile* clustalFile, clustalw::OutputFile* phylipFile,
                         clustalw::OutputFile* nexusFile, clustalw::TreeNames* treeNames, string* path)
       [line 53] 
        bool openFilesForTreeFromAlignment(clustalw::OutputFile* clustalFile, clustalw::OutputFile* phylipFile,
                            clustalw::OutputFile* distFile, clustalw::OutputFile* nexusFile, clustalw::OutputFile* pimFile, 
                            clustalw::TreeNames* treeNames, string* path)
       [line 56] 
        int calcQuickDistMatForAll(ofstream* clustalFile, ofstream* phylipFile, 
                                   ofstream* nexusFile, ofstream* pimFile, 
                                   ofstream* distFile, clustalw::Alignment* alignPtr)
       [line 59] 
                                   
        int calcQuickDistMatForSubSet(ofstream* clustalFile, ofstream* phylipFile, 
                                      ofstream* nexusFile, clustalw::Alignment* alignPtr, 
                                      bool inBootLoop = false)
       [line 63] 
        void printBootstrapHeaderToClustalFile(ofstream* clustalFile)
       [line 64] 
        void promptForBoolSeedAndNumTrials()
       [line 65] 
        void printErrorMessageForBootstrap(int totalOverspill, int totalDists, int nfails)
       [line 66] 
        bool checkIfConditionsMet(int numSeqs, int min)
  |- ClusterTreeOutput.cpp
    -> Found 18 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 53]  fixed << setprecision(5)
       [line 62]  fixed << setprecision(5)
       [line 75]  fixed << setprecision(5)
       [line 88]  fixed << setprecision(5)
       [line 143]  fixed << setprecision(5)
       [line 163]  fixed << setprecision(5)
       [line 195]  fixed << setprecision(5)
       [line 209]  fixed << setprecision(5)
       [line 248]  fixed << setprecision(5)
       [line 250]  fixed << setprecision(5)
       [line 260]  fixed << setprecision(5)
       [line 272]  fixed << setprecision(5)
       [line 285]  fixed << setprecision(5)
       [line 342]  fixed << setprecision(5)
       [line 361]  fixed << setprecision(5)
       [line 392]  fixed << setprecision(5)
       [line 406]  fixed << setprecision(5)
  |- RandomGenerator.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 26] 
        unsigned long addRand(unsigned long r)
       [line 32] 
        unsigned long mult(unsigned long p, unsigned long q)

[DIRECTORY] src/tree/UPGMA
  |- Node.cpp
    -> Found 2 function(s):
       [line 39]  new Node(*this)
       [line 68]  We search from the end of our area of the array       
    for(int i = numDists; --i; distIterator++)
  |- RootedGuideTree.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- RootedClusterTree.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 20]  
        void treeFromAlignment(TreeNames* treeNames, Alignment *alignPtr)
       [line 21] 
        auto_ptr<AlignmentSteps> treeFromDistMatrix(RootedGuideTree* phyloTree, 
                                        DistMatrix* distMat, Alignment *alignPtr, int seq1, 
                                        int nSeqs, string& phylipName)
  |- UPGMAAlgorithm.h
    -> Found 11 function(s):
       [line 22] 
        auto_ptr<AlignmentSteps> generateTree(RootedGuideTree* phyTree, 
                                    DistMatrix* distMat, SeqInfo* seqInfo,
                                    bool overwrite, ofstream* tree = 0)
       [line 25] 
        void setVerbose(bool _verbose)
       [line 30] 
        void printAllNodes(Node** nodes)
       [line 31] 
        void addAlignmentStep(vector<int>* group1, vector<int>* group2)
       [line 32] 
        Node** getNodeWithMinDist(Node** clusters)
       [line 33] 
        void recomputeNodeToJoin1DistMatRow(Node* nodeToJoin1, double** nodeToJoin2DistIter)
       [line 34] 
        void computeAllOtherDistsToNewNode(Node* nodeToJoin1, Node* nodeToJoin2,
                                                   double** nodeToJoin2DistIter)
       [line 36] 
        void computeDistsUpToNodeToJoin2(Node* nToJoin1, Node* nToJoin2, 
                                         double** nodeToJoin2DistIter)
       [line 38] 
        void computeDistsForNodesAfterNode2(Node* nToJoin2)
       [line 39] 
        void movePtrPastUnusedDistances(double** ptrToDist)
       [line 46] 
        double calcNewDist(double dist1, double dist2)
  |- UPGMAAlgorithm.cpp
    -> Found 9 function(s):
       [line 54] 
                      sizeDistMat * sizeof(double)
       [line 81]  new Node(firstSeq, 0, 0)
       [line 89]  new Node(elementIndex + firstSeq, 
                                    distanceMatrix, elementIndex)
       [line 208]  type2 
                    << setw(4)
       [line 268]  For each of the distances in nodeToJoin1           
    while(numDistToUpdate > 0)
       [line 329]  For each node until we get to the second node we are joining           
    for(nodeIter = nodeToJoin1->next; nodeIter != nodeToJoin2; nodeIter = nodeIter->next)
       [line 332]  Skip the distance to the node we are joining with
        movePtrPastUnusedDistances(nodeToJoin2DistIter)
       [line 345] 
        else if ((newDistToNode > nodeIter->minDist)
       [line 393] 
        else if ((distUpdate > nodeIter->minDist)
  |- RootedTreeOutput.h
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 22] 
    public:
        RootedTreeOutput(SeqInfo* seqInfo)
       [line 24] 
        void printPhylipTree(RootedGuideTree* tree, ofstream* ptrToFile, Alignment *alignPtr,
                             DistMatrix* distMat)
       [line 26] 
        void printNexusTree(RootedGuideTree* tree, ofstream* ptrToFile, Alignment *alignPtr, 
                            DistMatrix* distMat)
       [line 28]                    
                
    private:
        void phylipTraverse(ofstream* ptrToFile, Alignment *alignPtr, Node* tree)
       [line 31] 
        void nexusTraverse(ofstream* ptrToFile, Alignment *alignPtr, Node* tree)
  |- Node.h
    -> Found 33 function(s):
       [line 13] 
    public:
    
        Node(int seqNum, double *aptrToDistMatRow, int numDists)
       [line 16] 
        double getDist(int index)
       [line 17] 
        void setDist(int index, double dist)
       [line 18] 
        double* getPtrToDistMatRow()
       [line 19] 
        void setDistMatRowToNull()
       [line 20] 
        int getNumDists()
       [line 21] 
        double getMinDist()
       [line 22] 
        int getIndexToMinDist()
       [line 23] 
        void setMinDist(int index, double d)
       [line 24] 
        int getOrder()
       [line 25] 
        void setOrder(int o)
       [line 26] 
        int getSeqNum()
       [line 27] 
        void setSeqNum(int sNum)
       [line 28] 
        void printNodeInfo()
       [line 29] 
        void printDistMatRow()
       [line 30] 
        void printMinDist()
       [line 31] 
        string elementsToString()
       [line 32]         
        Node* getLeft()
       [line 33] 
        Node* getRight()
       [line 34] 
        void setLeft(Node* l)
       [line 35] 
        void setRight(Node* r)
       [line 36] 
        double getHeight()
       [line 37] 
        void setHeight(double h)
       [line 38] 
        vector<int>* getPtrToElements()
       [line 39] 
        int getFirstElement()
       [line 40] 
        void clearElements()
       [line 41] 
        int getFirstElem()
       [line 42] 
        bool isLeafNode()
       [line 53] 
        
        void merge(Node **rightNode, double _height)
       [line 55] 
        void findMinDist()
       [line 56] 
        void printElements()
       [line 57]       
        void makeEmpty()
       [line 58] 
        void makeEmpty(Node* t)
  |- upgmadata.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- RootedClusterTree.cpp
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 24]  Test to see if the inputs are valid
        if(seq1 < 1 || nSeqs < 1)
       [line 62] 
                
        RootedTreeOutput outputTree(&info)
       [line 140] 
    
        RootedTreeOutput outputTree(&info)
       [line 173]  check if any distances overflowed the distance corrections 
        if (overspill > 0)
       [line 184]  Turn on file output 
    

        if (userParameters->getOutputTreeClustal()
  |- RootedGuideTree.h
    -> Found 12 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 7]  Changes:
 * mark May 8th 2007: removed makeEmpty(Node* t function)
       [line 8]  changed makeEmpty()
       [line 25] 
    public:
        RootedGuideTree()
       [line 29] 
        void setRoot(Node* r)
       [line 30] 
        void makeEmpty()
       [line 31] 
        void calcSeqWeights(int firstSeq, int lastSeq, vector<int>* seqWeights)
       [line 32] 
        Node* getRoot()
       [line 33] 
    private:
        void orderNodes()
       [line 35] 
        int calcOrderNode(Node* node)
       [line 36] 
        void calcWeights(vector<int>* seqWeights)
       [line 37] 
        void doWeightCalc(float weightSoFar, vector<float>* seqWeights, Node* t)
  |- RootedTreeOutput.cpp
    -> Found 7 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 29]  use the distances in the distMat
    if (lastSeq - firstSeq + 1 == 2)
       [line 32]  fixed << setprecision(5)
       [line 34]  fixed << setprecision(5)
       [line 65]  IF we have only 2 seqs
    if (lastSeq - firstSeq + 1 == 2)
       [line 68]  fixed << setprecision(5)
       [line 70]  fixed << setprecision(5)

[DIRECTORY] src/cuda
  |- cudaMultiSeqAlign.h
    -> Found 1 function(s):
       [line 10]  SPThread 0

int cudaMultiSeqAlign(Alignment* alignPtr, DistMatrix* distMat, vector<int>* seqWeight, AlignmentSteps* progSteps, int iStart)
  |- pairwiseAlignInfo.h
    -> Found 3 function(s):
       [line 44] 

    void print_pair()
       [line 69]  constructor
    pairwiseAlignInfo()
       [line 86]  constructor
    pairwiseAlignInfo(pairwiseAlignInfoStruct* CPUInfo, int GPUORNOT)
  |- MSAInfo.h
    -> Found 4 function(s):
       [line 29] 
    string :q


    MSAInfoStruct()
       [line 60] 

    void print_pair()
       [line 94]  constructor
    MSAInfo()
       [line 111]  constructor
    MSAInfo(MSAInfoStruct* CPUInfo, int GPUORNOT)
  |- .dirstamp
  |- cudaMultiSeqAlign.cu
    -> Found 16 function(s):
       [line 25] 

void Random(vector<int>* v)
       [line 39] 

vector<int> Sort_Sets(vector< vector<int> > * ptrToSets)
       [line 119] 
vector<int> Sort_Sets(vector< vector<int> > * ptrToSets)
       [line 151]  check inner
                    for(int inner = 0 ; inner < index.size()
       [line 195] 

int cudaMultiSeqAlign(Alignment* alnPtr, DistMatrix* distMat, vector<int>* seqWeight, AlignmentSteps* progSteps, int iStart)
       [line 209] 
    vector<int> newOutputIndex(numSeqs)
       [line 214]  find the most closely related sequence

    for (int i = 1; i <= numSeqs; i++)
       [line 225]  group the sequences according to their relative divergence

    if (iStart == 0)
       [line 272]  new MyersMillerProfileAlign()
       [line 275]  omp parallel num_threads(numProc)
       [line 280]  omp for schedule(dynamic, 1)
       [line 292]  DEBUGFULL
                            if(logObject && DEBUGLOG)
       [line 298]  new MyersMillerProfileAlign()
       [line 349]  two most closely related sequences now
    if (ix == 0)
       [line 398]  multiply sequence weights from tree by percent identity with new sequence 
        if (userParameters->getNoWeights()
       [line 438] 
            else if (iseq == j)
  |- cudaFullPairwiseAlign.cu
    -> Found 39 function(s):
       [line 30] 
int findMaxLength(vector<vector <int> >& vec )
       [line 38] 

void Set_Element(int2* element, int element_size, int numSeqs)
       [line 52] 
__device__ int mmLength(unsigned char* Sequence,int length,  int gapPos1, int gapPos2)
       [line 61] 

__device__ int2 getGapOpenGapExtend(int DNAFlag, int matAvgScore, PairScaleValues scaleValues, float pwGapOpen, float pwGapExtend, int m, int n)
       [line 68] 
        return make_int2( static_cast<int>(2 * pwGapOpen * intScale * gapOpenScale)
       [line 76] 

        return make_int2(gapOpen , static_cast<int>(pwGapExtend * intScale)
       [line 80] 

__device__ int calcScore(unsigned char* sequence1, unsigned char* sequence2, int i, int j)
       [line 82] 
    return Matrix(sequence1[i] * 32 + sequence2[j])
       [line 84] 

__device__ int cudaCalcScore(unsigned char* sequence1, unsigned char* sequence2, int iat, int jat, int v1, int v2)
       [line 86] 
    return calcScore(sequence1, sequence2, v1 + iat, v2 + jat)
       [line 88] 

__device__ void cudaAdd(int& lastPrint, int& printPtr, int* displ, int v)
       [line 99] 

__device__ void cudaDel(int& lastPrint, int& printPtr, int* displ, int k)
       [line 109] 

__device__ int Gap(int k, int constant , int gapExtend)
       [line 114] 
__device__ int cudaGap(int k, int gapOpen, int gapExtend)
       [line 115] 
    return Gap(k, gapOpen, gapExtend)
       [line 117] 

__device__ int cudaTbGap(int k, int tb, int gapExtend)
       [line 119] 
    return Gap(k, tb, gapExtend)
       [line 121] 

__device__ int cudaTeGap(int k, int te, int gapExtend)
       [line 123] 
    return Gap(k, te, gapExtend)
       [line 125] 

__device__ float cudaTracePath(unsigned char* sequence1, unsigned char* sequence2, int sb1, int sb2, int printPtr, int* displ, int gapPos1, int gapPos2)
       [line 154] 

__device__  void setSequence(unsigned char* Sequence, int* array2D, int length)
       [line 163] 

__device__ void cudaInitHDOrRS(int* HR, int* DS, int gapOpen, int gapExtend, int tbte, int iStart, int iEnd, bool isInc)
       [line 181] 

__device__ void cudaSetHD(int* HH, int* DD, unsigned char* sequence1, unsigned char* sequence2, int gapOpen, int gapExtend, int tb, int A, int B, int iStart, int iEnd, int jStart, int jEnd)
       [line 220] 
            else if(count > 0 && i<= iEnd)
       [line 274] 


__device__ void cudaSetRS(int* RR, int* SS, unsigned char* sequence1, unsigned char* sequence2, int gapOpen, int gapExtend, int te, int A, int B, int iStart, int iEnd, int jStart, int jEnd)
       [line 314] 
            else if(count > 0 && i>= iEnd)
       [line 367] 

__device__ int3 cudaForwardPath(unsigned char* sequence1, unsigned char* sequence2, int n, int m, int gapOpen, int gapExtend, int* HH, int* DD)
       [line 413]      
            else if(i<= n && count > 0)
       [line 468] 

__device__ int3 cudaReversePath(unsigned char* sequence1, unsigned char* sequence2, int n, int m, int gapOpen, int gapExtend, int* HH, int* DD, int3 ScoreAndPosSe)
       [line 518] 
            else if(count > 0 && i >= 1)
       [line 573] 


__device__ 
int cudaDiff(unsigned char* sequence1, unsigned char* sequence2, int* HH, int* DD, int* RR, int* SS, int* displ, int gapOpen, int gapExtend, int3 ScoreAndPosSe, int3 ScoreAndPosSb)
       [line 623] 
             else if(M <= 1)
       [line 731] 



__global__ void cudaFullPairwiseAlignKernel( 
    DyArray2DStruct<int>* sequence,
    float* distMatrix,
    DyArray2DStruct<int>* HH, 
    DyArray2DStruct<int>* DD, 
    DyArray2DStruct<int>* RR, 
    DyArray2DStruct<int>* SS, 
    DyArray2DStruct<int>* displ, 
    int2* element)
       [line 818] 


void cudaFullPairwiseAlign(Alignment* alignPtr, DistMatrix* distMat, int iStart , int iEnd, int jStart, int jEnd)
       [line 901]   constant memory
    pairwiseAlignInfoStruct pair(
            alignPtr->getNumSeqs()
       [line 915] 
    DyArray2DStruct<int> sequenceConvertToArray( &ptrToSequence, findMaxLength(ptrToSequence)
       [line 916] 
    DyArray2DStruct<int> sequence(sequenceConvertToArray , 1)
       [line 917]  
    DyArray2D<int> gSequence(&sequence, 1)
       [line 1065] 


    cout << cudaGetErrorString(cudaGetLastError()
    -> Referências importantes (com snippet):
       [API CUDA Obsoleta] line 1039: 'cudaThreadSynchronize'
         [1036]     }
         [1037] 
         [1038] 
         [1039]     cudaThreadSynchronize();
         [1040]     cudaUnbindTexture(texMatrix);
         [1041]     cudaFree(gElement);
         [1042]     cudaFree(gDistMatrix);
       [API CUDA Obsoleta] line 24: 'texture<'
         [  21] 
         [  22] 
         [  23] #define Matrix(k) tex1Dfetch(texMatrix, k)
         [  24] texture<int, 1, cudaReadModeElementType> texMatrix;
         [  25] 
         [  26] __device__ __constant__ pairwiseAlignInfoStruct gpair;
         [  27] using namespace std;
       [API CUDA Obsoleta] line 897: 'BindTexture'
         [ 894]     cudaMalloc((void**)&gMatrix, sizeof(int)*NUMRES*NUMRES );
         [ 895]     for(int i = 0 ; i < 32 ; i += 32)
         [ 896]         cudaMemcpy(&gMatrix[i], &matrix[i], sizeof(int)*NUMRES*NUMRES, cudaMemcpyHostToDevice);
         [ 897]     cudaBindTexture(0, texMatrix, gMatrix, NUMRES*NUMRES*sizeof(int));
         [ 898] 
         [ 899] 
         [ 900] 
  |- Stack.o
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 11: 'sm_86'
         [   8] 
         [   9]    CbF                            GCC: (Ubuntu 12.3.0-17ubuntu1) 12.3.0           GNU                    zR x                EC
         [  10] Q      <           EC
         [  11] P      \       )    EC
         [  12] `      |           EC
         [  13] U             *    EC
         [  14] a             ^    EC
  |- DyArray1D.h
    -> Found 22 function(s):
       [line 17]  constructor 
    DyArray1DStruct()
       [line 46]  constructor
    DyArray1DStruct(int alloclength, int GPUORNOT)
       [line 52]             cout << cudaGetErrorString(error)
       [line 65]             cout << cudaGetErrorString(error)
       [line 78]             cout << cudaGetErrorString(error)
       [line 100] 

    void allocateCPU(int alloclength)
       [line 107] 


    void allocateGPU(int alloclength, int GPUORNOT)
       [line 115]           cout << cudaGetErrorString(error)
       [line 121]  TO CPU
    void copy(T* dest, int count)
       [line 129]  TO CPU 
    void copy(T* dest, int count, int GPUORNOT)
       [line 140]  TO GPU
    void copyToGPU(T* dest, int count)
       [line 147]  TO GPU
    void copyToGPU(T* dest, int count, int GPUORNOT)
       [line 152] 
    
    void print()
       [line 169]  constructor
    DyArray1D()
       [line 179]  constructor
    DyArray1D(DyArray1DStruct<T>* copy, int GPUORNOT)
       [line 184]             cout << cudaGetErrorString(error)
       [line 192] 


    void allocateGPU(DyArray1DStruct<T>* copy, int GPUORNOT)
       [line 199]             cout << cudaGetErrorString(error)
       [line 207]  TO CPU
    void copy(T* dest, int count)
       [line 212]  TO CPU
    void copy(T* dest, int count, int GPUORNOT)
       [line 218]  TO GPU
    void copyToGPU(T* dest, int count)
       [line 223]  TO GPU
    void copyToGPU(T* dest, int count, int GPUORNOT)
  |- cudaFullPairwiseAlign.h
    -> Found 1 function(s):
       [line 18] 

void cudaFullPairwiseAlign(Alignment* alignPtr, DistMatrix* distMat, int iStart , int iEnd, int jStart, int jEnd)
  |- cudaMultiSeqAlign.cpp
    -> Found 16 function(s):
       [line 16] 

void Random(vector<int>* v)
       [line 30] 

vector<int> Sort_Sets(vector< vector<int> > * ptrToSets)
       [line 110] 
vector<int> Sort_Sets(vector< vector<int> > * ptrToSets)
       [line 142]  check inner
                    for(int inner = 0 ; inner < index.size()
       [line 186] 

int cudaMultiSeqAlign(Alignment* alnPtr, DistMatrix* distMat, vector<int>* seqWeight, AlignmentSteps* progSteps, int iStart)
       [line 200] 
    vector<int> newOutputIndex(numSeqs)
       [line 204]  find the most closely related sequence

    for (int i = 1; i <= numSeqs; i++)
       [line 215]  group the sequences according to their relative divergence

    if (iStart == 0)
       [line 262]  new MyersMillerProfileAlign()
       [line 264]  omp parallel num_threads(numProc)
       [line 269]  omp for schedule(dynamic, 1)
       [line 280]  DEBUGFULL
                            if(logObject && DEBUGLOG)
       [line 285]  new MyersMillerProfileAlign()
       [line 334]  two most closely related sequences now
    if (ix == 0)
       [line 383]  multiply sequence weights from tree by percent identity with new sequence 
        if (userParameters->getNoWeights()
       [line 423] 
            else if (iseq == j)
  |- DyArray2D.h
    -> Found 23 function(s):
       [line 20]  CPU constructor
    DyArray2DStruct()
       [line 88]  allocate with GPU and copy data from CPU
    DyArray2DStruct(const DyArray2DStruct& CPUArray, int GPUORNOT)
       [line 101]  cout << cudaGetErrorString(error)
       [line 115]             cout << cudaGetErrorString(error)
       [line 119]             cout << cudaGetErrorString(error)
       [line 136]           cout << cudaGetErrorString(error)
       [line 140]           cout << cudaGetErrorString(error)
       [line 142]            cout << cudaGetErrorString(error)
       [line 146] 

    void initgpu(int CPUwidth, int CPUheigth, int GPUORNOT)
       [line 156]           cout << cudaGetErrorString(error)
       [line 160]           cout << cudaGetErrorString(error)
       [line 162]             cout << cudaGetErrorString(error)
       [line 192] 

    void copy(T** dest)
       [line 203] 

    void copy(T** dest, int destwidth, int destheigth, int GPUORNOT)
       [line 235] 

    void print()
       [line 260]  constructor
    DyArray2D()
       [line 270]  destructor
    DyArray2D(DyArray2DStruct<T>* copy, int GPUORNOT)
       [line 275]             cout << cudaGetErrorString(error)
       [line 282] 
    void initgpu(DyArray2DStruct<T>* copy, int GPUORNOT)
       [line 313]  TO CPU
    void copy(T** dest)
       [line 318]  TO CPU
    void copy(T** dest, int GPUORNOT)
       [line 323]  TO GPU
    void copyToGPU(T** dest, int width, int heigth)
       [line 328]  TO GPU
    void copyToGPU(T** dest, int width, int heigth, int GPUORNOT)
  |- Stack.cu
    -> Found 4 function(s):
       [line 14] 


template<class T>
__host__ __device__ void StackInit(Stack<T>* s)
       [line 20]  

template<class T>
__host__ __device__ void StackPush(Stack<T>* s, T element)
       [line 26] 

template<class T>
__host__ __device__ T StackPop(Stack<T>* s)
       [line 33] 

template<class T>
__host__ __device__ void StackFree(Stack<T>* s)

[DIRECTORY] src/cuda/.deps
  |- .dirstamp

[DIRECTORY] src/general
  |- clustalw.h
    -> Found 2 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 21]  or DEFINE(clustalx)
  |- Stats.cpp
    -> Found 9 function(s):
       [line 2]  Author: Andreas Wilm
 *
 * Copyright (c)
       [line 41]  Function: PairwiseIdentity()
       [line 58]  float
PairwiseIdentity(char @s1, char @s2)
       [line 96]  but be paranoid
    for (x = 1; x<=alnObj->getSeqLength(s1)
       [line 176]  continue if gap
        if((val < 0)
       [line 218]  i < mhash_get_block_size(MHASH_MD5)
       [line 280] 
    else
        fprintf(fp, "type: protein\n")
       [line 336]  alignment length is the length of any sequence
    fprintf(fp, "aln len: %d\n", alnObj->getSeqLength(1)
       [line 344]  create vector of pairwise identities
    for(int s1 = 1; s1 <= alnObj->getNumSeqs()
  |- SymMatrix.h
    -> Found 22 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 29] 
    public:
        SymMatrix()
       [line 66] 
        
        inline void SetAt(int nRow, int nCol, const double& value)
       [line 72] 
        
        inline double GetAt(int nRow, int nCol)
       [line 78] 
   
        inline void ResizeRect(int size, double val = 0.0)
       [line 99] 
        
        inline void setAllArrayToVal(double* array, int size, double val)
       [line 107]  
        
        inline int getSize()
       [line 112] 

        inline void clearArray()
       [line 132] 
         
        void printArray()
       [line 137] 
        
        void printSubArray()
       [line 142] 
        
        void printArray(double* array, int size)
       [line 165] 
        
        inline int getIndex(const int &i, const int &j, const int &nSeqs)
       [line 178] 
                    throw out_of_range("index out of range\n")
       [line 187] 
                    throw out_of_range("index out of range\n")
       [line 194] 
                throw out_of_range("index out of range\n")
       [line 200] inline
        inline double operator()
       [line 209] 
        
        inline double* getElements()
       [line 214] 
        
        inline int getSizeElements()
       [line 218] 

        inline double* getDistMatrix(int fSeq, int nSeqsInSub)
       [line 243]  Need to fix

                    for(int i = fSeq; i <= lSeq; i++)
       [line 262] 
        
        void clearSubArray()
       [line 273] 
        
        void makeSimilarityMatrix()
  |- debuglogObject.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- VectorUtility.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 16] 
template<class T>
void mergeVectors(std::vector<T>* vecToAddTo, std::vector<T>* vector1, std::vector<T>* vector2)
       [line 37] 
template<class T>
void mergeVectors(std::vector<T>* vecToAddTo, std::vector<T>* vector1)
  |- userparams.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- utils.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- statsObject.h
    -> Found 1 function(s):
       [line 2]  Author: Andreas Wilm
 * 
 * Copyright (c)
  |- OutputFile.cpp
    -> Found 2 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 88] 
    else if (userParameters->getMenuFlag()
  |- UserParameters.cpp
    -> Found 10 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 290]  FIXME: AW: Some parameters are missing here (e.g. the new ones like
 * clustering, etc)
       [line 363]  fixed << setprecision(2)
       [line 369]  fixed << setprecision(2)
       [line 377]  fixed << setprecision(2)
       [line 382]  fixed << setprecision(2)
       [line 421] 
    else if (outputGde)
       [line 425] 
    else if (outputNbrf)
       [line 429] 
    else if (outputPhylip)
       [line 433] 
    else if (outputNexus)
    -> Referências importantes (com snippet):
       [Marcador de problema] line 35: 'FIXME'
         [  32] 
         [  33] UserParameters::UserParameters(bool log)
         [  34] {
         [  35]    // FIXME: huge parts should be merged/replaced with
         [  36]    // setParamsToDefault (which is not used at all)
         [  37] 
         [  38]     gapPos1 = NUMRES - 2; /* code for gaps inserted by clustalw */
       [Marcador de problema] line 177: 'FIXME'
         [ 174] 
         [ 175] }
         [ 176] 
         [ 177] // FIXME:never used
         [ 178] void UserParameters::setParamsToDefault()
         [ 179] {
         [ 180]     DNAGapOpen = 15.0;
       [Marcador de problema] line 290: 'FIXME'
         [ 287]  * a file. It is used for testing and for saving parameters.
         [ 288]  *
         [ 289]  *
         [ 290]  * FIXME: AW: Some parameters are missing here (e.g. the new ones like
         [ 291]  * clustering, etc)
         [ 292]  *
         [ 293]  */
       [Marcador de problema] line 290: 'AW:'
         [ 287]  * a file. It is used for testing and for saving parameters.
         [ 288]  *
         [ 289]  *
         [ 290]  * FIXME: AW: Some parameters are missing here (e.g. the new ones like
         [ 291]  * clustering, etc)
         [ 292]  *
         [ 293]  */
  |- Stats.h
    -> Found 12 function(s):
       [line 2]  Author: Andreas Wilm
 *
 * Copyright (c)
       [line 26] 

    void setStatsFile(string f)
       [line 28] 
    string getStatsFile()
       [line 29] 

    void setEnabled(bool b)
       [line 31] 
    bool isEnabled()
       [line 32] 

    void logCmdLine(int argc, char **argv)
       [line 34] 

    void logInputSeqStats(Alignment *alnObj)
       [line 37] 
    void logAlignedSeqStats(Alignment *alnObj)
       [line 44]  HAVE_MHASH_H
    char * Md5Hash(const char *thread)
       [line 45] 
    string Md5ForSeq(Alignment *alnObj, int s)
       [line 46] 
    string ConcatInputHash(Alignment *alnObj)
       [line 49] 
    float pairwiseIdentity(Alignment *alnObj, int s1, int s2)
  |- OutputFile.h
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 14] 
    public:
        OutputFile()
       [line 17] 
        bool openFile(std::string* fileName, const std::string msg, const std::string* path, 
                      const std::string ext, const std::string fileType)
       [line 19] 
        bool isOpen()
       [line 21] 
        std::ofstream* getPtrToFile()
       [line 22] 
    private:
        std::string getOutputFileName(const std::string prompt, std::string path, 
                                      const std::string fileExtension)
  |- VectorOutOfRange.h
    -> Found 7 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 12] 
    public:
        VectorOutOfRange(std::string vectorName, int index, int max)
       [line 17] 
        int index()
       [line 18] 
        int max()
       [line 19] 
        const char* what()
       [line 20]  const throw()
       [line 20] 
        const char* what()
  |- SymMatrix.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- InvalidCombination.cpp
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 20] 
        public:
            InvalidCombination(int alignResidueType, int alignType)
       [line 24] 
            void whatHappened(std::ostream &os = std::cerr)
  |- SequenceNotFoundException.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 15] 
  virtual const char* what()
       [line 16]  const throw ()
  |- DebugLog.h
    -> Found 5 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 27] 
    public:
        DebugLog(std::string)
       [line 30] 
        void logMsg(std::string)
       [line 31] 
        void logScore(float x)
       [line 32] 
        void printScoreInfo()
  |- UserParameters.h
    -> Found 285 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 33] 
        void setParamsToDefault()
       [line 34] 
        void createParameterOutput()
       [line 35] 
        int resIndex(string t,char c)
       [line 36] 
        void setDNAMultiGap()
       [line 37] 
        void setProtMultiGap()
       [line 38] 
        void setDNAParams()
       [line 39] 
        void setProtParams()
       [line 40] 
        void setPWProteinParam()
       [line 41] 
        void setPWDNAParam()
       [line 42] 
        void setPWParamToProtein()
       [line 43] 
        void setPWParamToDNA()
       [line 44] 
        string getRevisionLevel()
       [line 45] 
        void setRevisionLevel(string value)
       [line 46] 
        bool getInteractive()
       [line 47] 
        void setInteractive(bool value)
       [line 48] 
        float getGapOpen()
       [line 49] 
        void setGapOpen(float value)
       [line 50] 
        float getGapExtend()
       [line 51] 
        void setGapExtend(float value)
       [line 52] 
        float getPWGapOpen()
       [line 53] 
        void setPWGapOpen(float value)
       [line 54] 
        float getPWGapExtend()
       [line 55] 
        void setPWGapExtend(float value)
       [line 56] 
        float getAAGapOpen()
       [line 57] 
        void setAAGapOpen(float gap)
       [line 58] 
        float getAAGapExtend()
       [line 59] 
        void setAAGapExtend(float gap)
       [line 60] 
        float getAAPWGapOpen()
       [line 61] 
        void setAAPWGapOpen(float gap)
       [line 62] 
        float getAAPWGapExtend()
       [line 63] 
        void setAAPWGapExtend(float gap)
       [line 64] 
        int getMaxAA()
       [line 65] 
        void setMaxAA(int value)
       [line 66] 
        int getGapPos1()
       [line 67] 
        void setGapPos1(int value)
       [line 68] 
        int getGapPos2()
       [line 69] 
        void setGapPos2(int value)
       [line 70] 
        int getProfileNum()
       [line 71] 
        void setProfileNum(int value)
       [line 72] 
        bool getMenuFlag()
       [line 73] 
        void setMenuFlag(bool value)
       [line 74] 
        bool getDNAFlag()
       [line 75] 
        void setDNAFlag(bool value)
       [line 76] 
        bool getDistanceTree()
       [line 77] 
        void setDistanceTree(bool value)
       [line 78] 
        string getSeqName()
       [line 79] 
        void setSeqName(string value)
       [line 80] 
        float getDNAGapOpen()
       [line 81] 
        void setDNAGapOpen(float value)
       [line 82] 
        float getDNAGapExtend()
       [line 83] 
        void setDNAGapExtend(float value)
       [line 84] 
        float getProteinGapOpen()
       [line 85] 
        void setProteinGapOpen(float value)
       [line 86] 
        float getProteinGapExtend()
       [line 87] 
        void setProteinGapExtend(float value)
       [line 88] 
        int getGapDist()
       [line 89] 
        void setGapDist(int value)
       [line 90] 
        int getOutputOrder()
       [line 91] 
        void setOutputOrder(int value)
       [line 92] 
        void toggleOutputOrder()
       [line 93] 
        int getDivergenceCutoff()
       [line 94] 
        void setDivergenceCutoff(int value)
       [line 95] 


        string getHydResidues()
       [line 98] 
        void setHydResidues(string value)
       [line 99] 
        bool getNoWeights()
       [line 100] 
        void setNoWeights(bool value)
       [line 101] 
        bool getUseNegMatrix()
       [line 102] 
        void setUseNegMatrix(bool value)
       [line 103] 
        void toggleUseNegMatrix()
       [line 104] 
        bool getNoHydPenalties()
       [line 105] 
        void setNoHydPenalties(bool value)
       [line 106] 
        void toggleNoHydPenalties()
       [line 107] 
        bool getNoVarPenalties()
       [line 108] 
        void setNoVarPenalties(bool value)
       [line 109] 
        bool getNoPrefPenalties()
       [line 110] 
        void setNoPrefPenalties(bool value)
       [line 111] 
        void toggleNoPrefPenalties()
       [line 112] 
        bool getUseEndGaps()
       [line 113] 
        void setUseEndGaps(bool value)
       [line 114] 
        void toggleUseEndGaps()
       [line 115] 
        bool getEndGapPenalties()
       [line 116] 
        void setEndGapPenalties(bool value)
       [line 117] 
        bool getResetAlignmentsNew()
       [line 118] 
        void setResetAlignmentsNew(bool value)
       [line 119] 
        bool getResetAlignmentsAll()
       [line 120] 
        void toggleResetAlignmentsNew()
       [line 121] 
        void setResetAlignmentsAll(bool value)
       [line 122] 
        int getOutputStructPenalties()
       [line 123] 
        void setOutputStructPenalties(int value)
       [line 124] 
        int getStructPenalties1()
       [line 125] 
        void setStructPenalties1(int value)
       [line 126] 
        int getStructPenalties2()
       [line 127] 
        void setStructPenalties2(int value)
       [line 128] 
        bool getUseSS1()
       [line 129] 
        void setUseSS1(bool value)
       [line 130] 
        void toggleUseSS1()
       [line 131] 
        bool getUseSS2()
       [line 132] 
        void setUseSS2(bool value)
       [line 133] 
        void toggleUseSS2()
       [line 134] 
        int getHelixPenalty()
       [line 135] 
        void setHelixPenalty(int value)
       [line 136] 
        int getStrandPenalty()
       [line 137] 
        void setStrandPenalty(int value)
       [line 138] 
        int getLoopPenalty()
       [line 139] 
        void setLoopPenalty(int value)
       [line 140] 
        int getHelixEndMinus()
       [line 141] 
        void setHelixEndMinus(int value)
       [line 142] 
        int getHelixEndPlus()
       [line 143] 
        void setHelixEndPlus(int value)
       [line 144] 
        int getStrandEndMinus()
       [line 145] 
        void setStrandEndMinus(int value)
       [line 146] 
        int getStrandEndPlus()
       [line 147] 
        void setStrandEndPlus(int value)
       [line 148] 
        int getHelixEndPenalty()
       [line 149] 
        void setHelixEndPenalty(int value)
       [line 150] 
        int getStrandEndPenalty()
       [line 151] 
        void setStrandEndPenalty(int value)
       [line 152] 
        bool getUseAmbiguities()
       [line 153] 
        void setUseAmbiguities(bool value)
       [line 154] 
        float getDNAPWGapOpenPenalty()
       [line 155] 
        void setDNAPWGapOpenPenalty(float value)
       [line 156] 
        float getDNAPWGapExtendPenalty()
       [line 157] 
        void setDNAPWGapExtendPenalty(float value)
       [line 158] 
        float getProteinPWGapOpenPenalty()
       [line 159] 
        void setProteinPWGapOpenPenalty(float value)
       [line 160] 
        float getProteinPWGapExtendPenalty()
       [line 161] 
        void setProteinPWGapExtendPenalty(float value)
       [line 162] 

        bool getQuickPairAlign()
       [line 164] 
        void setQuickPairAlign(bool value)
       [line 165] 
        void toggleQuickPairAlign()
       [line 166] 
        float getTransitionWeight()
       [line 167] 
        void setTransitionWeight(float value)
       [line 168] 
        int getDNAKtup()
       [line 169] 
        void setDNAKtup(int value)
       [line 170] 
        int getDNAWindowGap()
       [line 171] 
        void setDNAWindowGap(int value)
       [line 172] 
        int getDNASignif()
       [line 173] 
        void setDNASignif(int value)
       [line 174] 
        int getDNAWindow()
       [line 175] 
        void setDNAWindow(int value)
       [line 176] 
        int getAAKtup()
       [line 177] 
        void setAAKtup(int value)
       [line 178] 
        int getAAWindowGap()
       [line 179] 
        void setAAWindowGap(int value)
       [line 180] 
        int getAASignif()
       [line 181] 
        void setAASignif(int value)
       [line 182] 
        int getAAWindow()
       [line 183] 
        void setAAWindow(int value)
       [line 184] 
        bool getPercent()
       [line 185] 
        void setPercent(bool value)
       [line 186] 
        bool getTossGaps()
       [line 187] 
        void setTossGaps(bool value)
       [line 188] 
        void toggleTossGaps()
       [line 189] 
        bool getKimura()
       [line 190] 
        void setKimura(bool value)
       [line 191] 
        void toggleKimura()
       [line 192] 
        int getBootNumTrials()
       [line 193] 
        void setBootNumTrials(int value)
       [line 194] 
        unsigned int getBootRanSeed()
       [line 195] 
        void setBootRanSeed(unsigned int value)
       [line 196] 
        int getDebug()
       [line 197] 
        void setDebug(int value)
       [line 198] 
        bool getExplicitDNAFlag()
       [line 199] 
        void setExplicitDNAFlag(bool value)
       [line 200] 
        bool getLowercase()
       [line 201] 
        void setLowercase(bool value)
       [line 202] 
        void toggleLowercase()
       [line 203] 
        bool getClSeqNumbers()
       [line 204] 
        void setClSeqNumbers(bool value)
       [line 205] 
        void toggleClSeqNumbers()
       [line 206] 
        bool getSeqRange()
       [line 207] 
        void setSeqRange(bool value)
       [line 208] 
        void toggleSeqRange()
       [line 209] 
        bool getOutputClustal()
       [line 210] 
        void setOutputClustal(bool value)
       [line 211] 
        void toggleOutputClustal()
       [line 212]  
        bool getOutputGCG()
       [line 213] 
        void setOutputGCG(bool value)
       [line 214] 
        void toggleOutputGCG()
       [line 215]  
        bool getOutputPhylip()
       [line 216] 
        void setOutputPhylip(bool value)
       [line 217] 
        void toggleOutputPhylip()
       [line 218]  
        bool getOutputNbrf()
       [line 219] 
        void setOutputNbrf(bool value)
       [line 220] 
        void toggleOutputNbrf()
       [line 221]  
        bool getOutputGde()
       [line 222] 
        void setOutputGde(bool value)
       [line 223] 
        void toggleOutputGde()
       [line 224]  
        bool getOutputNexus()
       [line 225] 
        void setOutputNexus(bool value)
       [line 226] 
        void toggleOutputNexus()
       [line 227]  
        bool getOutputFasta()
       [line 228] 
        void setOutputFasta(bool value)
       [line 229] 
        void toggleOutputFasta()
       [line 230]  
        bool getShowAlign()
       [line 231] 
        void setShowAlign(bool value)
       [line 232] 
        void toggleShowAlign()
       [line 233] 
        bool getSaveParameters()
       [line 234] 
        void setSaveParameters(bool value)
       [line 235] 
        void toggleSaveParameters()
       [line 236] 
        bool getOutputTreeClustal()
       [line 237] 
        void setOutputTreeClustal(bool value)
       [line 238] 
        void toggleOutputTreeClustal()
       [line 239] 
        bool getOutputTreePhylip()
       [line 240] 
        void setOutputTreePhylip(bool value)
       [line 241] 
        void toggleOutputTreePhylip()
       [line 242] 
        bool getOutputTreeDistances()
       [line 243] 
        void setOutputTreeDistances(bool value)
       [line 244] 
        void toggleOutputTreeDistances()
       [line 245] 
        bool getOutputTreeNexus()
       [line 246] 
        void setOutputTreeNexus(bool value)
       [line 247] 
        void toggleOutputTreeNexus()
       [line 248] 
        bool getOutputPim()
       [line 249] 
        void setOutputPim(bool value)
       [line 250] 
        int getBootstrapFormat()
       [line 251] 
        void setBootstrapFormat(int value)
       [line 252] 
        void toggleBootstrapFormat()
       [line 253] 
        string getProfile1Name()
       [line 254] 
        void setProfile1Name(string value)
       [line 255] 
        string getProfile2Name()
       [line 256] 
        void setProfile2Name(string value)
       [line 257] 
        bool getEmpty()
       [line 258] 
        void setEmpty(bool value)
       [line 259] 
        bool getProfile1Empty()
       [line 260] 
        void setProfile1Empty(bool value)
       [line 261] 
        bool getProfile2Empty()
       [line 262] 
        void setProfile2Empty(bool value)
       [line 263] 
        string getOutfileName()
       [line 264] 
        void setOutfileName(string value)
       [line 265] 
        bool getUseTreeFile()
       [line 266] 
        void setUseTreeFile(bool value)
       [line 267] 
        bool getNewTreeFile()
       [line 268] 
        void setNewTreeFile(bool value)
       [line 269] 
        bool getUseTree1File()
       [line 270] 
        void setUseTree1File(bool value)
       [line 271] 
        bool getUseTree2File()
       [line 272] 
        void setUseTree2File(bool value)
       [line 273] 
        bool getNewTree1File()
       [line 274] 
        void setNewTree1File(bool value)
       [line 275] 
        bool getNewTree2File()
       [line 276] 
        void setNewTree2File(bool value)
       [line 277] 
        string getAminoAcidCodes()
       [line 278] 
        char getAminoAcidCode(int i)
       [line 279] 
        void setAminoAcidCodes(string value)
       [line 280] 
        int getKtup()
       [line 281] 
        void setKtup(int value)
       [line 282] 
        int getWindow()
       [line 283] 
        void setWindow(int value)
       [line 284] 
        int getWindowGap()
       [line 285] 
        void setWindowGap(int value)
       [line 286] 
        int getSignif()
       [line 287] 
        void setSignif(int value)
       [line 288] 
        int getRangeFrom()
       [line 289] 
        int getRangeTo()
       [line 290] 
        void setRangeFrom(int from)
       [line 291] 
        void setRangeTo(int to)
       [line 292] 
        bool getRangeFromToSet()
       [line 293] 
        void setRangeFromToSet(bool set)
       [line 294] 
        int getQTScorePlotScale()
       [line 295] 
        void setQTScorePlotScale(int score)
       [line 296] 
        int getQTResExceptionCutOff()
       [line 297] 
        void setQTResExceptionCutOff(int cutOff)
       [line 298] 
        bool getQTseqWeightCalculated()
       [line 299] 
        void setQTseqWeightCalculated(bool calculated)
       [line 300] 
        int getQTminLenLowScoreSegment()
       [line 301] 
        void setQTminLenLowScoreSegment(int minLen)
       [line 302] 
        int getQTlowScoreDNAMarkingScale()
       [line 303] 
        void setQTlowScoreDNAMarkingScale(int dnaScale)
       [line 307] 
        void setNumIterations(int num)
       [line 308] 
        int getNumIterations()
       [line 309] 
        void setDoRemoveFirstIteration(int doIter)
       [line 310] 
        int getDoRemoveFirstIteration()
       [line 311] 
        bool IterationIsEnabled()
       [line 312] 
            
        void setClusterAlgorithm(int clust)
       [line 314] 
        int getClusterAlgorithm()
       [line 315] 
        
        void setDisplayInfo(bool display)
       [line 317] 
        bool getDisplayInfo()
       [line 318] 
        bool getHelpFlag()
       [line 319] 
        void setHelpFlag(bool b)
       [line 320] 
        bool getFullHelpFlag()
       [line 321] 
        void setFullHelpFlag(bool b)
       [line 322] 
        void setMaxAllowedSeqLength(int num)
       [line 323] 
        int getMaxAllowedSeqLength()
       [line 324] 

        bool ResetGapsIsEnabled()
  |- RandomAccessLList.h
    -> Found 12 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 31] 
    public:
        ListElement()
       [line 50] 
        
        unsigned int getIndex()
       [line 63] 
    public:
        RandomAccessLList(int size)
       [line 86] 
        
        unsigned int getNumElements()
       [line 88] 
        
        void addElementToBack(T* element)
       [line 104] 
                else if(numElements > 0)
       [line 113] 
        
        ListElement<T>* getAt(int index)
       [line 126] 
        
        ListElement<T>* getFirst()
       [line 131]         
        
        void removeItem(ListElement<T>* item)
       [line 146] 
                    else if(item->prev == 0)
       [line 155] 
                    else if(item->next == 0)
  |- general.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- VectorOutOfRange.cpp
    -> Found 2 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 22]  const throw()
  |- Array2D.h
    -> Found 17 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18] 
public:
   Array2D()
       [line 26] 
           vector<T> x(nCol)
       [line 31] 
   
   int getRowSize()
       [line 36] 
   
   int getColSize()
       [line 41] 
   
   void SetAt(int nRow, int nCol, const T& value)
       [line 46] 
   T GetAt(int nRow, int nCol)
       [line 50] 
   void GrowRow(int newSize)
       [line 57] 
           vector<T> x(m_dimRow)
       [line 61] 
   void GrowCol(int newSize)
       [line 69] 
   
   void ResizeRect(int row, int col)
       [line 77] 
   void GrowRow(int newSize, const T& value)
       [line 84] 
           vector<T> x(m_dimRow, value)
       [line 88] 
   void GrowCol(int newSize, const T& value)
       [line 96] 
   
   void ResizeRect(int row, int col, const T& value)
       [line 102]    
      
   void printArray()
       [line 114] 
   
   void clearArray()
  |- ClustalWResources.cpp
    -> Found 6 function(s):
       [line 3]  The single instance is (re)
       [line 80] 
    return findFile(string(file)
       [line 111] 
        return string()
       [line 119] 
    return string()
       [line 123]  Search for a (string)
       [line 124]  return the full path as (string)
  |- ClustalWResources.h
    -> Found 11 function(s):
       [line 3]  The single instance is (re)
       [line 35] 
    void setPathToExecutable(std::string pathToFiles)
       [line 38] 
    std::string getDefaultPath()
       [line 39] 
    std::string getInstallPath()
       [line 40] 
    std::string getExecutablePath()
       [line 41] 
    std::string getHomePath()
       [line 42] 

    std::string findFile(const char *file, const ClustalWResourcePathType where = DefaultPath)
       [line 44] 
    std::string findFile(const std::string file, const ClustalWResourcePathType where = DefaultPath)
       [line 45] 
    std::string searchPathsForFile(const std::string fileName)
       [line 48] 
    void dump()
       [line 55] 
    
    std::string dirname(std::string path)
  |- SquareMat.h
    -> Found 13 function(s):
       [line 3]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 16] 
public:
   SquareMat()
       [line 24] 
           vector<T> x(size)
       [line 29] 
   void SetAt(int nRow, int nCol, const T& value)
       [line 33] 
   T GetAt(int nRow, int nCol)
       [line 37] 
   void GrowRow(int newSize)
       [line 44] 
           vector<T> x(m_dimRow)
       [line 48] 
   void GrowCol(int newSize)
       [line 56] 
   
   void ResizeRect(int size)
       [line 62] 

   int getSize()
       [line 67] 

   void clearArray()
       [line 80] 
         
   void printArray()
       [line 87] 
               cout << setprecision(20)
  |- Utility.cpp
    -> Found 4 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 10]  Andreas Wilm (UCD)
       [line 129] 
    else if(choice == '\n')
       [line 503] 
    return sqrt(tmp / v.size()
    -> Referências importantes (com snippet):
       [Marcador de problema] line 250: 'AW:'
         [ 247]  */
         [ 248] bool Utility::lineType(char *line, const char *code)
         [ 249] {
         [ 250]    // AW: introduced sanity check
         [ 251]    int n;
         [ 252]    if (strlen(line)<strlen(code))
         [ 253]      n=strlen(line);
  |- DebugLog.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- Utility.h
    -> Found 30 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 22] 
    public:
        Utility()
       [line 24] 
        char* rTrim(char *str)
       [line 25] 
        void rTrim(string *str)
       [line 26] 
        char* blankToUnderscore(char *str)
       [line 27] 
        string blankToUnderscore(string str)
       [line 28] 
        void getStr(string instr, string& outstr)
       [line 29] 
        char getChoice(string instr)
       [line 30] 
        double getReal(char *instr, double minx, double maxx, double def)
       [line 31] 
        int getInt(char *instr,int minx,int maxx, int def)
       [line 32] 
        unsigned long getUniqueSequenceIdentifier()
       [line 33] 
        bool lineType(char *line, const char *code)
       [line 34] 

        bool blankLine(char *line)
       [line 36] 
        
        void getPath(string str, string *path)
       [line 38] 
        
        virtual char promptForYesNo(char *title,char *prompt)
       [line 40] 
        virtual char promptForYesNo(const char *title,char *prompt)
       [line 41] 
        virtual void error( char *msg,...)
       [line 42] 
        virtual void error( const char *msg,...)
       [line 43] 
        virtual void warning( char *msg,...)
       [line 44] 
        virtual void warning( const char *msg,...)
       [line 45] 
        virtual void info( char *msg,...)
       [line 46] 
        virtual void info( const char *msg,...)
       [line 47] 
        template <class T> T MIN(T x, T y)
       [line 48] 
        template <class T> T MAX(T x, T y)
       [line 51] 
        virtual void setInfoLabelPtr(QLabel* ptrToLabelObj)
       [line 52] 
        bool isNumeric(char ch)
       [line 53] 
        double average(std::vector<double>& v)
       [line 54] 
        double stdDev(std::vector<double>& v)
       [line 55] 
        double median(std::vector<double> v)
       [line 57] 
        void beQuiet(bool b)
  |- param.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)

[DIRECTORY] src/interface
  |- CommandLineParser.h
    -> Found 8 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 44] 
        void parseParams(StringArray* args, bool xmenus)
       [line 45] 
        int checkParam(StringArray* args, StringArray* params, StringArray* paramArg)
       [line 46] 
        void setOptionalParam()
       [line 47] 
        int findMatch(string probe, StringArray* list, int n)
       [line 48] 
        CmdLineData getCmdLineDataStruct(const char *str, int *flag, int type, StringArray* arg)
       [line 49] 
        void printCmdLineData(const CmdLineData& temp)
       [line 50] 
        string ConvertStringToLower(string strToConvert)
  |- InteractiveMenu.h
    -> Found 16 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 31] 
        void mainMenu()
       [line 37] 
        void doSystem()
       [line 38] 
        void multipleAlignMenu()
       [line 39] 
        void profileAlignMenu()
       [line 40] 
        void ssOptionsMenu()
       [line 41] 
        int secStrOutputOptions()
       [line 42] 
        void phylogeneticTreeMenu()
       [line 43] 
        void treeFormatOptionsMenu()
       [line 44] 
        void formatOptionsMenu()
       [line 45]  
        void pairwiseMenu()
       [line 46] 
        void multiMenu()
       [line 47] 
        void gapPenaltiesMenu()
       [line 48] 
        int readMatrix(int alignResidueType, int alignType, MatMenu menu)
       [line 49] 
        void clusteringAlgorithmMenu()
       [line 50] 
        void iterationMenu()
  |- CommandLineParser.cpp
    -> Found 151 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 108]  new Clustal()
       [line 111]  new StringArray(3)
       [line 112]  new StringArray(3)
       [line 113]  new StringArray(3)
       [line 114]  new StringArray(3)
       [line 115]  new StringArray(3)
       [line 116]  new StringArray(3)
       [line 117]  new StringArray(3)
       [line 118]  new StringArray(7)
       [line 119]  new StringArray(5)
       [line 120]  new StringArray(5)
       [line 121]  new StringArray(6)
       [line 122]  new StringArray(3)
       [line 123]  new StringArray(4)
       [line 308]  FIXME: final ctr index is hardcoded in CommandLineParser
    
    parseParams(args, xmenus)
       [line 316]  NOTE any dynamically allocated memory (new)
       [line 337]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 409]  need to check maxseqlen before reading input file
    if (setMaxSeqLen != -1)
       [line 412]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 455]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 467] 
            else if(temp == 1)
       [line 471] 
            else if(temp == 2)
       [line 485]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 556]  the automatic checking (DNA or Protein)
       [line 571] 
            else if(temp == 1)
       [line 584]  DEBUGFULL 
                if(logObject && DEBUGLOG)
       [line 599]  moved to checkParam()
       [line 619]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 622]  file name (seqName)
       [line 676]  profile file (profile 2)
       [line 833] 
        else if(profileType == SEQUENCE)
       [line 861] 
        else if(profileType == SEQUENCE)
       [line 888] 
        else if(profileType == SEQUENCE)
       [line 916] 
        else if(profileType == SEQUENCE)
       [line 950]  NOTE 
    if(userParameters->getDNAFlag()
       [line 972]  input file(s)
       [line 983]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 986]  doing the requested task(s)
       [line 992]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1000]  DEBUGFULL 
                if(logObject && DEBUGLOG)
       [line 1010]  DEBUGFULL 
                if(logObject && DEBUGLOG)
       [line 1018] 

    else if(doAlign)
       [line 1022]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1029] 

    else if(doConvert)
       [line 1033]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1040] 

    else if (doAlignUseOldTree)
       [line 1044]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1051] 

    else if(doGuideTreeOnly)
       [line 1055]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1062] 

    else if(doTreeFromAlign)
       [line 1066]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1074] 

    else if(doBootstrap)
       [line 1078]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1104]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 1117]  AW: first arg is an input file if it doesnt start with commandsep
    if (VALID_COMMAND_SEP.find((*args)
       [line 1137]  because each option should begin with commandsep
                (*params)
       [line 1147]  extract paramArgs in next step

    
    if (args->size()
       [line 1162]  Andreas Wilm (UCD)
       [line 1168]  UNIX
           if(logObject && DEBUGLOG)
       [line 1198]  Andreas Wilm (UCD)
       [line 1199]  this convert nonarg params to lowercase (-QuIcKtReE etc)
       [line 1240]  Andreas Wilm (UCD)
       [line 1245]  UNIX
                 * else if (cmdLinePara[match[i]].type != FILARG && (*paramArg)
       [line 1250]  else if (cmdLinePara[match[i]].type != FILARG && (*paramArg)
       [line 1253]  lowercase arg if not a filename to support mixed case
                        (*paramArg)
       [line 1359]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 1373]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1408]  DEBUGFULL 
                    if(logObject && DEBUGLOG)
       [line 1414] 
            else if(temp == 1)
       [line 1418]  DEBUGFULL 
                    if(logObject && DEBUGLOG)
       [line 1428]  DEBUGFULL 
                    if(logObject && DEBUGLOG)
       [line 1441]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1466]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1478] 
            else if(temp == 1)
       [line 1492]  GDE or PHYLIP *
    if(setOutput != -1)
       [line 1496]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1542]  or PHYLIP or DIST or NEXUS 
    if(setOutputTree != -1)
       [line 1545]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1578]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1590]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1603]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1647]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1686]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1726]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1765]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1777]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1789]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1801]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1814]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1827] 
            else if (_matrixname.compare("pam")
       [line 1831] 
            else if (_matrixname.compare("gonnet")
       [line 1835] 
            else if (_matrixname.compare("id")
       [line 1850] 
                else 
                    exit(1)
       [line 1861]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1875] 
            else if (_matrixname.compare("pam")
       [line 1879] 
            else if (_matrixname.compare("gonnet")
       [line 1883] 
            else if (_matrixname.compare("id")
       [line 1898] 
                else 
                    exit(1)
       [line 1908]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1922] 
            else if (_matrixname.compare("clustalw")
       [line 1937] 
                else 
                    exit(1)
       [line 1947]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1961] 
            else if (_matrixname.compare("clustalw")
       [line 1976] 
                else 
                    exit(1)
       [line 1984]  n
    if(setMaxDiv != -1)
       [line 1987]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2008]  n
    if(setGapDist != -1)
       [line 2011]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2031]  n 
    if(setDebug != -1)
       [line 2050]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2065]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2077] 
            else if(temp == 1)
       [line 2092]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2104] 
            else if(temp == 1)
       [line 2119]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2135] 
            else if(temp == 1)
       [line 2151]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2182]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2215]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2249]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2271]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2306]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2342]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2357] 
        else if(temp == 1)
       [line 2372]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2387] 
        else if(temp == 1)
       [line 2401]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2414]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2427]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2440]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2454]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2468]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2481]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2494]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2516]  n
    if(setHelixGap != -1)
       [line 2519]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2541]  n 
    if(setStrandGap != -1)
       [line 2544]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2566]  n 
    if(setLoopGap != -1)
       [line 2569]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2591]  n
    if(setTerminalGap != -1)
       [line 2594]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2616]  n
    if(setHelixEndIn != -1)
       [line 2619]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2641]  n
    if(setHelixEndOut != -1)
       [line 2644]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2666]  n 
    if(setStrandEndIn != -1)
       [line 2669]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2691]  n 
    if(setStrandEndOut != -1)
       [line 2694]  DEBUGFULL 
            if(logObject && DEBUGLOG)
    -> Referências importantes (com snippet):
       [Marcador de problema] line 218: 'FIXME'
         [ 215]     cmdLineFile[ctr++] = getCmdLineDataStruct("profile1", &setProfile1, FILARG, NULL);
         [ 216]     cmdLineFile[ctr++] = getCmdLineDataStruct("profile2", &setProfile2, FILARG, NULL);
         [ 217]     cmdLineFile[ctr++] = getCmdLineDataStruct("", NULL, -1, NULL);
         [ 218]     // FIXME: final ctr index is hardcoded in CommandLineParser
         [ 219] 
         [ 220]     ctr=0;
         [ 221]     cmdLineVerb[ctr++] = getCmdLineDataStruct("help", &setHelp, NOARG, NULL);
       [Marcador de problema] line 243: 'FIXME'
         [ 240]     cmdLineVerb[ctr++] = getCmdLineDataStruct("iteration", &setDoIteration,
         [ 241]                                            OPTARG, iterationArg);
         [ 242]     cmdLineVerb[ctr++] = getCmdLineDataStruct("", NULL, -1, NULL);
         [ 243]     // FIXME: final ctr index is hardcoded in CommandLineParser.h
         [ 244] 
         [ 245]     // NOTE Start back here!!!!!!!!!!!!
         [ 246]     ctr=0;
       [Marcador de problema] line 308: 'FIXME'
         [ 305]     cmdLinePara[ctr++] = getCmdLineDataStruct("maxseqlen", &setMaxSeqLen, INTARG, NULL);
         [ 306]     cmdLinePara[ctr++] = getCmdLineDataStruct("stats", &setStatsFile, FILARG, NULL);
         [ 307]     cmdLinePara[ctr++] = getCmdLineDataStruct("", NULL, -1, NULL);
         [ 308]     // FIXME: final ctr index is hardcoded in CommandLineParser
         [ 309] 
         [ 310]     parseParams(args, xmenus);
         [ 311] }
       [Marcador de problema] line 1536: 'FIXME'
         [1533]                     userParameters->setOutputFasta(true);
         [1534]                     break;
         [1535]                 default:
         [1536]                     // FIXME AW: 1.83 behaves the same, but shouldnt
         [1537]                     // we exit here?
         [1538]                     cout << "\nUnknown OUTPUT type: " << (*paramArg)[setOutput] << endl;
         [1539]             }
       [Marcador de problema] line 1117: 'AW:'
         [1114]         return 0;
         [1115]     }
         [1116] 
         [1117]     // AW: first arg is an input file if it doesnt start with commandsep
         [1118]     if (VALID_COMMAND_SEP.find((*args)[0][0], 0) == string::npos)
         [1119]     {
         [1120]         name1 = true;
       [Marcador de problema] line 1145: 'AW:'
         [1142]     num = i;
         [1143] 
         [1144] 
         [1145]     // AW:
         [1146]     // params are now setup
         [1147]     // extract paramArgs in next step
         [1148] 
       [Marcador de problema] line 1536: 'AW:'
         [1533]                     userParameters->setOutputFasta(true);
         [1534]                     break;
         [1535]                 default:
         [1536]                     // FIXME AW: 1.83 behaves the same, but shouldnt
         [1537]                     // we exit here?
         [1538]                     cout << "\nUnknown OUTPUT type: " << (*paramArg)[setOutput] << endl;
         [1539]             }
  |- InteractiveMenu.cpp
    -> Found 16 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 33]  new Clustal()
       [line 178] 
        else if(userParameters->getDoRemoveFirstIteration()
       [line 248] 

            default:
                fprintf(stdout, "\n\nUnrecognised Command\n\n")
       [line 718]  Create alignment output file(s)
       [line 803]  fixed << setprecision(2)
       [line 805]  fixed << setprecision(2)
       [line 941]  fixed << setprecision(2)
       [line 943]  fixed << setprecision(2)
       [line 949]  fixed << setprecision(2)
       [line 1151]  Select the matrix series to be using 
        if (option > 0 && option < menu.noptions)
       [line 1156] 
        else if (option == menu.noptions)
       [line 1165] 
        else
        switch (toupper(choice)
       [line 1243] 
        else if(userParameters->getDoRemoveFirstIteration()
       [line 1256]  Tree based iteration (iterates each profile alignment step)
       [line 1257]  Alignment iteration (iterates final alignment only)

[DIRECTORY] src/multipleAlign
  |- ProfileAlignAlgorithm.h
    -> Found 2 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 17] 
    virtual int profileAlign(Alignment* alnPtr, DistMatrix* distMat, vector<int>* group, 
                             int* aligned)
  |- ProfileWithSub.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 19] 
        void resetPrf1()
       [line 20] 
        void calcProfileWithSub(SeqArray* seqArray, vector<int>* gaps, 
                                int matrix[NUMRES][NUMRES], vector<int>* seqWeight)
  |- MyersMillerProfileAlign.h
    -> Found 16 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 20] 
        virtual int profileAlign(Alignment* alnPtr, DistMatrix* distMat, 
                                 vector<int>* group, int* aligned)
       [line 27] 
        void addGGaps(Alignment* alnPtr, SeqArray* seqArray)
       [line 28] 
        void addGGapsMask(vector<char>* mask,int len, vector<int>* path1, vector<int>* path2)
       [line 29] 
        int prfScore(int n, int m)
       [line 30] 
        int progTracepath()
       [line 31] 
        void progDel(int k)
       [line 32] 
        void progAdd(int k)
       [line 33] 
        void progAlign()
       [line 34] 
        int progDiff(int A, int B, int M, int N, int go1, int go2)
       [line 35] 

        int openPenalty1(int i, int j)
       [line 37] 
        int extPenalty1(int i, int j)
       [line 38] 
        int gapPenalty1(int i, int j, int k)
       [line 39] 
        int openPenalty2(int i, int j)
       [line 40] 
        int extPenalty2(int i, int j)
       [line 41] 
        int gapPenalty2(int i, int j, int k)
  |- ProfileStandard.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- ProfileStandard.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 19] 
        void resetPrf2()
       [line 20] 
        void calcStandardProfile(SeqArray* alignment, vector<int>* seqWeight)
  |- ProfileWithSub.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- MyersMillerProfileAlign.cpp
    -> Found 10 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 84] 
        else if ((*group)
       [line 106] 
            else if ((*group)
       [line 285] 
            else if (len1 < len2)
       [line 325]  new ProfileWithSub(prfLength1, 0, nseqs1)
       [line 326]  new ProfileStandard(prfLength2, nseqs1, nseqs1 + nseqs2)
       [line 852] 
            else if (alnPath1[i] == 1)
       [line 895] 
            else if (alnPath2[i] == 1)
       [line 970] 
            else if ((*path1)
       [line 985] 
            else if ((*path2)
  |- ProfileBase.cpp
    -> Found 8 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 77]  Check for a gap penalty mask

    if (useStructPenalties != false)
       [line 83] 
    else if (userParameters->getNoVarPenalties()
       [line 155]  mark the residues close to an existing gap (set gaps[i] = -ve)
       [line 243]  apply the gap penalty mask
        
        if (useStructPenalties != NONE)
       [line 255]  positions
        
        if (profile[j + 1][GAPCOL] <= 0)
       [line 267]  set the penalties at the beginning and end of the profile
    if(userParameters->getEndGapPenalties()
       [line 399] 
    string _hydResidues(userParameters->getHydResidues()
  |- MSA.h
    -> Found 5 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 23] 
        int multiSeqAlign(Alignment* alnPtr, DistMatrix* distMat, 
            vector<int>* seqWeight, AlignmentSteps* progSteps, int iStart)
       [line 25] 
        int seqsAlignToProfile(Alignment* alnPtr, DistMatrix* distMat, vector<int>* seqWeight, int iStart, 
                              string phylipName)
       [line 27] 
        int calcPairwiseForProfileAlign(Alignment* alnPtr, DistMatrix* distMat)
       [line 28] 
        int doProfileAlign(Alignment* alnPtr, DistMatrix* distMat, vector<int>* prof1Weight,
                           vector<int>* prof2Weight)
  |- Iteration.h
    -> Found 4 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 17] 
        bool iterationOnTreeNode(int numSeqsProf1, int numSeqsProf2, int& prfLength1,
                                    int& prfLength2, SeqArray* seqArray)
       [line 19] 
        bool removeFirstIterate(Alignment* alnPtr)
       [line 20] 
    private:
        void printSeqArray(SeqArray* arrayToPrint)
  |- Iteration.cpp
    -> Found 4 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 69] 
            else if(j < numSeqsProf1 + numSeqsProf2)
       [line 84]  I need to recalculate the prfLength1 and prfLength2
            (*seqArray)
       [line 240]  new MSA()
  |- LowScoreSegProfile.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- ProfileBase.h
    -> Found 9 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 23] 
        void calcGapCoeff(SeqArray* seqArray, vector<int>* gaps,  bool useStructPenalties,
                          vector<char>* gapPenaltyMask, int gapCoef, int lenCoef)
       [line 25] 
        const SeqArray* getProfilePtr()
       [line 26] 
        void resetProfile()
       [line 36] 
        void calcVPenalties(SeqArray* aln, vector<int>* weight)
       [line 37]  
        void calcResidueSpecificPen(SeqArray* aln, vector<int>* weight)
       [line 38]  
        void calcHydrophilicPen(SeqArray* aln, vector<int>* weight)
       [line 39]  
        int localPenalty(int penalty, int n, vector<int>* resWeight, vector<int>* hydWeight,
                         vector<int>* vWeight)
       [line 41]   
        float percentId(vector<int>* s1, vector<int>* s2)
  |- LowScoreSegProfile.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 22] 
        void calcLowScoreSegProfile(const SeqArray* seqArray, 
                                int matrix[NUMRES][NUMRES], vector<int>* seqWeight)
       [line 24] 
        const SeqArray* getProfilePtr()
  |- MSA.cpp
    -> Found 10 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 53] 
    
    vector<int> newOutputIndex(_numSeqs)
       [line 75]  group the sequences according to their relative divergence

    if (iStart == 0)
       [line 135]  DEBUGFULL
                    if(logObject && DEBUGLOG)
       [line 203]  two most closely related sequences now
    if (ix == 0)
       [line 264]  multiply sequence weights from tree by percent identity with new sequence 
        if (userParameters->getNoWeights()
       [line 313] 
            else if (iseq == j)
       [line 380]  weights in global variable seq_weight normalised to sum to 100
    vector<int> newOutputIndex(_numSeqs)
       [line 464] 
            else if (iseq == j)
       [line 475]  identity with new sequence 

        for (j = 0; j < _numSeqs; j++)

[DIRECTORY] src/pairwise
  |- FastPairwiseAlign.cpp
    -> Found 9 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 147]  This is bad and will have to be changed (later)
       [line 150]  In the best case the results of the 
 * fast alignment (of DNA)
       [line 155]  This is awfull (it is not OO compliant)
       [line 158]  but this requires changes 
 * to (i)
       [line 162]                 A  B  C  D  E  F  G  H  I  K  L  M  0  N  P  Q  R  S 
 *                T  U  W  X  Y  Z (goodmeasuregoodmeasuregood)
       [line 209]  increment diagonal score for each k_tuple match 

    for (i = 1; i <= limit; ++i)
       [line 231]  choose the top SIGNIF diagonals 

    desQuickSort(displ, diagIndex, tl1)
       [line 241]  flag all diagonals within WINDOW of a top diagonal

    for (i = tl1; i >= j; i--)
  |- FullPairwiseAlign.cpp
    -> Found 4 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 473]  Divide: Find optimum midpoint (midi,midj)
       [line 588]  Conquer recursively around midpoint 


    if (type == 1)
       [line 593]  Type 1 gaps
        diff(A, B, midi, midj, tb, _gapOpen)
  |- FastPairwiseAlign.h
    -> Found 8 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18] 
        virtual void pairwiseAlign(Alignment *alignPtr, DistMatrix *distMat, int iStart, 
                                   int iEnd, int jStart, int jEnd)
       [line 24] 
        void pairAlign(const vector<int>* seq, int l1, int l2)
       [line 25]  
        void makePPtrs(vector<int>& tptr, vector<int>& pl, const vector<int>* seq, 
                       int length)
       [line 27]  
        void makeNPtrs(vector<int>& tptr, vector<int>& pl, const vector<int>* seq, 
                       int length)
       [line 29] 
        void putFrag(int fs, int v1, int v2, int flen)
       [line 30] 
        int fragRelPos(int a1, int b1, int a2, int b2)
       [line 31] 
        void desQuickSort(vector<int>& array1, vector<int>& array2, int arraySize)
  |- FullPairwiseAlign.h
    -> Found 12 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18] 
        virtual void pairwiseAlign(Alignment *alignPtr, DistMatrix *distMat, int iStart, 
                                   int iEnd, int jStart, int jEnd)
       [line 24] 
        void add(int v)
       [line 25] 
        int calcScore(int iat, int jat, int v1, int v2)
       [line 26]  
        float tracePath(int tsb1, int tsb2)
       [line 27] 
        void forwardPass(const vector<int>* seq1, const vector<int>* seq2, int n, int m)
       [line 28] 
        void reversePass(const vector<int>* ia, const vector<int>* ib)
       [line 29] 
        int diff(int A, int B, int M, int N, int tb, int te)
       [line 30] 
        void del(int k)
       [line 31] 
        int gap(int k)
       [line 32] 
        int tbgap(int k, int tb)
       [line 33] 
        int tegap(int k, int te)
  |- PairwiseAlignBase.h
    -> Found 2 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18] 
        virtual void pairwiseAlign(Alignment *alignPtr, DistMatrix *distMat, int iStart, 
                                   int iEnd, int jStart, int jEnd)

[DIRECTORY] src/paralel
  |- 100_1800.dnd
  |- 100_1800.fa
  |- 100_1000.dnd
  |- 100_500.fa
  |- 100_1800.aln
  |- 100_500.aln
  |- 100_1000.aln
  |- 100_1000.fa
  |- 100_500.dnd

[DIRECTORY] src/.deps
  |- RSFFileParser.Po
  |- ProfileBase.Po
  |- InFileStream.Po
  |- Utility.Po
  |- PIRFileParser.Po
  |- FileReader.Po
  |- main.Po
  |- Help.Po
  |- SubMatrix.Po
  |- EMBLFileParser.Po
  |- LowScoreSegProfile.Po
  |- AlignmentOutput.Po
  |- Alignment.Po
  |- OutputFile.Po
  |- RootedClusterTree.Po
  |- AlignmentSteps.Po
  |- NJTree.Po
  |- TreeInterface.Po
  |- VectorOutOfRange.Po
  |- InteractiveMenu.Po
  |- Stats.Po
  |- FastPairwiseAlign.Po
  |- GDEFileParser.Po
  |- PearsonFileParser.Po
  |- UnRootedClusterTree.Po
  |- InvalidCombination.Po
  |- SymMatrix.Po
  |- ObjectiveScore.Po
  |- ProfileWithSub.Po
  |- UPGMAAlgorithm.Po
  |- MyersMillerProfileAlign.Po
  |- RootedTreeOutput.Po
  |- Clustal.Po
  |- MSA.Po
  |- FileParser.Po
  |- Iteration.Po
  |- Tree.Po
  |- CommandLineParser.Po
  |- MSFFileParser.Po
  |- ClusterTreeOutput.Po
  |- Sequence.Po
  |- RandomGenerator.Po
  |- ClusterTree.Po
  |- ClustalWResources.Po
  |- UserParameters.Po
  |- FullPairwiseAlign.Po
  |- DebugLog.Po
  |- ProfileStandard.Po
  |- Node.Po
  |- RootedGuideTree.Po
  |- cudaMultiSeqAlign.Po
  |- ClustalFileParser.Po

[DIRECTORY] src/substitutionMatrix
  |- SubMatrix.cpp
    -> Found 87 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 41]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 54]  new Matrix(blosum30mt, blosum30mt + sizenAAMatrix)
       [line 55]  new Matrix(blosum40mt, blosum40mt + sizenAAMatrix)
       [line 56]  new Matrix(blosum45mt, blosum45mt + sizenAAMatrix)
       [line 57]  new Matrix(blosum62mt2, blosum62mt2 + sizenAAMatrix)
       [line 58]  new Matrix(blosum80mt, blosum80mt + sizenAAMatrix)
       [line 59]  new Matrix(pam20mt, pam20mt + sizenAAMatrix)
       [line 60]  new Matrix(pam60mt, pam60mt + sizenAAMatrix)
       [line 61]  new Matrix(pam120mt, pam120mt + sizenAAMatrix)
       [line 62]  new Matrix(pam350mt, pam350mt + sizenAAMatrix)
       [line 63]  new Matrix(idmat, idmat + sizenAAMatrix)
       [line 64]  new Matrix(gon40mt, gon40mt + sizenAAMatrix)
       [line 65]  new Matrix(gon80mt, gon80mt + sizenAAMatrix)
       [line 66]  new Matrix(gon120mt, gon120mt + sizenAAMatrix)
       [line 67]  new Matrix(gon160mt, gon160mt + sizenAAMatrix)
       [line 68]  new Matrix(gon250mt, gon250mt + sizenAAMatrix)
       [line 69]  new Matrix(gon350mt, gon350mt + sizenAAMatrix)
       [line 70]  new Matrix(clustalvdnamt, clustalvdnamt + sizeDNAMatrix)
       [line 71]  new Matrix(swgapdnamt, swgapdnamt + sizeDNAMatrix)
       [line 110]  new string("gonnet")
       [line 112]  new string("iub")
       [line 114]  new string("gonnet")
       [line 116]  new string("iub")
       [line 264]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 283]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 295] 
        else if (pwDNAMatrixName->compare("clustalw")
       [line 328]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 341] 
        else if (pwMatrixName->compare("pam")
       [line 347] 
        else if (pwMatrixName->compare("gonnet")
       [line 354] 
        else if (pwMatrixName->compare("id")
       [line 376]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 415]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 423]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 437] 
        else if (DNAMatrixName->compare("clustalw")
       [line 477]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 494] 
            else if (pcid > 80.0)
       [line 499] 
            else if (pcid > 60.0)
       [line 504] 
            else if (pcid > 40.0)
       [line 509] 
            else if (pcid > 30.0)
       [line 515] 
            else if (pcid > 20.0)
       [line 530] 
        else if (matrixName->compare("pam")
       [line 538] 
            else if (pcid > 80.0)
       [line 543] 
            else if (pcid > 60.0)
       [line 548] 
            else if (pcid > 40.0)
       [line 561] 
        else if (matrixName->compare("gonnet")
       [line 569] 
            else if (pcid > 35.0)
       [line 575] 
            else if (pcid > 25.0)
       [line 605] 
        else if (matrixName->compare("id")
       [line 612] 
        else if (userSeries)
       [line 663]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 817]  DO THE SAGA MATRIX
        for (i = 0; i <= userParameters->getMaxAA()
       [line 925] 
    ofstream outfile("getmatrix.out")
       [line 1063]  lower limit is greater than upper (%d-%d)
       [line 1153]  j < strlen(inline1)
       [line 1236]  i < strlen(args[farg])
       [line 1353]  new string(_matrixName)
       [line 1354] 
    else if((alignResidueType == Protein)
       [line 1359]  new string(_matrixName)
       [line 1360] 
    else if((alignResidueType == DNA)
       [line 1365]  new string(_matrixName)
       [line 1366] 
    else if((alignResidueType == DNA)
       [line 1371]  new string(_matrixName)
       [line 1375]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 1400] 
    else if((alignResidueType == Protein)
       [line 1404] 
    else if((alignResidueType == DNA)
       [line 1408] 
    else if((alignResidueType == DNA)
       [line 1451] 

    ofstream outfile(nameOfFile)
       [line 1481]  Check to see if the next element is the last element
        if((i + 1)
       [line 1495] 
    
    ofstream outfile2("temp.out")
       [line 1514] 

    ofstream outfile(nameOfFile)
       [line 1547] 
    else if((alignResidueType == Protein)
       [line 1551] 
    else if((alignResidueType == DNA)
       [line 1555] 
    else if((alignResidueType == DNA)
       [line 1574] 
    else if((alignResidueType == Protein)
       [line 1578] 
    else if((alignResidueType == DNA)
       [line 1582] 
    else if((alignResidueType == DNA)
       [line 1599] 
        InvalidCombination ex(alignResidueType, alignType)
       [line 1670] 
        else if (QTDNAHistMatNum == DNACLUSTALW)
       [line 1688] 
        else if (QTAAHistMatNum == AAHISTGONNETPAM80)
       [line 1693] 
        else if (QTAAHistMatNum == AAHISTGONNETPAM120)
       [line 1698] 
        else if (QTAAHistMatNum == AAHISTUSER)
       [line 1703] 
        else if (QTAAHistMatNum == AAHISTGONNETPAM350)
       [line 1734] 
        else if (QTsegmentDNAMatNum == DNACLUSTALW)
       [line 1776] 
        else if (QTsegmentAAMatNum == QTAASEGGONNETPAM120)
       [line 1781] 
        else if (QTsegmentAAMatNum == QTAASEGUSER)
       [line 1786] 
        else if (QTsegmentAAMatNum == QTAASEGGONNETPAM350)
  |- SubMatrix.h
    -> Found 41 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 12]  or they can select one of the matrix series (e.g Blosum)
       [line 45] 
        
        bool getUserMatFromFile(char *str, int alignResidueType, int alignType)
       [line 47] 
        bool getAAScoreMatFromFile(char *str)
       [line 48] 
        bool getDNAScoreMatFromFile(char *str)
       [line 49] 
        bool getQTLowScoreMatFromFile(char *fileName, bool dna)
       [line 50] 
        bool getUserMatSeriesFromFile(char *str)
       [line 51] 
        void setCurrentNameAndNum(string _matrixName, int _matrixNum, int alignResidueType,
                                  int alignType)
       [line 53] 
        int getMatrixNumForMenu(int alignResidueType, int alignType)
       [line 54] 
        int getPairwiseMatrix(int matrix[NUMRES][NUMRES], PairScaleValues& scale, 
                              int& matAvg)
       [line 56] 
        int getProfileAlignMatrix(int matrix[NUMRES][NUMRES], double pcid, int minLen, 
                                  PrfScaleValues& scaleParam, int& matAvg)
       [line 58] 
        int getAlnScoreMatrix(int matrix[NUMRES][NUMRES])
       [line 60]  
        int getMatrixNum()
       [line 61] 
        int getDNAMatrixNum()
       [line 62] 
        int getPWMatrixNum()
       [line 63] 
        int getPWDNAMatrixNum()
       [line 64] 
        void getQTMatrixForHistogram(int matrix[NUMRES][NUMRES])
       [line 66]  NOTE Qt
        int getQTAAHistMatNum()
       [line 67] 
        int getQTDNAHistMatNum()
       [line 68] 
        void setQTAAHistMatNum(int num)
       [line 69] 
        void setQTDNAHistMatNum(int num)
       [line 70] 

        void getQTMatrixForLowScoreSeg(int matrix[NUMRES][NUMRES])
       [line 72] 
        int getQTsegmentDNAMatNum()
       [line 73] 
        void setQTsegmentDNAMatNum(int dnaMat)
       [line 74] 
        int getQTsegmentAAMatNum()
       [line 75] 
        void setQTsegmentAAMatNum(int aaMat)
       [line 76] 
        
        void tempInterface(int alignResidueType, int alignType)
       [line 78] 
        void setValuesToDefault()
       [line 84] 
        int getMatrix(Matrix* matPtr, Xref* xref, int matrix[NUMRES][NUMRES],
                      bool negFlag, int scale, bool minimise = false)
       [line 86]  
        int readMatrixSeries(const char *fileName, Matrix& userMat, Xref& xref)
       [line 87] 
        int readUserMatrix(const char *fileName, Matrix& userMat, Xref& xref)
       [line 88] 
        int getArgs(char *inline1, char *args[], int max)
       [line 89] 
        void setUpCrossReferences()
       [line 90] 
        bool commentline(char* line)
       [line 93] 
        void printGetMatrixResults(int mat[NUMRES][NUMRES])
       [line 94]  
        void compareMatrices(int mat1[NUMRES][NUMRES], int mat2[NUMRES][NUMRES])
       [line 95]  
        void printInFormat(vector<short>& temp, char* name = "tempfile.out")
       [line 96] 
        void printVectorToFile(vector<short>& temp, char* name = "tempfile.out")
       [line 97] 
        Matrix* getUserMatAddress(int alignResidueType, int alignType)
       [line 98] 
        Xref* getUserXrefAddress(int alignResidueType, int alignType)
       [line 99] 
        void checkResidueAndAlignType(int alignResidueType, int alignType)
  |- matrices.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- globalmatrix.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)

[DIRECTORY] src/alignment
  |- Sequence.h
    -> Found 11 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 34] 
        void encodeSequence()
       [line 35] 
        void printSequence()
       [line 36] 
        std::vector<int>* getSequence()
       [line 37] 
        bool isEmpty()
       [line 38] 
        std::string getName()
       [line 39] 
        std::string getTitle()
       [line 40] 
        bool checkDNAFlag()
       [line 41] 
        unsigned long getIdentifier()
       [line 46] 
        void checkIntegrity()
       [line 47] 
        void copyStringIntoVector(std::vector<char>* _vectorTo, std::string* _stringFrom)
  |- Alignment.cpp
    -> Found 43 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 12]  modified searchForString()
       [line 16]  added testUniqueNames()
       [line 43]  Andreas Wilm (UCD)
       [line 44]  remove gaps from older alignments (code = gap_pos1)
       [line 109]  Andreas Wilm (UCD)
       [line 119]  Andreas Wilm (UCD)
       [line 186]  Andreas Wilm (UCD)
       [line 211]  Check if the size is correct
    if(outputIndexToAdd->size()
       [line 232]  Check if the size is correct
    if((outputIndexToAppend->size()
       [line 377] 
        return string()
       [line 379] 
        return string()
       [line 400]  over new candidate names
    for (newName = seqVector->begin()
       [line 402]  over old stored names
        for (oldName = names.begin()
       [line 611]  remove gaps from older alignments (code = gap_pos1)
       [line 642]  Andreas Wilm (UCD)
       [line 658]  j < getSeqLength(1)
       [line 669]  j < getSeqLength(1)
       [line 909]  std::left << setw(maxNames)
       [line 910]  std::right << setw(6)
       [line 921]  std::left << setw(maxNames)
       [line 922]  std::right << setw(6)
       [line 1009] 
        throw VectorOutOfRange(string("secStructMask1")
       [line 1021] 
        throw VectorOutOfRange(string("secStructMask2")
       [line 1033] 
        throw VectorOutOfRange(string("gapPenaltyMask1")
       [line 1045] 
        throw VectorOutOfRange(string("gapPenaltyMask2")
       [line 1057] 
        throw VectorOutOfRange(string("names")
       [line 1073] 
        throw VectorOutOfRange(string("sequenceIds")
       [line 1085] 
        throw VectorOutOfRange(string("titles")
       [line 1097] 
        throw VectorOutOfRange(string("outputIndex")
       [line 1109] 
        throw VectorOutOfRange(string("seqWeight")
       [line 1254] 
        else if(n % 2 == 0)
       [line 1286] 
            else if(t - (int)
       [line 1312]  p < getSeqLength(s + 1)
       [line 1389]  nige
            for(int i = 0; i < searchSize && (i + res)
       [line 1396] 
                else if (seqArray[seq][res + i] == 31 || seqArray[seq][res + i] == 30)
       [line 1632] 
            Sequence SeqToCut(&seqArray[i - numCutSoFar], *namesIterator, *titlesIterator, 
                              *sequenceIdsIterator)
       [line 1687]  endPos > getLengthLongestSequence()
       [line 1700]  recalculate the maxLengths
    calculateMaxLengths()
       [line 1706]  reset the weights
    resetAllSeqWeights()
       [line 1961]  Remove all the elements from the old ones and set them to be these arrays
    clearSeqArray()
       [line 1977] 
            return getSequence(i)
       [line 1982] 
    throw SequenceNotFoundException()
  |- AlignmentOutput.cpp
    -> Found 60 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 11]  clustalx code used (firsRes, length)
       [line 12]  while the port uses (firsRes, lastRes)
       [line 555] 
    else if (userParameters->getMenuFlag()
       [line 600]  round to a multiple of 10
        if (lineLength > LINELENGTH || lineLength <= 0)
       [line 611]  nige
            for(j = firstRes; j <= lastRes; j++)
       [line 626] 
                else if((val < 0)
       [line 715]  nige
            for(j = firstRes; j <= lastRes; j++)
       [line 730] 
                else if((val < 0)
       [line 741]  to make all sequences the same length 
            for(; j <= firstRes + lastRes - 1; j++)
       [line 772]  nige

        for(ii = firstSeq; ii <= lastSeq; ii++)
       [line 780]  nige
                          << setw(5)
       [line 782]  fixed << setprecision(1)
       [line 786]  nige
        if(length % GCG_LINELENGTH != 0)
       [line 796]  nige
            
            for(ii = firstSeq; ii <= lastSeq; ii++)
       [line 826]  characters to end 
            
                    if (j + firstRes - 1 <= alignPtr->getSeqLength(i)
       [line 840] 
                    else if((val < 0)
       [line 939]  nige
        if(length % GCG_LINELENGTH != 0)
       [line 1000] 
                    else if((val < 0)
       [line 1058]  nige
        if(length % GCG_LINELENGTH != 0)
       [line 1086]  nige
            for(ii = firstSeq; ii <= lastSeq; ii++)
       [line 1127] 
                    else if((val < 0)
       [line 1192]  round to a multiple of 10
        if (lineLength > LINELENGTH || lineLength <= 0)
       [line 1198]  set it up
        if (userParameters->getStructPenalties1()
       [line 1213]  set it up
        if (userParameters->getStructPenalties2()
       [line 1249]  nige
            for(j = firstRes; j <= lastRes; j++)
       [line 1264] 
                else if((val < 0)
       [line 1302]  nige
                for(i = firstRes; i <= lastRes; i++)
       [line 1333]  nige
                for(i = firstRes; i <= lastRes; i++)
       [line 1348]  nige
                for(i = 1; i <= length; i++)
       [line 1352]  nige
                    if((i % lineLength == 0)
       [line 1370]  nige
                for(i = firstRes; i <= lastRes; i++)
       [line 1385]  nige
                for(i = 1; i <= length; i++)
       [line 1389]  nige
                    if((i % lineLength == 0)
       [line 1403]  nige
                for(i = firstRes; i < length; i++)
       [line 1418]  nige
                for(i = 1; i <= length; i++)
       [line 1422]  nige
                    if((i % lineLength == 0)
       [line 1475]  round to a multiple of 10
        if (lineLength > LINELENGTH || lineLength <= 0)
       [line 1486]  nige

        for(ii = firstSeq; ii <= lastSeq; ii++)
       [line 1507]  nige
            for(j = firstRes; j <= lastRes; j++)
       [line 1523] 
                else if((val < 0)
       [line 1607]  _numSequences
        if(lastSeq > _numSequences)
       [line 1619]  NOTE june29
                if((val >= 0)
       [line 1671]  round to a multiple of 10
        if (lineLength > LINELENGTH || lineLength <= 0)
       [line 1679]  nige
        if(length % lineLength != 0)
       [line 1711]  Check if we can access mask position first
                        if(ss_mask1.size()
       [line 1892] 
                    else if((val < 0)
       [line 1986]  NOTE june29
                        if(((*alignment)
       [line 1991]  Count how many are identical to the first sequence
                            if((*alignment)
       [line 2036] 
                else if (!userParameters->getDNAFlag()
       [line 2114]  NOTE I have had to use (*structMask)
       [line 2162] 
            else if (tolower(mask->at(i)
       [line 2264]  NOTE june29
            if ((val < 0)
       [line 2286] 
            else if((val < 0)
       [line 2415] 
    else if(userParameters->getOutputNbrf()
       [line 2419] 
    else if(userParameters->getOutputGCG()
       [line 2423] 
    else if(userParameters->getOutputPhylip()
       [line 2427] 
    else if(userParameters->getOutputGde()
       [line 2431] 
    else if(userParameters->getOutputNexus()
       [line 2435] 
    else if(userParameters->getOutputFasta()
  |- Sequence.cpp
    -> Found 2 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 192]  of all characters (except -)
  |- ObjectiveScore.h
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 27]    
    public:
        ObjectiveScore()
       [line 29] 
        long getScore(const Alignment* alnToScore)
       [line 30]     
    private:
        
        float scoreLetters(int seq1, int seq2)
       [line 33] 
        float scoreGaps(int seq1, int seq2)
       [line 34] 
        void calcNormalisedSeqWeights(const vector<int>* seqWeight, 
                                      vector<float>* normSeqWeight)
  |- Alignment.h
    -> Found 91 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 23]  added testUniqueNames()
       [line 49]  sequences it would be nice to have a isAligned flag here (AW)
       [line 62] 
        void addSequences(vector<Sequence>* seqVector)
       [line 63] 
        void addSequences(SeqArray* seqVector)
       [line 64] 
        void appendSequences(vector<Sequence>* seqVector)
       [line 65] 
        vector<Sequence> cutSelectedSequencesFromAlignment(vector<int>* selected)
       [line 66]         
        void pasteSequencesIntoPosition(vector<Sequence>* seqVector, int pos, 
                                        bool explicitPasteToProfile2 = false)
       [line 68] 
                                        
        void resizeSeqArray(int size)
       [line 72] 
        bool addOutputIndex(vector<int>* outputIndexToAdd)
       [line 73] 
        bool appendOutputIndex(vector<int>* outputIndexToAppend)
       [line 74] 
        void addSecStructMask1(vector<char>* secStructMaskToAdd)
       [line 75] 
        void addSecStructMask2(vector<char>* secStructMaskToAdd)
       [line 76] 
        void addSeqWeight(vector<int>* _seqWeight)
       [line 77] 
        void addGapPenaltyMask1(vector<char>* gapPenaltyMaskToAdd)
       [line 78] 
        void addGapPenaltyMask2(vector<char>* gapPenaltyMaskToAdd)
       [line 79] 
        vector<char>* getSecStructMask1()
       [line 80] 
        vector<char>* getSecStructMask2()
       [line 81] 
        const vector<int>* getOutputIndex()
       [line 82] 
        vector<char>* getGapPenaltyMask1()
       [line 83] 
        vector<char>* getGapPenaltyMask2()
       [line 84]      
        void addSecStructName1(string nameToAdd)
       [line 85] 
        void addSecStructName2(string nameToAdd)
       [line 86] 
        int alignScore(void)
       [line 87] 
        int countGaps(int s1, int s2, int l)
       [line 88] 
        void resetAlign()
       [line 89] 
        void fixGaps()
       [line 90] 
        float countid(int s1, int s2)
       [line 91] 
        
        const vector<int>* getSequence(int index)
       [line 93] 
        const vector<int>* getSequence(int index)
       [line 94] 
        const vector<int>* getSequenceFromUniqueId(unsigned long id)
       [line 95]  For iteration        
        const SeqArray* getSeqArray()
       [line 96] 
        SeqArray* getSeqArrayForRealloc()
       [line 97] 
        void updateSequence(int index, const vector<int>* seq)
       [line 98] 
        
        void printSequences()
       [line 100] 
        bool checkAllNamesDifferent()
       [line 101] 
        bool testUniqueNames(vector<Sequence>* seqVector)
       [line 102] 
        void clearAlignment()
       [line 103] 
        void clearSecStruct1()
       [line 104] 
        void clearSecStruct2()
       [line 105] 
        void printAllNames()
       [line 106] 
        void printSequencesAddedInfo()
       [line 107] 
        
        string getSecStructName1()
       [line 109] 
        string getSecStructName2()
       [line 110]         
        int getNumSeqs()
       [line 111] 
        int getMaxNames()
       [line 112] 
        int getMaxAlnLength()
       [line 113] 
        void setMaxAlnLength(int len)
       [line 114]          
        int getLengthLongestSequence()
       [line 115] 
        int getLengthLongestSequence(int firstSeq, int lastSeq)
       [line 116] 
        int getSeqLength(int index)
       [line 117] 
        int getSecStructMask1Element(int index)
       [line 118] 
        int getSecStructMask2Element(int index)
       [line 119] 
        int getGapPenaltyMask1Element(int index)
       [line 120] 
        int getGapPenaltyMask2Element(int index)
       [line 121] 
        int getOutputIndex(int index)
       [line 122] 
        int getSeqWeight(int index)
       [line 123] 
        const vector<int>* getSeqWeights()
       [line 124] 
        string getName(int index)
       [line 125] 
        string getTitle(int index)
       [line 126] 
        vector<int>* QTcalcHistColumnHeights(int firstSeq, int nSeqs, 
                                           Array2D<int>* exceptionalRes)
       [line 132] 
        void resetProfile1()
       [line 133] 
        void resetProfile2()
       [line 134] 
        void resetAllSeqWeights()
       [line 135] 
        
        int searchForString(bool* found, int seq, int beginRes, string search)
       [line 137] 
        void removeGapsFromSelectedSeqs(vector<int>* selected)
       [line 138] 
        void removeGapOnlyColsFromSelectedSeqs(vector<int>* selected)
       [line 139] 
        void removeAllGapOnlyColumns(int fSeq, int lSeq, int profileNum)
       [line 140] 
        void setDefaultOutputIndex()
       [line 141] 
        bool removeAllOutsideRange(int beginPos, int endPos)
       [line 142] 
        bool updateRealignedRange(SeqArray realignedSeqs, int beginPos, int endPos)
       [line 143] 
        bool reloadAlignment()
       [line 144] 
        
        int getProfile1NumSeqs()
       [line 146] 
        void setProfile1NumSeqs(int value)
       [line 147] 
        bool isGap(int seq, int col)
       [line 151] 
        unsigned long getUniqueId(int seq)
       [line 152] 
        void printArray()
       [line 153] 
        void printSeqArray(SeqArray* arrayToPrint)
       [line 154] 
        void printProfile1()
       [line 155] 
        void printProfile2()
       [line 156] 
        void debugPrintOutAlignInfo()
       [line 157] 
        void calculateMaxLengths()
       [line 169] 
            public:
                void begin(Alignment *alignment)
       [line 171] 
                const string next()
       [line 172] 
                bool end()
       [line 177] 
        
        void addSequencesToVector(vector<Sequence>* seqVector)
       [line 179] 
        int getSequenceLength(int index)
       [line 180] 
        void sortScores(vector<float>* scores, int f, int l)
       [line 181] 
        void swap(vector<float>* scores, int s1, int s2)
       [line 182] 
        bool keepPortionOfSeqArray(int beginRangeIndex, int endRangeIndex)
       [line 183] 
        
        void clearSeqArray()
    -> Referências importantes (com snippet):
       [Marcador de problema] line 48: 'FIXME'
         [  45] #include "../general/SequenceNotFoundException.h"
         [  46] 
         [  47] 
         [  48] // FIXME because this object is used for aligned and unaligned
         [  49] // sequences it would be nice to have a isAligned flag here (AW)
         [  50] 
         [  51] using namespace std;
  |- AlignmentOutput.h
    -> Found 18 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 48] 
        bool openAlignmentOutput(string path)
       [line 49] 
        bool QTOpenFilesForOutput(AlignmentFileNames fileNames)
       [line 50] 
        void createAlignmentOutput(Alignment* alignPtr, int firstSeq, int lastSeq)
       [line 51] 
        void printSecStructMask(int prfLength, vector<char>* mask, vector<char>* structMask)
       [line 56] 
        void fastaOut(Alignment* alignPtr, outputRegion partToOutput)
       [line 57] 
        void clustalOut(Alignment* alignPtr, outputRegion partToOutput)
       [line 58] 
        void gcgOut(Alignment* alignPtr, outputRegion partToOutput)
       [line 59] 
        void nexusOut(Alignment* alignPtr, outputRegion partToOutput)
       [line 60] 
        void phylipOut(Alignment* alignPtr, outputRegion partToOutput)
       [line 61] 
        void nbrfOut(Alignment* alignPtr, outputRegion partToOutput)
       [line 62] 
        void gdeOut(Alignment* alignPtr, outputRegion partToOutput)
       [line 63] 
        string nameonly(string s)
       [line 64] 
        
        void findRangeValues(Alignment* alignPtr, rangeNum *rnum, int firstRes, int lastRes, 
                             int firstSeq)
       [line 67] 
        bool openExplicitFile(auto_ptr<ofstream>& outFile, string fileName)
       [line 68] 
        string openOutputFile(auto_ptr<ofstream>& outFile, string prompt, string path, 
                              string fileExtension)
       [line 70] 
        int SeqGCGCheckSum(vector<char>* sequence, int length)
       [line 71] 
        void showAlign()
  |- ObjectiveScore.cpp
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 31]  DEBUGFULL
        if(logObject && DEBUGLOG)
       [line 83]  DEBUGFULL
                if(logObject && DEBUGLOG)
       [line 99]  DEBUGFULL
        if(logObject && DEBUGLOG)
       [line 243] 
        else if(gap2)
       [line 283]  DEBUGFULL
        if(logObject && DEBUGLOG)

[DIRECTORY] src/fileInput
  |- RSFFileParser.cpp
    -> Found 16 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 83] 
                    return Sequence(blank, blank, blank)
       [line 100] 
                return Sequence(blank, blank, blank)
       [line 111]  remember entryname
        for (i = 0; i <= strlen(_sname)
       [line 131] 
                return Sequence(blank, blank, blank)
       [line 145]  EOL
                if (c == '.')
       [line 166]  return empty seq
            return Sequence(blank, blank, blank)
       [line 168] 
        return Sequence(characterSeq, name, title)
       [line 194]  start at the beginning
                
        if(!_fileIn->is_open()
       [line 201]  skip the comments 
        while (_fileIn->getline(_line, MAXLINE + 1)
       [line 257]  skip the comments 
        while (_fileIn->getline(_line, MAXLINE + 1)
       [line 266]  find the start of the sequence entry 
        for (;;)
       [line 291]  remember entryname
            for (i = 0; i <= strlen(_sname)
       [line 304]  gap penalty mask
            while (_fileIn->getline(_line, MAXLINE + 1)
       [line 343] 
                else if (keyword(_line, "sequence")
       [line 390] 
        else if (strcmp(feature, "STRAND")
  |- FileReader.h
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 33] 
        int seqInput(Alignment* alignPtr, bool append)
       [line 34] 
        int readSeqs(Alignment* alignPtr, int firstSeq)
       [line 35] 
        int profileInput(Alignment* alignPtr)
       [line 41] 
        void checkInfile(int* nseqs, auto_ptr<FileParser>& fileParser)
       [line 44] 
        bool noEmptySequence(vector<Sequence> seqRangeVector)
  |- ClustalFileParser.h
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 20] 
        virtual Sequence getSeq(int seqNum)
       [line 21] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 22] 
        virtual int countSeqs()
       [line 23] 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                vector<char>& secStructMask,
               string& secStructName, int &structPenalties, int length)
       [line 31] 
        bool clustalBlankline(char* line)
  |- InFileStream.h
    -> Found 6 function(s):
       [line 2]  Author: Nigel Brown
 * 
 * Copyright (c)
       [line 8]  This is then used by the getline()
       [line 23] 
  public:
    InFileStream()
       [line 27] 

    void open(const char *filename)
       [line 29] 
    void close()
       [line 38] 

  protected:
    char findDelimiter()
  |- EMBLFileParser.h
    -> Found 7 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 20] 
        virtual Sequence getSeq(int seqNum)
       [line 21] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 22] 
        virtual int countSeqs()
       [line 23] 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                vector<char>& secStructMask,
               string& secStructName, int &structPenalties, int length)
       [line 31] 
        void getSwissFeature(char* line, vector<char>& secStructMask, int length)
       [line 32] 
        void getSwissMask(char* line, vector<char>& gapPenaltyMask, int length)
  |- FileParser.h
    -> Found 10 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 15]  Removed delimiter and findDelimiter()
       [line 35] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 36]  VIRTUAL
        virtual Sequence getSeq(int seqNum)
       [line 37]  VIRTUAL
        virtual int countSeqs()
       [line 38]  VIRTUAL 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                                     vector<char>& secStructMask,
                                     string& secStructName, int &structPenalties, int length)
       [line 41] 
        void fillCharTab(void)
       [line 42] 
        char getDelimiter(string filename)
       [line 45] 
        int getParseExitCode()
       [line 46] 
        
    protected:
        void freeFileResources(InFileStream* filePtr)
  |- PIRFileParser.h
    -> Found 5 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 19] 
        virtual Sequence getSeq(int seqNum)
       [line 20] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 21] 
        virtual int countSeqs()
       [line 22] 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                                     vector<char>& secStructMask, string& secStructName, 
                                     int &structPenalties, int length)
  |- PearsonFileParser.h
    -> Found 5 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 24] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 25] 
        virtual Sequence getSeq(int seqNum)
       [line 26] 
        virtual int countSeqs()
       [line 27] 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                                     vector<char>& secStructMask, string& secStructName, 
                                     int &structPenalties, int length)
  |- MSFFileParser.cpp
    -> Found 7 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 83] 
                return Sequence(blank, blank, blank)
       [line 86]  read the title
            if (utilityObject->lineType(_line, "//")
       [line 117]  Get the name of the sequence
                strncpy(_sname, _line + j, utilityObject->MIN(MAXNAMES, k - j)
       [line 151] 
                        return Sequence(characterSeq, name, title)
       [line 166]  return empty seq
            return Sequence(blank, blank, blank)
       [line 168] 
        return Sequence(characterSeq, name, title)
  |- GDEFileParser.cpp
    -> Found 9 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 91] 
                    return Sequence(blank, blank, blank)
       [line 157]  return empty seq
            return Sequence(blank, blank, blank)
       [line 159] 
        return Sequence(characterSeq, name, title)
       [line 195] 
            else if ((*line == '#')
       [line 240]  search for the next comment line
            while (*_line != '"')
       [line 266]  if _line contains ( then we break and dont put it into _sname
                // So how can sname have it???????
                if (_sname[i - 1] == '(')
       [line 334] 
            else if (strncmp(&_line[1], "GM_", 3)
       [line 349]  Again I dont think it is possible for _sname to have ( !!!!
                if (_sname[i - 1] == '(')
  |- RSFFileParser.h
    -> Found 7 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 19] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 20] 
        virtual Sequence getSeq(int seqNum)
       [line 21] 
        virtual int countSeqs()
       [line 22] 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                                     vector<char>& secStructMask, string& secStructName, 
                                     int &structPenalties, int length)
       [line 30] 
        void getRSFFeature(char* line, vector<char>& secStructMask, int length)
       [line 31] 
        bool keyword(char *line,char *code)
  |- PIRFileParser.cpp
    -> Found 8 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 88] 
                    return Sequence(blank, blank, blank)
       [line 101]  line contains the name of the sequence
        for (i = 4; i <= strlen(_line)
       [line 152]  return empty seq
            return Sequence(blank, blank, blank)
       [line 154] 
        return Sequence(characterSeq, name, title)
       [line 200]  Look for end of first seq
            if (*line == '>')
       [line 212]  EOL 
                if (c == '\n' || c == EOS)
       [line 241]  Look for end of seq
                    if (*line == '>')
  |- PearsonFileParser.cpp
    -> Found 16 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 90]  get sequence name from current line (excluded '>' and read up to first ' ' or MAXNAMES
            // remove the first char i.e. '>'
            name=line.substr(1,MAXNAMES)
       [line 112]  No title information
            
            while(std::getline(_fileIn,line,delim)
       [line 119]  Andreas Wilm (UCD)
       [line 119]  exit if  angle brackets within sequence
                    if(*iterator1=='>' && iterator1!=line.begin()
       [line 149]  check sequence
            if (characterSeq.length()
       [line 157] 
            else if (characterSeq.length()
       [line 242]  get sequence name from current line (excluded '>' and read up to first ' ' or MAXNAMES
        // remove the first char i.e. '>'
        name=line.substr(1,MAXNAMES)
       [line 262]  PMcG replace char array with string processing
        while (_currentSeqNum != seqNum)
       [line 269] 
                    return Sequence(blank, blank, blank)
       [line 282]  line contains the name of the sequence
        for (i = 1; i <= strlen(_line)
       [line 290]  remember entryname 
        for (i = 1; i <= strlen(sname)
       [line 358]  return empty seq
            return Sequence(blank, blank, blank)
       [line 360] 
        else if (characterSeq.length()
       [line 364]  return empty seq
            return Sequence(blank, blank, blank)
       [line 366] 
        
        return Sequence(characterSeq, name, title)
    -> Referências importantes (com snippet):
       [Marcador de problema] line 47: 'FIXME'
         [  44]  * reads fasta/pearson file in one go instead of calling getSeq for
         [  45]  * each single sequence.
         [  46]  *
         [  47]  * FIXME AW: only PearsonFileParser::getSeqRange is special, rest is the
         [  48]  * same. should be defined in FileParser and then overloaded in special
         [  49]  * cases like here
         [  50]  */
       [Marcador de problema] line 47: 'AW:'
         [  44]  * reads fasta/pearson file in one go instead of calling getSeq for
         [  45]  * each single sequence.
         [  46]  *
         [  47]  * FIXME AW: only PearsonFileParser::getSeqRange is special, rest is the
         [  48]  * same. should be defined in FileParser and then overloaded in special
         [  49]  * cases like here
         [  50]  */
  |- InFileStream.cpp
    -> Found 7 function(s):
       [line 2]  Author: Nigel Brown
 * 
 * Copyright (c)
       [line 8]  This is then used by the getline()
       [line 66]  but for symmetry to open()
       [line 109]  for CR or LF or CRLF (or LFCR)
       [line 114] 
            else if (c == LF)
       [line 116] 
            else if (type)
       [line 137]  is UNIX (default)
  |- ClustalFileParser.cpp
    -> Found 23 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 12]  Mark Larkin (UCD)
       [line 81]  it
    
        while (_fileIn->getline(line, MAXLINE + 1)
       [line 135]  return empty seq
                                return Sequence(blank, blank, blank)
       [line 137] 
                     return Sequence(characterSeq, name, title)
       [line 152]  return empty seq
            return Sequence(blank, blank, blank)
       [line 154] 
        return Sequence(characterSeq, name, title)
       [line 264]  initialise length to zero 
    
        if (!_fileIn->getline(line, MAXLINE + 1)
       [line 271]  it 

        if (!_fileIn->getline(line, MAXLINE + 1)
       [line 279]  skip any blank lines 
        for (;;)
       [line 346]  EOL
                        if (!isspace(c)
       [line 356] 
            else if (strncmp(line, "!GM", 3)
       [line 401]  EOL
                        if (!isspace(c)
       [line 428]  skip any more comment lines
        while (line[0] == '!')
       [line 438]  skip the sequence lines and any comments after the alignment 
        for (;;)
       [line 453]  read the rest of the alignment

        for (;;)
       [line 457]  skip any blank lines
            for (;;)
       [line 470]  get structure table line 
            for (ix = 0; ix < struct_index; ix++)
       [line 510]  EOL
                    if (!isspace(c)
       [line 516] 
            else if (structPenalties == GMASK)
       [line 534]  EOL
                if (!isspace(c)
       [line 542]  skip any more comment lines
        while (line[0] == '!')
       [line 552]  skip the sequence lines
            for (;;)
  |- GDEFileParser.h
    -> Found 5 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 20] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 21] 
        virtual Sequence getSeq(int seqNum)
       [line 22] 
        virtual int countSeqs()
       [line 23] 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                vector<char>& secStructMask,
               string& secStructName, int &structPenalties, int length)
  |- FileParser.cpp
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 7]  Removed delimiter and findDelimiter()
       [line 69]  for CR or LF or CRLF (or LFCR)
       [line 74] 
            else if (c == LF)
       [line 76] 
            else if (type)
       [line 97]  is UNIX (default)
  |- EMBLFileParser.cpp
    -> Found 12 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 94] 
                    return Sequence(blank, blank, blank)
       [line 114]  remember entryname 
        for (i = 0; i <= strlen(_sname)
       [line 128]  Andreas Wilm (UCD)
       [line 135] 
                return Sequence(blank, name, blank)
       [line 179]  return empty seq
            return Sequence(blank, blank, blank)
       [line 181] 
        return Sequence(characterSeq, name, title)
       [line 259]  find the start of the sequence entry 
        for (;;)
       [line 278]  remember entryname
            for (i = 0; i <= strlen(_sname)
       [line 291]  gap penalty mask 
            while (_fileIn->getline(_line, MAXLINE + 1)
       [line 335] 
                else if (utilityObject->lineType(_line, "GM")
       [line 415] 
        else if (strcmp(feature, "STRAND")
    -> Referências importantes (com snippet):
       [Marcador de problema] line 135: 'FIXME'
         [ 132]             if(!_fileIn->getline(_line, MAXLINE + 1)) // If we cannot get anymore!
         [ 133]             {
         [ 134]                 _fileIn->close();
         [ 135]                 // FIXME AW: why return with a name but otherwise empty seq?
         [ 136]                 return Sequence(blank, name, blank);
         [ 137]             }
         [ 138]         }
       [Marcador de problema] line 135: 'AW:'
         [ 132]             if(!_fileIn->getline(_line, MAXLINE + 1)) // If we cannot get anymore!
         [ 133]             {
         [ 134]                 _fileIn->close();
         [ 135]                 // FIXME AW: why return with a name but otherwise empty seq?
         [ 136]                 return Sequence(blank, name, blank);
         [ 137]             }
         [ 138]         }
  |- MSFFileParser.h
    -> Found 5 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 19] 
        virtual Sequence getSeq(int seqNum)
       [line 20] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 21] 
        virtual int countSeqs()
       [line 22] 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                                     vector<char>& secStructMask, string& secStructName, 
                                     int &structPenalties, int length)
  |- FileReader.cpp
    -> Found 29 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18]  warnings in seqInput()
       [line 18]  and profileInput()
       [line 21]  because some state (what exactly?)
       [line 118] 
    else if(code == NOSEQUENCESINFILE)
       [line 188]  open input file (%s)
       [line 199] 
    else if(userParameters->getProfileNum()
       [line 218]  FIXME AW: noEmptySequence check should be done internally by FileParser instances
    if (noEmptySequence(seqRangeVector)
       [line 224]  Andreas Wilm (UCD)
       [line 225]  which important when no alignment (convert!)
       [line 252]  names after saving
        if(alignPtr->checkAllNamesDifferent()
       [line 265]  names before appending
        if (! alignPtr->testUniqueNames(&seqVector)
       [line 281]  gap penalty mask (only if this is a profile)
       [line 292]  Andreas Wilm (UCD)
       [line 332]  Clear old info

            if (structPenalties != NONE)
       [line 352] 
        else if(code == NOSEQUENCESINFILE)
       [line 374]  Clear old info
            
            if (structPenalties != NONE)
       [line 391] 
        else if(code == CANNOTOPENFILE)
       [line 395] 
        else if(code == NOSEQUENCESINFILE)
       [line 484] 
    else if (utilityObject->lineType(_lineIn, "CLUSTAL")
       [line 490] 
    else if (utilityObject->lineType(_lineIn, "PILEUP")
       [line 496] 
    else if (utilityObject->lineType(_lineIn, "!!AA_MULTIPLE_ALIGNMENT")
       [line 503] 
    else if (utilityObject->lineType(_lineIn, "!!NA_MULTIPLE_ALIGNMENT")
       [line 510] 
    else if (strstr(_lineIn, "MSF")
       [line 517] 
    else if (utilityObject->lineType(_lineIn, "!!RICH_SEQUENCE")
       [line 523] 
    else if (utilityObject->lineType(_lineIn, "#NEXUS")
       [line 528] 
    else if (*_lineIn == '>')
       [line 547] 
    else if ((*_lineIn == '"')
       [line 558] 
        else if (*_lineIn == '#')
    -> Referências importantes (com snippet):
       [Marcador de problema] line 218: 'FIXME'
         [ 215]     seqRangeVector = fileParser->getSeqRange(1, noSeqs);
         [ 216]     if (seqRangeVector.size()==0)
         [ 217]         return fileParser->getParseExitCode();
         [ 218]     // FIXME AW: noEmptySequence check should be done internally by FileParser instances
         [ 219]     if (noEmptySequence(seqRangeVector) == false)
         [ 220]         return EMPTYSEQUENCE; // Error there are same names.
         [ 221] 
       [Marcador de problema] line 218: 'AW:'
         [ 215]     seqRangeVector = fileParser->getSeqRange(1, noSeqs);
         [ 216]     if (seqRangeVector.size()==0)
         [ 217]         return fileParser->getParseExitCode();
         [ 218]     // FIXME AW: noEmptySequence check should be done internally by FileParser instances
         [ 219]     if (noEmptySequence(seqRangeVector) == false)
         [ 220]         return EMPTYSEQUENCE; // Error there are same names.
         [ 221] 

=== Execução do 'make' ===

Código de retorno do 'make': 2

>> RAW MAKE OUTPUT <<

Making all in m4
make[1]: Entering directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/m4'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/m4'
Making all in src
make[1]: Entering directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/src'
make  all-recursive
make[2]: Entering directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/src'
make[3]: Entering directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/src'
nvcc -DHAVE_CONFIG_H -I. -I../ -o cuda/cudaFullPairwiseAlign.o -c cuda/cudaFullPairwiseAlign.cu -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp 
make[3]: Leaving directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/src'
make[2]: Leaving directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/src'
make[1]: Leaving directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/src'
cuda/../alignment/../substitutionMatrix/SubMatrix.h(96): warning #2464-D: conversion from a string literal to "char *" is deprecated
          void printInFormat(vector<short>& temp, char* name = "tempfile.out");
                                                               ^

Remark: The warnings can be suppressed with "-diag-suppress <warning-number>"

cuda/../alignment/../substitutionMatrix/SubMatrix.h(97): warning #2464-D: conversion from a string literal to "char *" is deprecated
          void printVectorToFile(vector<short>& temp, char* name = "tempfile.out");
                                                                   ^

cuda/cudaFullPairwiseAlign.cu(24): error: texture is not a template
  texture<int, 1, cudaReadModeElementType> texMatrix;
  ^

cuda/cudaFullPairwiseAlign.cu(83): error: no instance of overloaded function "tex1Dfetch" matches the argument list
            argument types are: (<error-type>, int)
      return tex1Dfetch(texMatrix, sequence1[i] * 32 + sequence2[j]);
             ^
/usr/local/cuda-12.4/bin/../targets/x86_64-linux/include/texture_indirect_functions.h(115): note #3327-D: candidate function template "tex1Dfetch<T>(cudaTextureObject_t, int)" failed deduction
  static __attribute__((device)) T tex1Dfetch(cudaTextureObject_t texObject, int x)
                                   ^
/usr/local/cuda-12.4/bin/../targets/x86_64-linux/include/texture_indirect_functions.h(109): note #3322-D: number of parameters of function template "tex1Dfetch(T *, cudaTextureObject_t, int)" does not match the call
  static __attribute__((device)) typename __nv_itex_trait<T>::type tex1Dfetch(T *ptr, cudaTextureObject_t obj, int x)
                                                                   ^

cuda/cudaFullPairwiseAlign.cu(897): error: identifier "cudaBindTexture" is undefined
      cudaBindTexture(0, texMatrix, gMatrix, NUMRES*NUMRES*sizeof(int));
      ^

cuda/cudaFullPairwiseAlign.cu(1040): error: identifier "cudaUnbindTexture" is undefined
      cudaUnbindTexture(texMatrix);
      ^

4 errors detected in the compilation of "cuda/cudaFullPairwiseAlign.cu".
make[3]: *** [Makefile:1843: cuda/cudaFullPairwiseAlign.o] Error 2
make[2]: *** [Makefile:1462: all-recursive] Error 1
make[1]: *** [Makefile:540: all] Error 2
make: *** [Makefile:371: all-recursive] Error 1

=== Warnings Coletados ===

(nenhum warning encontrado)

=== Errors Coletados ===

* cuda/cudaFullPairwiseAlign.cu(24): error: texture is not a template
* cuda/cudaFullPairwiseAlign.cu(83): error: no instance of overloaded function "tex1Dfetch" matches the argument list
* cuda/cudaFullPairwiseAlign.cu(897): error: identifier "cudaBindTexture" is undefined
* cuda/cudaFullPairwiseAlign.cu(1040): error: identifier "cudaUnbindTexture" is undefined


=== SUMÁRIO DE CONTAGEM DE ITENS DETECTADOS ===

- FUNCTIONS: 1913
- Marcador de problema: 86
- CUDA Arch / Flags: 74
- API CUDA Obsoleta: 8
- MAKE_ERRORS: 4