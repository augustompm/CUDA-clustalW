============================================================
 Relatório Ultra-Completo do Projeto CUDA-clustalW
============================================================

Inclui:
1) Árvore de diretórios, assinaturas de função
2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.
3) Estatísticas ao final
4) Execução do 'make', com parse de warnings e errors
5) Enfim, informações detalhadas para migração/debug.


=== Informações de ambiente ===

nvcc version:
nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2024 NVIDIA Corporation
Built on Tue_Feb_27_16:19:38_PST_2024
Cuda compilation tools, release 12.4, V12.4.99
Build cuda_12.4.r12.4/compiler.33961263_0

CUDA_HOME: Not set
CUDA_PATH: Not set
PATH: /usr/local/cuda-12.4/bin:/dados/home/tesla-dados/.vscode-server/cli/servers/Stable-fabdb6a30b49f79a7aba0f2ad9df9b399473380f/server/bin/remote-cli:/usr/local/cuda-12.4/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
LD_LIBRARY_PATH: /usr/local/cuda-12.4/lib64:/usr/local/cuda-12.4/lib64:


=== Mapeando o diretório: /dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final ===


[DIRECTORY] /dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final
  |- master-read.py
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 10: 'sm_13'
         [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [   8] 
         [   9] - Mapeia diretórios, assinaturas de função
         [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  12] - Exibe TODO, FIXME, etc. com snippet
         [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 10: 'sm_86'
         [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [   8] 
         [   9] - Mapeia diretórios, assinaturas de função
         [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  12] - Exibe TODO, FIXME, etc. com snippet
         [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 10: 'NVCCFLAGS'
         [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [   8] 
         [   9] - Mapeia diretórios, assinaturas de função
         [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  12] - Exibe TODO, FIXME, etc. com snippet
         [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 51: 'gencode'
         [  48] 
         [  49] # Regex (compilado) para compute capabilities/flags
         [  50] CUDA_ARCH_REGEX = re.compile(
         [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  52] )
         [  53] 
         [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 51: 'NVCCFLAGS'
         [  48] 
         [  49] # Regex (compilado) para compute capabilities/flags
         [  50] CUDA_ARCH_REGEX = re.compile(
         [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  52] )
         [  53] 
         [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 51: 'CUDAFLAGS'
         [  48] 
         [  49] # Regex (compilado) para compute capabilities/flags
         [  50] CUDA_ARCH_REGEX = re.compile(
         [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  52] )
         [  53] 
         [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 51: '--gpu-architecture'
         [  48] 
         [  49] # Regex (compilado) para compute capabilities/flags
         [  50] CUDA_ARCH_REGEX = re.compile(
         [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  52] )
         [  53] 
         [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 51: '--gpu-code'
         [  48] 
         [  49] # Regex (compilado) para compute capabilities/flags
         [  50] CUDA_ARCH_REGEX = re.compile(
         [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  52] )
         [  53] 
         [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 212: 'sm_13'
         [ 209]     """
         [ 210]     Percorre o diretório. Para cada arquivo, busca:
         [ 211]      - assinaturas de função
         [ 212]      - references a sm_13/sm_86 (CUDA_ARCH_REGEX)
         [ 213]      - references a APIs obsoletas (CUDA_OBSOLETE_APIS)
         [ 214]      - references a marcadores (PROBLEM_MARKERS)
         [ 215]      Exibe snippet ao redor e registra contadores em summary_counts.
       [CUDA Arch / Flags] line 212: 'sm_86'
         [ 209]     """
         [ 210]     Percorre o diretório. Para cada arquivo, busca:
         [ 211]      - assinaturas de função
         [ 212]      - references a sm_13/sm_86 (CUDA_ARCH_REGEX)
         [ 213]      - references a APIs obsoletas (CUDA_OBSOLETE_APIS)
         [ 214]      - references a marcadores (PROBLEM_MARKERS)
         [ 215]      Exibe snippet ao redor e registra contadores em summary_counts.
       [CUDA Arch / Flags] line 334: 'sm_13'
         [ 331]         "============================================================\n\n"
         [ 332]         "Inclui:\n"
         [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 335]         "3) Estatísticas ao final\n"
         [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [CUDA Arch / Flags] line 334: 'sm_86'
         [ 331]         "============================================================\n\n"
         [ 332]         "Inclui:\n"
         [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 335]         "3) Estatísticas ao final\n"
         [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [API CUDA Obsoleta] line 11: 'cudaThreadSynchronize'
         [   8] 
         [   9] - Mapeia diretórios, assinaturas de função
         [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  12] - Exibe TODO, FIXME, etc. com snippet
         [  13] - Separa warnings e errors do 'make' e agrupa
         [  14] - Gera contagem estatística de cada tipo de referência
       [API CUDA Obsoleta] line 56: 'cudaThreadSynchronize'
         [  53] 
         [  54] # Listas de strings para buscas literais
         [  55] CUDA_OBSOLETE_APIS = [
         [  56]     r"cudaThreadSynchronize",
         [  57]     r"cudaThreadExit",
         [  58]     r"__syncthreadsCount",
         [  59]     r"cutil\.h",
       [API CUDA Obsoleta] line 57: 'cudaThreadExit'
         [  54] # Listas de strings para buscas literais
         [  55] CUDA_OBSOLETE_APIS = [
         [  56]     r"cudaThreadSynchronize",
         [  57]     r"cudaThreadExit",
         [  58]     r"__syncthreadsCount",
         [  59]     r"cutil\.h",
         [  60]     r"helper_cuda\.h",
       [API CUDA Obsoleta] line 58: '__syncthreadsCount'
         [  55] CUDA_OBSOLETE_APIS = [
         [  56]     r"cudaThreadSynchronize",
         [  57]     r"cudaThreadExit",
         [  58]     r"__syncthreadsCount",
         [  59]     r"cutil\.h",
         [  60]     r"helper_cuda\.h",
         [  61]     r"texture\<",
       [API CUDA Obsoleta] line 62: 'BindTexture'
         [  59]     r"cutil\.h",
         [  60]     r"helper_cuda\.h",
         [  61]     r"texture\<",
         [  62]     r"BindTexture",
         [  63] ]
         [  64] 
         [  65] PROBLEM_MARKERS = [
       [Marcador de problema] line 12: 'TODO'
         [   9] - Mapeia diretórios, assinaturas de função
         [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  12] - Exibe TODO, FIXME, etc. com snippet
         [  13] - Separa warnings e errors do 'make' e agrupa
         [  14] - Gera contagem estatística de cada tipo de referência
         [  15] 
       [Marcador de problema] line 66: 'TODO'
         [  63] ]
         [  64] 
         [  65] PROBLEM_MARKERS = [
         [  66]     r"TODO",
         [  67]     r"FIXME",
         [  68]     r"DEPRECATED",
         [  69]     r"AW:",
       [Marcador de problema] line 334: 'TODO'
         [ 331]         "============================================================\n\n"
         [ 332]         "Inclui:\n"
         [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 335]         "3) Estatísticas ao final\n"
         [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [Marcador de problema] line 12: 'FIXME'
         [   9] - Mapeia diretórios, assinaturas de função
         [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  12] - Exibe TODO, FIXME, etc. com snippet
         [  13] - Separa warnings e errors do 'make' e agrupa
         [  14] - Gera contagem estatística de cada tipo de referência
         [  15] 
       [Marcador de problema] line 67: 'FIXME'
         [  64] 
         [  65] PROBLEM_MARKERS = [
         [  66]     r"TODO",
         [  67]     r"FIXME",
         [  68]     r"DEPRECATED",
         [  69]     r"AW:",
         [  70]     r"eight[ -_]years",
       [Marcador de problema] line 68: 'DEPRECATED'
         [  65] PROBLEM_MARKERS = [
         [  66]     r"TODO",
         [  67]     r"FIXME",
         [  68]     r"DEPRECATED",
         [  69]     r"AW:",
         [  70]     r"eight[ -_]years",
         [  71] ]
       [Marcador de problema] line 69: 'AW:'
         [  66]     r"TODO",
         [  67]     r"FIXME",
         [  68]     r"DEPRECATED",
         [  69]     r"AW:",
         [  70]     r"eight[ -_]years",
         [  71] ]
         [  72] 
  |- LICENSE
  |- compile
    -> Referências importantes (com snippet):
       [Marcador de problema] line 324: 'FIXME'
         [ 321]   fi
         [ 322]   sleep 1
         [ 323] done
         [ 324] # FIXME: race condition here if user kills between mkdir and trap.
         [ 325] trap "rmdir '$lockdir'; exit 1" 1 2 15
         [ 326] 
         [ 327] # Run the compile.
  |- README
  |- intltool-merge.in
  |- depcomp
    -> Referências importantes (com snippet):
       [Marcador de problema] line 330: 'FIXME'
         [ 327] 
         [ 328] tcc)
         [ 329]   # tcc (Tiny C Compiler) understand '-MD -MF file' since version 0.9.26
         [ 330]   # FIXME: That version still under development at the moment of writing.
         [ 331]   #        Make that this statement remains true also for stable, released
         [ 332]   #        versions.
         [ 333]   # It will wrap lines (doesn't matter whether long or short) with a
  |- configure.ac
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 116: 'NVCCFLAGS'
         [ 113]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 114]     NVCC="nvcc"
         [ 115] fi
         [ 116] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 117] AC_SUBST(CUDA_CFLAGS)
         [ 118] AC_SUBST(CUDA_LIBS)
         [ 119] AC_SUBST(NVCC)
       [CUDA Arch / Flags] line 116: 'arch=sm_86'
         [ 113]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 114]     NVCC="nvcc"
         [ 115] fi
         [ 116] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 117] AC_SUBST(CUDA_CFLAGS)
         [ 118] AC_SUBST(CUDA_LIBS)
         [ 119] AC_SUBST(NVCC)
       [CUDA Arch / Flags] line 120: 'NVCCFLAGS'
         [ 117] AC_SUBST(CUDA_CFLAGS)
         [ 118] AC_SUBST(CUDA_LIBS)
         [ 119] AC_SUBST(NVCC)
         [ 120] AC_SUBST(NVCCFLAGS)
         [ 121] 
         [ 122] 
         [ 123] 
  |- clustalw_help
  |- Makefile.in
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 250: 'NVCCFLAGS'
         [ 247] MAKEINFO = @MAKEINFO@
         [ 248] MKDIR_P = @MKDIR_P@
         [ 249] NVCC = @NVCC@
         [ 250] NVCCFLAGS = @NVCCFLAGS@
         [ 251] OBJEXT = @OBJEXT@
         [ 252] PACKAGE = @PACKAGE@
         [ 253] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 250: 'NVCCFLAGS'
         [ 247] MAKEINFO = @MAKEINFO@
         [ 248] MKDIR_P = @MKDIR_P@
         [ 249] NVCC = @NVCC@
         [ 250] NVCCFLAGS = @NVCCFLAGS@
         [ 251] OBJEXT = @OBJEXT@
         [ 252] PACKAGE = @PACKAGE@
         [ 253] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
  |- missing
  |- config.sub
    -> Referências importantes (com snippet):
       [Marcador de problema] line 769: 'FIXME'
         [ 766] 		vendor=hp
         [ 767] 		;;
         [ 768] 	hp9k78[0-9] | hp78[0-9])
         [ 769] 		# FIXME: really hppa2.0-hp
         [ 770] 		cpu=hppa1.1
         [ 771] 		vendor=hp
         [ 772] 		;;
       [Marcador de problema] line 774: 'FIXME'
         [ 771] 		vendor=hp
         [ 772] 		;;
         [ 773] 	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
         [ 774] 		# FIXME: really hppa2.0-hp
         [ 775] 		cpu=hppa1.1
         [ 776] 		vendor=hp
         [ 777] 		;;
  |- Makefile
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 250: 'NVCCFLAGS'
         [ 247] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 248] MKDIR_P = /usr/bin/mkdir -p
         [ 249] NVCC = nvcc
         [ 250] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 251] OBJEXT = o
         [ 252] PACKAGE = clustalw
         [ 253] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 250: 'arch=sm_86'
         [ 247] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 248] MKDIR_P = /usr/bin/mkdir -p
         [ 249] NVCC = nvcc
         [ 250] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 251] OBJEXT = o
         [ 252] PACKAGE = clustalw
         [ 253] PACKAGE_BUGREPORT = clustalw@ucd.ie
  |- config.h.in
  |- intltool-extract.in
  |- config.guess
  |- install-sh
  |- config.h
  |- configure
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 658: 'NVCCFLAGS'
         [ 655] EGREP
         [ 656] GREP
         [ 657] RANLIB
         [ 658] NVCCFLAGS
         [ 659] NVCC
         [ 660] CUDA_LIBS
         [ 661] CUDA_CFLAGS
       [CUDA Arch / Flags] line 5464: 'NVCCFLAGS'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [CUDA Arch / Flags] line 5464: 'arch=sm_86'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [Marcador de problema] line 7486: 'TODO'
         [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [7485]   # if we detect the quoting.
         [7486]   # TODO: see whether this extra hack can be removed once we start
         [7487]   # requiring Autoconf 2.70 or later.
         [7488]   case $CONFIG_FILES in #(
         [7489]   *\'*) :
       [Marcador de problema] line 1199: 'FIXME'
         [1196]     export $ac_envvar ;;
         [1197] 
         [1198]   *)
         [1199]     # FIXME: should be removed in autoconf 3.0.
         [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 1245: 'FIXME'
         [1242] 
         [1243] # There might be people who depend on the old broken behavior: `$host'
         [1244] # used to hold the argument of --host etc.
         [1245] # FIXME: To remove some day.
         [1246] build=$build_alias
         [1247] host=$host_alias
         [1248] target=$target_alias
       [Marcador de problema] line 1250: 'FIXME'
         [1247] host=$host_alias
         [1248] target=$target_alias
         [1249] 
         [1250] # FIXME: To remove some day.
         [1251] if test "x$host_alias" != x; then
         [1252]   if test "x$build_alias" = x; then
         [1253]     cross_compiling=maybe
       [Marcador de problema] line 4654: 'FIXME'
         [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [4653]    # Losing compiler, so override with the script.
         [4654]    # FIXME: It is wrong to rewrite CC.
         [4655]    # But if we don't then we get into trouble of one sort or another.
         [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
       [Marcador de problema] line 7344: 'FIXME'
         [7341] 
         [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [7343] # If the template does not know about datarootdir, expand it.
         [7344] # FIXME: This hack should be removed a few years after 2.60.
         [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [7346] ac_sed_dataroot='
         [7347] /datarootdir/ {
       [Marcador de problema] line 7375: 'FIXME'
         [7372] 
         [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [7374] # Shell code in configure.ac might set extrasub.
         [7375] # FIXME: do we really want to maintain this feature?
         [7376] cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
         [7377] ac_sed_extra="$ac_vpsub
         [7378] $extrasub
  |- project_report-old.txt
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 7: 'sm_13'
         [   4] 
         [   5] Inclui:
         [   6] 1) Árvore de diretórios, assinaturas de função
         [   7] 2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.
         [   8] 3) Estatísticas ao final
         [   9] 4) Execução do 'make', com parse de warnings e errors
         [  10] 5) Enfim, informações detalhadas para migração/debug.
       [CUDA Arch / Flags] line 7: 'sm_86'
         [   4] 
         [   5] Inclui:
         [   6] 1) Árvore de diretórios, assinaturas de função
         [   7] 2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.
         [   8] 3) Estatísticas ao final
         [   9] 4) Execução do 'make', com parse de warnings e errors
         [  10] 5) Enfim, informações detalhadas para migração/debug.
       [CUDA Arch / Flags] line 34: 'sm_13'
         [  31] [DIRECTORY] /dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final
         [  32]   |- master-read.py
         [  33]     -> Referências importantes (com snippet):
         [  34]        [CUDA Arch / Flags] line 10: 'sm_13'
         [  35]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [  36]          [   8]
         [  37]          [   9] - Mapeia diretórios, assinaturas de função
       [CUDA Arch / Flags] line 38: 'sm_13'
         [  35]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [  36]          [   8]
         [  37]          [   9] - Mapeia diretórios, assinaturas de função
         [  38]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  39]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  40]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  41]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 38: 'sm_86'
         [  35]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [  36]          [   8]
         [  37]          [   9] - Mapeia diretórios, assinaturas de função
         [  38]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  39]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  40]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  41]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 38: 'NVCCFLAGS'
         [  35]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [  36]          [   8]
         [  37]          [   9] - Mapeia diretórios, assinaturas de função
         [  38]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  39]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  40]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  41]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 42: 'sm_86'
         [  39]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  40]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  41]          [  13] - Separa warnings e errors do 'make' e agrupa
         [  42]        [CUDA Arch / Flags] line 10: 'sm_86'
         [  43]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [  44]          [   8]
         [  45]          [   9] - Mapeia diretórios, assinaturas de função
       [CUDA Arch / Flags] line 46: 'sm_13'
         [  43]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [  44]          [   8]
         [  45]          [   9] - Mapeia diretórios, assinaturas de função
         [  46]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  47]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  48]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  49]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 46: 'sm_86'
         [  43]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [  44]          [   8]
         [  45]          [   9] - Mapeia diretórios, assinaturas de função
         [  46]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  47]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  48]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  49]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 46: 'NVCCFLAGS'
         [  43]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [  44]          [   8]
         [  45]          [   9] - Mapeia diretórios, assinaturas de função
         [  46]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  47]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  48]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  49]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 50: 'NVCCFLAGS'
         [  47]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  48]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  49]          [  13] - Separa warnings e errors do 'make' e agrupa
         [  50]        [CUDA Arch / Flags] line 10: 'NVCCFLAGS'
         [  51]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [  52]          [   8]
         [  53]          [   9] - Mapeia diretórios, assinaturas de função
       [CUDA Arch / Flags] line 54: 'sm_13'
         [  51]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [  52]          [   8]
         [  53]          [   9] - Mapeia diretórios, assinaturas de função
         [  54]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  55]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  56]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  57]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 54: 'sm_86'
         [  51]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [  52]          [   8]
         [  53]          [   9] - Mapeia diretórios, assinaturas de função
         [  54]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  55]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  56]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  57]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 54: 'NVCCFLAGS'
         [  51]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
         [  52]          [   8]
         [  53]          [   9] - Mapeia diretórios, assinaturas de função
         [  54]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  55]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  56]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  57]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 58: 'gencode'
         [  55]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  56]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  57]          [  13] - Separa warnings e errors do 'make' e agrupa
         [  58]        [CUDA Arch / Flags] line 51: 'gencode'
         [  59]          [  48]
         [  60]          [  49] # Regex (compilado) para compute capabilities/flags
         [  61]          [  50] CUDA_ARCH_REGEX = re.compile(
       [CUDA Arch / Flags] line 62: 'gencode'
         [  59]          [  48]
         [  60]          [  49] # Regex (compilado) para compute capabilities/flags
         [  61]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  62]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  63]          [  52] )
         [  64]          [  53]
         [  65]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 62: 'NVCCFLAGS'
         [  59]          [  48]
         [  60]          [  49] # Regex (compilado) para compute capabilities/flags
         [  61]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  62]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  63]          [  52] )
         [  64]          [  53]
         [  65]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 62: 'CUDAFLAGS'
         [  59]          [  48]
         [  60]          [  49] # Regex (compilado) para compute capabilities/flags
         [  61]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  62]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  63]          [  52] )
         [  64]          [  53]
         [  65]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 62: '--gpu-architecture'
         [  59]          [  48]
         [  60]          [  49] # Regex (compilado) para compute capabilities/flags
         [  61]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  62]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  63]          [  52] )
         [  64]          [  53]
         [  65]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 62: '--gpu-code'
         [  59]          [  48]
         [  60]          [  49] # Regex (compilado) para compute capabilities/flags
         [  61]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  62]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  63]          [  52] )
         [  64]          [  53]
         [  65]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 66: 'NVCCFLAGS'
         [  63]          [  52] )
         [  64]          [  53]
         [  65]          [  54] # Listas de strings para buscas literais
         [  66]        [CUDA Arch / Flags] line 51: 'NVCCFLAGS'
         [  67]          [  48]
         [  68]          [  49] # Regex (compilado) para compute capabilities/flags
         [  69]          [  50] CUDA_ARCH_REGEX = re.compile(
       [CUDA Arch / Flags] line 70: 'gencode'
         [  67]          [  48]
         [  68]          [  49] # Regex (compilado) para compute capabilities/flags
         [  69]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  70]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  71]          [  52] )
         [  72]          [  53]
         [  73]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 70: 'NVCCFLAGS'
         [  67]          [  48]
         [  68]          [  49] # Regex (compilado) para compute capabilities/flags
         [  69]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  70]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  71]          [  52] )
         [  72]          [  53]
         [  73]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 70: 'CUDAFLAGS'
         [  67]          [  48]
         [  68]          [  49] # Regex (compilado) para compute capabilities/flags
         [  69]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  70]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  71]          [  52] )
         [  72]          [  53]
         [  73]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 70: '--gpu-architecture'
         [  67]          [  48]
         [  68]          [  49] # Regex (compilado) para compute capabilities/flags
         [  69]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  70]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  71]          [  52] )
         [  72]          [  53]
         [  73]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 70: '--gpu-code'
         [  67]          [  48]
         [  68]          [  49] # Regex (compilado) para compute capabilities/flags
         [  69]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  70]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  71]          [  52] )
         [  72]          [  53]
         [  73]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 74: 'CUDAFLAGS'
         [  71]          [  52] )
         [  72]          [  53]
         [  73]          [  54] # Listas de strings para buscas literais
         [  74]        [CUDA Arch / Flags] line 51: 'CUDAFLAGS'
         [  75]          [  48]
         [  76]          [  49] # Regex (compilado) para compute capabilities/flags
         [  77]          [  50] CUDA_ARCH_REGEX = re.compile(
       [CUDA Arch / Flags] line 78: 'gencode'
         [  75]          [  48]
         [  76]          [  49] # Regex (compilado) para compute capabilities/flags
         [  77]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  78]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  79]          [  52] )
         [  80]          [  53]
         [  81]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 78: 'NVCCFLAGS'
         [  75]          [  48]
         [  76]          [  49] # Regex (compilado) para compute capabilities/flags
         [  77]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  78]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  79]          [  52] )
         [  80]          [  53]
         [  81]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 78: 'CUDAFLAGS'
         [  75]          [  48]
         [  76]          [  49] # Regex (compilado) para compute capabilities/flags
         [  77]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  78]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  79]          [  52] )
         [  80]          [  53]
         [  81]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 78: '--gpu-architecture'
         [  75]          [  48]
         [  76]          [  49] # Regex (compilado) para compute capabilities/flags
         [  77]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  78]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  79]          [  52] )
         [  80]          [  53]
         [  81]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 78: '--gpu-code'
         [  75]          [  48]
         [  76]          [  49] # Regex (compilado) para compute capabilities/flags
         [  77]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  78]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  79]          [  52] )
         [  80]          [  53]
         [  81]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 82: '--gpu-architecture'
         [  79]          [  52] )
         [  80]          [  53]
         [  81]          [  54] # Listas de strings para buscas literais
         [  82]        [CUDA Arch / Flags] line 51: '--gpu-architecture'
         [  83]          [  48]
         [  84]          [  49] # Regex (compilado) para compute capabilities/flags
         [  85]          [  50] CUDA_ARCH_REGEX = re.compile(
       [CUDA Arch / Flags] line 86: 'gencode'
         [  83]          [  48]
         [  84]          [  49] # Regex (compilado) para compute capabilities/flags
         [  85]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  86]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  87]          [  52] )
         [  88]          [  53]
         [  89]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 86: 'NVCCFLAGS'
         [  83]          [  48]
         [  84]          [  49] # Regex (compilado) para compute capabilities/flags
         [  85]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  86]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  87]          [  52] )
         [  88]          [  53]
         [  89]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 86: 'CUDAFLAGS'
         [  83]          [  48]
         [  84]          [  49] # Regex (compilado) para compute capabilities/flags
         [  85]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  86]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  87]          [  52] )
         [  88]          [  53]
         [  89]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 86: '--gpu-architecture'
         [  83]          [  48]
         [  84]          [  49] # Regex (compilado) para compute capabilities/flags
         [  85]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  86]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  87]          [  52] )
         [  88]          [  53]
         [  89]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 86: '--gpu-code'
         [  83]          [  48]
         [  84]          [  49] # Regex (compilado) para compute capabilities/flags
         [  85]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  86]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  87]          [  52] )
         [  88]          [  53]
         [  89]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 90: '--gpu-code'
         [  87]          [  52] )
         [  88]          [  53]
         [  89]          [  54] # Listas de strings para buscas literais
         [  90]        [CUDA Arch / Flags] line 51: '--gpu-code'
         [  91]          [  48]
         [  92]          [  49] # Regex (compilado) para compute capabilities/flags
         [  93]          [  50] CUDA_ARCH_REGEX = re.compile(
       [CUDA Arch / Flags] line 94: 'gencode'
         [  91]          [  48]
         [  92]          [  49] # Regex (compilado) para compute capabilities/flags
         [  93]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  94]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  95]          [  52] )
         [  96]          [  53]
         [  97]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 94: 'NVCCFLAGS'
         [  91]          [  48]
         [  92]          [  49] # Regex (compilado) para compute capabilities/flags
         [  93]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  94]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  95]          [  52] )
         [  96]          [  53]
         [  97]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 94: 'CUDAFLAGS'
         [  91]          [  48]
         [  92]          [  49] # Regex (compilado) para compute capabilities/flags
         [  93]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  94]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  95]          [  52] )
         [  96]          [  53]
         [  97]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 94: '--gpu-architecture'
         [  91]          [  48]
         [  92]          [  49] # Regex (compilado) para compute capabilities/flags
         [  93]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  94]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  95]          [  52] )
         [  96]          [  53]
         [  97]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 94: '--gpu-code'
         [  91]          [  48]
         [  92]          [  49] # Regex (compilado) para compute capabilities/flags
         [  93]          [  50] CUDA_ARCH_REGEX = re.compile(
         [  94]          [  51]     r"(sm_\d+|compute_\d+|gencode\s*|arch=compute_\d+|arch=sm_\d+|NVCCFLAGS|CUDAFLAGS|--gpu-architecture|--gpu-code)"
         [  95]          [  52] )
         [  96]          [  53]
         [  97]          [  54] # Listas de strings para buscas literais
       [CUDA Arch / Flags] line 98: 'sm_13'
         [  95]          [  52] )
         [  96]          [  53]
         [  97]          [  54] # Listas de strings para buscas literais
         [  98]        [CUDA Arch / Flags] line 212: 'sm_13'
         [  99]          [ 209]     """
         [ 100]          [ 210]     Percorre o diretório. Para cada arquivo, busca:
         [ 101]          [ 211]      - assinaturas de função
       [CUDA Arch / Flags] line 102: 'sm_13'
         [  99]          [ 209]     """
         [ 100]          [ 210]     Percorre o diretório. Para cada arquivo, busca:
         [ 101]          [ 211]      - assinaturas de função
         [ 102]          [ 212]      - references a sm_13/sm_86 (CUDA_ARCH_REGEX)
         [ 103]          [ 213]      - references a APIs obsoletas (CUDA_OBSOLETE_APIS)
         [ 104]          [ 214]      - references a marcadores (PROBLEM_MARKERS)
         [ 105]          [ 215]      Exibe snippet ao redor e registra contadores em summary_counts.
       [CUDA Arch / Flags] line 102: 'sm_86'
         [  99]          [ 209]     """
         [ 100]          [ 210]     Percorre o diretório. Para cada arquivo, busca:
         [ 101]          [ 211]      - assinaturas de função
         [ 102]          [ 212]      - references a sm_13/sm_86 (CUDA_ARCH_REGEX)
         [ 103]          [ 213]      - references a APIs obsoletas (CUDA_OBSOLETE_APIS)
         [ 104]          [ 214]      - references a marcadores (PROBLEM_MARKERS)
         [ 105]          [ 215]      Exibe snippet ao redor e registra contadores em summary_counts.
       [CUDA Arch / Flags] line 106: 'sm_86'
         [ 103]          [ 213]      - references a APIs obsoletas (CUDA_OBSOLETE_APIS)
         [ 104]          [ 214]      - references a marcadores (PROBLEM_MARKERS)
         [ 105]          [ 215]      Exibe snippet ao redor e registra contadores em summary_counts.
         [ 106]        [CUDA Arch / Flags] line 212: 'sm_86'
         [ 107]          [ 209]     """
         [ 108]          [ 210]     Percorre o diretório. Para cada arquivo, busca:
         [ 109]          [ 211]      - assinaturas de função
       [CUDA Arch / Flags] line 110: 'sm_13'
         [ 107]          [ 209]     """
         [ 108]          [ 210]     Percorre o diretório. Para cada arquivo, busca:
         [ 109]          [ 211]      - assinaturas de função
         [ 110]          [ 212]      - references a sm_13/sm_86 (CUDA_ARCH_REGEX)
         [ 111]          [ 213]      - references a APIs obsoletas (CUDA_OBSOLETE_APIS)
         [ 112]          [ 214]      - references a marcadores (PROBLEM_MARKERS)
         [ 113]          [ 215]      Exibe snippet ao redor e registra contadores em summary_counts.
       [CUDA Arch / Flags] line 110: 'sm_86'
         [ 107]          [ 209]     """
         [ 108]          [ 210]     Percorre o diretório. Para cada arquivo, busca:
         [ 109]          [ 211]      - assinaturas de função
         [ 110]          [ 212]      - references a sm_13/sm_86 (CUDA_ARCH_REGEX)
         [ 111]          [ 213]      - references a APIs obsoletas (CUDA_OBSOLETE_APIS)
         [ 112]          [ 214]      - references a marcadores (PROBLEM_MARKERS)
         [ 113]          [ 215]      Exibe snippet ao redor e registra contadores em summary_counts.
       [CUDA Arch / Flags] line 114: 'sm_13'
         [ 111]          [ 213]      - references a APIs obsoletas (CUDA_OBSOLETE_APIS)
         [ 112]          [ 214]      - references a marcadores (PROBLEM_MARKERS)
         [ 113]          [ 215]      Exibe snippet ao redor e registra contadores em summary_counts.
         [ 114]        [CUDA Arch / Flags] line 334: 'sm_13'
         [ 115]          [ 331]         "============================================================\n\n"
         [ 116]          [ 332]         "Inclui:\n"
         [ 117]          [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
       [CUDA Arch / Flags] line 118: 'sm_13'
         [ 115]          [ 331]         "============================================================\n\n"
         [ 116]          [ 332]         "Inclui:\n"
         [ 117]          [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 118]          [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 119]          [ 335]         "3) Estatísticas ao final\n"
         [ 120]          [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 121]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [CUDA Arch / Flags] line 118: 'sm_86'
         [ 115]          [ 331]         "============================================================\n\n"
         [ 116]          [ 332]         "Inclui:\n"
         [ 117]          [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 118]          [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 119]          [ 335]         "3) Estatísticas ao final\n"
         [ 120]          [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 121]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [CUDA Arch / Flags] line 122: 'sm_86'
         [ 119]          [ 335]         "3) Estatísticas ao final\n"
         [ 120]          [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 121]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
         [ 122]        [CUDA Arch / Flags] line 334: 'sm_86'
         [ 123]          [ 331]         "============================================================\n\n"
         [ 124]          [ 332]         "Inclui:\n"
         [ 125]          [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
       [CUDA Arch / Flags] line 126: 'sm_13'
         [ 123]          [ 331]         "============================================================\n\n"
         [ 124]          [ 332]         "Inclui:\n"
         [ 125]          [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 126]          [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 127]          [ 335]         "3) Estatísticas ao final\n"
         [ 128]          [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 129]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [CUDA Arch / Flags] line 126: 'sm_86'
         [ 123]          [ 331]         "============================================================\n\n"
         [ 124]          [ 332]         "Inclui:\n"
         [ 125]          [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 126]          [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 127]          [ 335]         "3) Estatísticas ao final\n"
         [ 128]          [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 129]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [CUDA Arch / Flags] line 133: 'sm_13'
         [ 130]        [API CUDA Obsoleta] line 11: 'cudaThreadSynchronize'
         [ 131]          [   8]
         [ 132]          [   9] - Mapeia diretórios, assinaturas de função
         [ 133]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 134]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 135]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 136]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 133: 'sm_86'
         [ 130]        [API CUDA Obsoleta] line 11: 'cudaThreadSynchronize'
         [ 131]          [   8]
         [ 132]          [   9] - Mapeia diretórios, assinaturas de função
         [ 133]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 134]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 135]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 136]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 133: 'NVCCFLAGS'
         [ 130]        [API CUDA Obsoleta] line 11: 'cudaThreadSynchronize'
         [ 131]          [   8]
         [ 132]          [   9] - Mapeia diretórios, assinaturas de função
         [ 133]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 134]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 135]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 136]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 172: 'sm_13'
         [ 169]          [  65] PROBLEM_MARKERS = [
         [ 170]        [Marcador de problema] line 12: 'TODO'
         [ 171]          [   9] - Mapeia diretórios, assinaturas de função
         [ 172]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 173]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 174]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 175]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 172: 'sm_86'
         [ 169]          [  65] PROBLEM_MARKERS = [
         [ 170]        [Marcador de problema] line 12: 'TODO'
         [ 171]          [   9] - Mapeia diretórios, assinaturas de função
         [ 172]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 173]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 174]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 175]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 172: 'NVCCFLAGS'
         [ 169]          [  65] PROBLEM_MARKERS = [
         [ 170]        [Marcador de problema] line 12: 'TODO'
         [ 171]          [   9] - Mapeia diretórios, assinaturas de função
         [ 172]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 173]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 174]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 175]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 190: 'sm_13'
         [ 187]          [ 331]         "============================================================\n\n"
         [ 188]          [ 332]         "Inclui:\n"
         [ 189]          [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 190]          [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 191]          [ 335]         "3) Estatísticas ao final\n"
         [ 192]          [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 193]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [CUDA Arch / Flags] line 190: 'sm_86'
         [ 187]          [ 331]         "============================================================\n\n"
         [ 188]          [ 332]         "Inclui:\n"
         [ 189]          [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 190]          [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 191]          [ 335]         "3) Estatísticas ao final\n"
         [ 192]          [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 193]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [CUDA Arch / Flags] line 196: 'sm_13'
         [ 193]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
         [ 194]        [Marcador de problema] line 12: 'FIXME'
         [ 195]          [   9] - Mapeia diretórios, assinaturas de função
         [ 196]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 197]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 198]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 199]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 196: 'sm_86'
         [ 193]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
         [ 194]        [Marcador de problema] line 12: 'FIXME'
         [ 195]          [   9] - Mapeia diretórios, assinaturas de função
         [ 196]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 197]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 198]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 199]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 196: 'NVCCFLAGS'
         [ 193]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
         [ 194]        [Marcador de problema] line 12: 'FIXME'
         [ 195]          [   9] - Mapeia diretórios, assinaturas de função
         [ 196]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 197]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 198]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 199]          [  13] - Separa warnings e errors do 'make' e agrupa
       [CUDA Arch / Flags] line 251: 'NVCCFLAGS'
         [ 248]          [ 333]   # It will wrap lines (doesn't matter whether long or short) with a
         [ 249]   |- configure.ac
         [ 250]     -> Referências importantes (com snippet):
         [ 251]        [CUDA Arch / Flags] line 116: 'NVCCFLAGS'
         [ 252]          [ 113]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 253]          [ 114]     NVCC="nvcc"
         [ 254]          [ 115] fi
       [CUDA Arch / Flags] line 255: 'NVCCFLAGS'
         [ 252]          [ 113]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 253]          [ 114]     NVCC="nvcc"
         [ 254]          [ 115] fi
         [ 255]          [ 116] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 256]          [ 117] AC_SUBST(CUDA_CFLAGS)
         [ 257]          [ 118] AC_SUBST(CUDA_LIBS)
         [ 258]          [ 119] AC_SUBST(NVCC)
       [CUDA Arch / Flags] line 255: 'arch=sm_86'
         [ 252]          [ 113]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 253]          [ 114]     NVCC="nvcc"
         [ 254]          [ 115] fi
         [ 255]          [ 116] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 256]          [ 117] AC_SUBST(CUDA_CFLAGS)
         [ 257]          [ 118] AC_SUBST(CUDA_LIBS)
         [ 258]          [ 119] AC_SUBST(NVCC)
       [CUDA Arch / Flags] line 259: 'arch=sm_86'
         [ 256]          [ 117] AC_SUBST(CUDA_CFLAGS)
         [ 257]          [ 118] AC_SUBST(CUDA_LIBS)
         [ 258]          [ 119] AC_SUBST(NVCC)
         [ 259]        [CUDA Arch / Flags] line 116: 'arch=sm_86'
         [ 260]          [ 113]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 261]          [ 114]     NVCC="nvcc"
         [ 262]          [ 115] fi
       [CUDA Arch / Flags] line 263: 'NVCCFLAGS'
         [ 260]          [ 113]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 261]          [ 114]     NVCC="nvcc"
         [ 262]          [ 115] fi
         [ 263]          [ 116] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 264]          [ 117] AC_SUBST(CUDA_CFLAGS)
         [ 265]          [ 118] AC_SUBST(CUDA_LIBS)
         [ 266]          [ 119] AC_SUBST(NVCC)
       [CUDA Arch / Flags] line 263: 'arch=sm_86'
         [ 260]          [ 113]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 261]          [ 114]     NVCC="nvcc"
         [ 262]          [ 115] fi
         [ 263]          [ 116] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 264]          [ 117] AC_SUBST(CUDA_CFLAGS)
         [ 265]          [ 118] AC_SUBST(CUDA_LIBS)
         [ 266]          [ 119] AC_SUBST(NVCC)
       [CUDA Arch / Flags] line 267: 'NVCCFLAGS'
         [ 264]          [ 117] AC_SUBST(CUDA_CFLAGS)
         [ 265]          [ 118] AC_SUBST(CUDA_LIBS)
         [ 266]          [ 119] AC_SUBST(NVCC)
         [ 267]        [CUDA Arch / Flags] line 120: 'NVCCFLAGS'
         [ 268]          [ 117] AC_SUBST(CUDA_CFLAGS)
         [ 269]          [ 118] AC_SUBST(CUDA_LIBS)
         [ 270]          [ 119] AC_SUBST(NVCC)
       [CUDA Arch / Flags] line 271: 'NVCCFLAGS'
         [ 268]          [ 117] AC_SUBST(CUDA_CFLAGS)
         [ 269]          [ 118] AC_SUBST(CUDA_LIBS)
         [ 270]          [ 119] AC_SUBST(NVCC)
         [ 271]          [ 120] AC_SUBST(NVCCFLAGS)
         [ 272]          [ 121]
         [ 273]          [ 122]
         [ 274]          [ 123]
       [CUDA Arch / Flags] line 278: 'NVCCFLAGS'
         [ 275]   |- clustalw_help
         [ 276]   |- Makefile.in
         [ 277]     -> Referências importantes (com snippet):
         [ 278]        [CUDA Arch / Flags] line 250: 'NVCCFLAGS'
         [ 279]          [ 247] MAKEINFO = @MAKEINFO@
         [ 280]          [ 248] MKDIR_P = @MKDIR_P@
         [ 281]          [ 249] NVCC = @NVCC@
       [CUDA Arch / Flags] line 282: 'NVCCFLAGS'
         [ 279]          [ 247] MAKEINFO = @MAKEINFO@
         [ 280]          [ 248] MKDIR_P = @MKDIR_P@
         [ 281]          [ 249] NVCC = @NVCC@
         [ 282]          [ 250] NVCCFLAGS = @NVCCFLAGS@
         [ 283]          [ 251] OBJEXT = @OBJEXT@
         [ 284]          [ 252] PACKAGE = @PACKAGE@
         [ 285]          [ 253] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 282: 'NVCCFLAGS'
         [ 279]          [ 247] MAKEINFO = @MAKEINFO@
         [ 280]          [ 248] MKDIR_P = @MKDIR_P@
         [ 281]          [ 249] NVCC = @NVCC@
         [ 282]          [ 250] NVCCFLAGS = @NVCCFLAGS@
         [ 283]          [ 251] OBJEXT = @OBJEXT@
         [ 284]          [ 252] PACKAGE = @PACKAGE@
         [ 285]          [ 253] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 286: 'NVCCFLAGS'
         [ 283]          [ 251] OBJEXT = @OBJEXT@
         [ 284]          [ 252] PACKAGE = @PACKAGE@
         [ 285]          [ 253] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
         [ 286]        [CUDA Arch / Flags] line 250: 'NVCCFLAGS'
         [ 287]          [ 247] MAKEINFO = @MAKEINFO@
         [ 288]          [ 248] MKDIR_P = @MKDIR_P@
         [ 289]          [ 249] NVCC = @NVCC@
       [CUDA Arch / Flags] line 290: 'NVCCFLAGS'
         [ 287]          [ 247] MAKEINFO = @MAKEINFO@
         [ 288]          [ 248] MKDIR_P = @MKDIR_P@
         [ 289]          [ 249] NVCC = @NVCC@
         [ 290]          [ 250] NVCCFLAGS = @NVCCFLAGS@
         [ 291]          [ 251] OBJEXT = @OBJEXT@
         [ 292]          [ 252] PACKAGE = @PACKAGE@
         [ 293]          [ 253] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 290: 'NVCCFLAGS'
         [ 287]          [ 247] MAKEINFO = @MAKEINFO@
         [ 288]          [ 248] MKDIR_P = @MKDIR_P@
         [ 289]          [ 249] NVCC = @NVCC@
         [ 290]          [ 250] NVCCFLAGS = @NVCCFLAGS@
         [ 291]          [ 251] OBJEXT = @OBJEXT@
         [ 292]          [ 252] PACKAGE = @PACKAGE@
         [ 293]          [ 253] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 315: 'NVCCFLAGS'
         [ 312]          [ 777] 		;;
         [ 313]   |- Makefile
         [ 314]     -> Referências importantes (com snippet):
         [ 315]        [CUDA Arch / Flags] line 250: 'NVCCFLAGS'
         [ 316]          [ 247] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 317]          [ 248] MKDIR_P = /usr/bin/mkdir -p
         [ 318]          [ 249] NVCC = nvcc
       [CUDA Arch / Flags] line 319: 'NVCCFLAGS'
         [ 316]          [ 247] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 317]          [ 248] MKDIR_P = /usr/bin/mkdir -p
         [ 318]          [ 249] NVCC = nvcc
         [ 319]          [ 250] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 320]          [ 251] OBJEXT = o
         [ 321]          [ 252] PACKAGE = clustalw
         [ 322]          [ 253] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 319: 'arch=sm_86'
         [ 316]          [ 247] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 317]          [ 248] MKDIR_P = /usr/bin/mkdir -p
         [ 318]          [ 249] NVCC = nvcc
         [ 319]          [ 250] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 320]          [ 251] OBJEXT = o
         [ 321]          [ 252] PACKAGE = clustalw
         [ 322]          [ 253] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 323: 'arch=sm_86'
         [ 320]          [ 251] OBJEXT = o
         [ 321]          [ 252] PACKAGE = clustalw
         [ 322]          [ 253] PACKAGE_BUGREPORT = clustalw@ucd.ie
         [ 323]        [CUDA Arch / Flags] line 250: 'arch=sm_86'
         [ 324]          [ 247] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 325]          [ 248] MKDIR_P = /usr/bin/mkdir -p
         [ 326]          [ 249] NVCC = nvcc
       [CUDA Arch / Flags] line 327: 'NVCCFLAGS'
         [ 324]          [ 247] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 325]          [ 248] MKDIR_P = /usr/bin/mkdir -p
         [ 326]          [ 249] NVCC = nvcc
         [ 327]          [ 250] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 328]          [ 251] OBJEXT = o
         [ 329]          [ 252] PACKAGE = clustalw
         [ 330]          [ 253] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 327: 'arch=sm_86'
         [ 324]          [ 247] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 325]          [ 248] MKDIR_P = /usr/bin/mkdir -p
         [ 326]          [ 249] NVCC = nvcc
         [ 327]          [ 250] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 328]          [ 251] OBJEXT = o
         [ 329]          [ 252] PACKAGE = clustalw
         [ 330]          [ 253] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 338: 'NVCCFLAGS'
         [ 335]   |- config.h
         [ 336]   |- configure
         [ 337]     -> Referências importantes (com snippet):
         [ 338]        [CUDA Arch / Flags] line 658: 'NVCCFLAGS'
         [ 339]          [ 655] EGREP
         [ 340]          [ 656] GREP
         [ 341]          [ 657] RANLIB
       [CUDA Arch / Flags] line 342: 'NVCCFLAGS'
         [ 339]          [ 655] EGREP
         [ 340]          [ 656] GREP
         [ 341]          [ 657] RANLIB
         [ 342]          [ 658] NVCCFLAGS
         [ 343]          [ 659] NVCC
         [ 344]          [ 660] CUDA_LIBS
         [ 345]          [ 661] CUDA_CFLAGS
       [CUDA Arch / Flags] line 346: 'NVCCFLAGS'
         [ 343]          [ 659] NVCC
         [ 344]          [ 660] CUDA_LIBS
         [ 345]          [ 661] CUDA_CFLAGS
         [ 346]        [CUDA Arch / Flags] line 5464: 'NVCCFLAGS'
         [ 347]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 348]          [5462]     NVCC="nvcc"
         [ 349]          [5463] fi
       [CUDA Arch / Flags] line 350: 'NVCCFLAGS'
         [ 347]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 348]          [5462]     NVCC="nvcc"
         [ 349]          [5463] fi
         [ 350]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 351]          [5465]
         [ 352]          [5466]
         [ 353]          [5467]
       [CUDA Arch / Flags] line 350: 'arch=sm_86'
         [ 347]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 348]          [5462]     NVCC="nvcc"
         [ 349]          [5463] fi
         [ 350]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 351]          [5465]
         [ 352]          [5466]
         [ 353]          [5467]
       [CUDA Arch / Flags] line 354: 'arch=sm_86'
         [ 351]          [5465]
         [ 352]          [5466]
         [ 353]          [5467]
         [ 354]        [CUDA Arch / Flags] line 5464: 'arch=sm_86'
         [ 355]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 356]          [5462]     NVCC="nvcc"
         [ 357]          [5463] fi
       [CUDA Arch / Flags] line 358: 'NVCCFLAGS'
         [ 355]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 356]          [5462]     NVCC="nvcc"
         [ 357]          [5463] fi
         [ 358]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 359]          [5465]
         [ 360]          [5466]
         [ 361]          [5467]
       [CUDA Arch / Flags] line 358: 'arch=sm_86'
         [ 355]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 356]          [5462]     NVCC="nvcc"
         [ 357]          [5463] fi
         [ 358]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 359]          [5465]
         [ 360]          [5466]
         [ 361]          [5467]
       [CUDA Arch / Flags] line 423: 'NVCCFLAGS'
         [ 420]   |- intltool-update.in
         [ 421]   |- configure~
         [ 422]     -> Referências importantes (com snippet):
         [ 423]        [CUDA Arch / Flags] line 718: 'NVCCFLAGS'
         [ 424]          [ 715] CUDA_CFLAGS
         [ 425]          [ 716] CUDA_LIBS
         [ 426]          [ 717] NVCC
       [CUDA Arch / Flags] line 427: 'NVCCFLAGS'
         [ 424]          [ 715] CUDA_CFLAGS
         [ 425]          [ 716] CUDA_LIBS
         [ 426]          [ 717] NVCC
         [ 427]          [ 718] NVCCFLAGS
         [ 428]          [ 719] RANLIB
         [ 429]          [ 720] CPP
         [ 430]          [ 721] GREP
       [CUDA Arch / Flags] line 431: 'NVCCFLAGS'
         [ 428]          [ 719] RANLIB
         [ 429]          [ 720] CPP
         [ 430]          [ 721] GREP
         [ 431]        [CUDA Arch / Flags] line 4176: 'NVCCFLAGS'
         [ 432]          [4173]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 433]          [4174]     NVCC="nvcc"
         [ 434]          [4175] fi
       [CUDA Arch / Flags] line 435: 'NVCCFLAGS'
         [ 432]          [4173]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 433]          [4174]     NVCC="nvcc"
         [ 434]          [4175] fi
         [ 435]          [4176] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 436]          [4177]
         [ 437]          [4178]
         [ 438]          [4179]
       [CUDA Arch / Flags] line 435: 'arch=sm_86'
         [ 432]          [4173]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 433]          [4174]     NVCC="nvcc"
         [ 434]          [4175] fi
         [ 435]          [4176] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 436]          [4177]
         [ 437]          [4178]
         [ 438]          [4179]
       [CUDA Arch / Flags] line 439: 'arch=sm_13'
         [ 436]          [4177]
         [ 437]          [4178]
         [ 438]          [4179]
         [ 439]        [CUDA Arch / Flags] line 4176: 'arch=sm_13'
         [ 440]          [4173]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 441]          [4174]     NVCC="nvcc"
         [ 442]          [4175] fi
       [CUDA Arch / Flags] line 443: 'NVCCFLAGS'
         [ 440]          [4173]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 441]          [4174]     NVCC="nvcc"
         [ 442]          [4175] fi
         [ 443]          [4176] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 444]          [4177]
         [ 445]          [4178]
         [ 446]          [4179]
       [CUDA Arch / Flags] line 443: 'arch=sm_86'
         [ 440]          [4173]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 441]          [4174]     NVCC="nvcc"
         [ 442]          [4175] fi
         [ 443]          [4176] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 444]          [4177]
         [ 445]          [4178]
         [ 446]          [4179]
       [CUDA Arch / Flags] line 447: 'NVCCFLAGS'
         [ 444]          [4177]
         [ 445]          [4178]
         [ 446]          [4179]
         [ 447]        [CUDA Arch / Flags] line 6657: 'NVCCFLAGS'
         [ 448]          [6654] CUDA_CFLAGS!$CUDA_CFLAGS$ac_delim
         [ 449]          [6655] CUDA_LIBS!$CUDA_LIBS$ac_delim
         [ 450]          [6656] NVCC!$NVCC$ac_delim
       [CUDA Arch / Flags] line 451: 'NVCCFLAGS'
         [ 448]          [6654] CUDA_CFLAGS!$CUDA_CFLAGS$ac_delim
         [ 449]          [6655] CUDA_LIBS!$CUDA_LIBS$ac_delim
         [ 450]          [6656] NVCC!$NVCC$ac_delim
         [ 451]          [6657] NVCCFLAGS!$NVCCFLAGS$ac_delim
         [ 452]          [6658] RANLIB!$RANLIB$ac_delim
         [ 453]          [6659] CPP!$CPP$ac_delim
         [ 454]          [6660] GREP!$GREP$ac_delim
       [CUDA Arch / Flags] line 451: 'NVCCFLAGS'
         [ 448]          [6654] CUDA_CFLAGS!$CUDA_CFLAGS$ac_delim
         [ 449]          [6655] CUDA_LIBS!$CUDA_LIBS$ac_delim
         [ 450]          [6656] NVCC!$NVCC$ac_delim
         [ 451]          [6657] NVCCFLAGS!$NVCCFLAGS$ac_delim
         [ 452]          [6658] RANLIB!$RANLIB$ac_delim
         [ 453]          [6659] CPP!$CPP$ac_delim
         [ 454]          [6660] GREP!$GREP$ac_delim
       [CUDA Arch / Flags] line 455: 'NVCCFLAGS'
         [ 452]          [6658] RANLIB!$RANLIB$ac_delim
         [ 453]          [6659] CPP!$CPP$ac_delim
         [ 454]          [6660] GREP!$GREP$ac_delim
         [ 455]        [CUDA Arch / Flags] line 6657: 'NVCCFLAGS'
         [ 456]          [6654] CUDA_CFLAGS!$CUDA_CFLAGS$ac_delim
         [ 457]          [6655] CUDA_LIBS!$CUDA_LIBS$ac_delim
         [ 458]          [6656] NVCC!$NVCC$ac_delim
       [CUDA Arch / Flags] line 459: 'NVCCFLAGS'
         [ 456]          [6654] CUDA_CFLAGS!$CUDA_CFLAGS$ac_delim
         [ 457]          [6655] CUDA_LIBS!$CUDA_LIBS$ac_delim
         [ 458]          [6656] NVCC!$NVCC$ac_delim
         [ 459]          [6657] NVCCFLAGS!$NVCCFLAGS$ac_delim
         [ 460]          [6658] RANLIB!$RANLIB$ac_delim
         [ 461]          [6659] CPP!$CPP$ac_delim
         [ 462]          [6660] GREP!$GREP$ac_delim
       [CUDA Arch / Flags] line 459: 'NVCCFLAGS'
         [ 456]          [6654] CUDA_CFLAGS!$CUDA_CFLAGS$ac_delim
         [ 457]          [6655] CUDA_LIBS!$CUDA_LIBS$ac_delim
         [ 458]          [6656] NVCC!$NVCC$ac_delim
         [ 459]          [6657] NVCCFLAGS!$NVCCFLAGS$ac_delim
         [ 460]          [6658] RANLIB!$RANLIB$ac_delim
         [ 461]          [6659] CPP!$CPP$ac_delim
         [ 462]          [6660] GREP!$GREP$ac_delim
       [CUDA Arch / Flags] line 521: 'NVCCFLAGS'
         [ 518]          [6936] $extrasub
         [ 519]   |- config.status
         [ 520]     -> Referências importantes (com snippet):
         [ 521]        [CUDA Arch / Flags] line 620: 'NVCCFLAGS'
         [ 522]          [ 617] S["EGREP"]="/usr/bin/grep -E"
         [ 523]          [ 618] S["GREP"]="/usr/bin/grep"
         [ 524]          [ 619] S["RANLIB"]="ranlib"
       [CUDA Arch / Flags] line 525: 'NVCCFLAGS'
         [ 522]          [ 617] S["EGREP"]="/usr/bin/grep -E"
         [ 523]          [ 618] S["GREP"]="/usr/bin/grep"
         [ 524]          [ 619] S["RANLIB"]="ranlib"
         [ 525]          [ 620] S["NVCCFLAGS"]="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 526]          [ 621] S["NVCC"]="nvcc"
         [ 527]          [ 622] S["CUDA_LIBS"]="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 528]          [ 623] S["CUDA_CFLAGS"]="-I/usr/local/cuda/include"
       [CUDA Arch / Flags] line 525: 'arch=sm_86'
         [ 522]          [ 617] S["EGREP"]="/usr/bin/grep -E"
         [ 523]          [ 618] S["GREP"]="/usr/bin/grep"
         [ 524]          [ 619] S["RANLIB"]="ranlib"
         [ 525]          [ 620] S["NVCCFLAGS"]="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 526]          [ 621] S["NVCC"]="nvcc"
         [ 527]          [ 622] S["CUDA_LIBS"]="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 528]          [ 623] S["CUDA_CFLAGS"]="-I/usr/local/cuda/include"
       [CUDA Arch / Flags] line 529: 'arch=sm_86'
         [ 526]          [ 621] S["NVCC"]="nvcc"
         [ 527]          [ 622] S["CUDA_LIBS"]="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 528]          [ 623] S["CUDA_CFLAGS"]="-I/usr/local/cuda/include"
         [ 529]        [CUDA Arch / Flags] line 620: 'arch=sm_86'
         [ 530]          [ 617] S["EGREP"]="/usr/bin/grep -E"
         [ 531]          [ 618] S["GREP"]="/usr/bin/grep"
         [ 532]          [ 619] S["RANLIB"]="ranlib"
       [CUDA Arch / Flags] line 533: 'NVCCFLAGS'
         [ 530]          [ 617] S["EGREP"]="/usr/bin/grep -E"
         [ 531]          [ 618] S["GREP"]="/usr/bin/grep"
         [ 532]          [ 619] S["RANLIB"]="ranlib"
         [ 533]          [ 620] S["NVCCFLAGS"]="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 534]          [ 621] S["NVCC"]="nvcc"
         [ 535]          [ 622] S["CUDA_LIBS"]="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 536]          [ 623] S["CUDA_CFLAGS"]="-I/usr/local/cuda/include"
       [CUDA Arch / Flags] line 533: 'arch=sm_86'
         [ 530]          [ 617] S["EGREP"]="/usr/bin/grep -E"
         [ 531]          [ 618] S["GREP"]="/usr/bin/grep"
         [ 532]          [ 619] S["RANLIB"]="ranlib"
         [ 533]          [ 620] S["NVCCFLAGS"]="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 534]          [ 621] S["NVCC"]="nvcc"
         [ 535]          [ 622] S["CUDA_LIBS"]="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 536]          [ 623] S["CUDA_CFLAGS"]="-I/usr/local/cuda/include"
       [CUDA Arch / Flags] line 555: 'NVCCFLAGS'
         [ 552]          [ 980] /datarootdir/ {
         [ 553]   |- config.log
         [ 554]     -> Referências importantes (com snippet):
         [ 555]        [CUDA Arch / Flags] line 566: 'NVCCFLAGS'
         [ 556]          [ 563] MAKEINFO='${SHELL} '\''/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing'\'' makeinfo'
         [ 557]          [ 564] MKDIR_P='/usr/bin/mkdir -p'
         [ 558]          [ 565] NVCC='nvcc'
       [CUDA Arch / Flags] line 559: 'NVCCFLAGS'
         [ 556]          [ 563] MAKEINFO='${SHELL} '\''/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing'\'' makeinfo'
         [ 557]          [ 564] MKDIR_P='/usr/bin/mkdir -p'
         [ 558]          [ 565] NVCC='nvcc'
         [ 559]          [ 566] NVCCFLAGS='-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp '
         [ 560]          [ 567] OBJEXT='o'
         [ 561]          [ 568] PACKAGE='clustalw'
         [ 562]          [ 569] PACKAGE_BUGREPORT='clustalw@ucd.ie'
       [CUDA Arch / Flags] line 559: 'arch=sm_86'
         [ 556]          [ 563] MAKEINFO='${SHELL} '\''/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing'\'' makeinfo'
         [ 557]          [ 564] MKDIR_P='/usr/bin/mkdir -p'
         [ 558]          [ 565] NVCC='nvcc'
         [ 559]          [ 566] NVCCFLAGS='-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp '
         [ 560]          [ 567] OBJEXT='o'
         [ 561]          [ 568] PACKAGE='clustalw'
         [ 562]          [ 569] PACKAGE_BUGREPORT='clustalw@ucd.ie'
       [CUDA Arch / Flags] line 563: 'arch=sm_86'
         [ 560]          [ 567] OBJEXT='o'
         [ 561]          [ 568] PACKAGE='clustalw'
         [ 562]          [ 569] PACKAGE_BUGREPORT='clustalw@ucd.ie'
         [ 563]        [CUDA Arch / Flags] line 566: 'arch=sm_86'
         [ 564]          [ 563] MAKEINFO='${SHELL} '\''/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing'\'' makeinfo'
         [ 565]          [ 564] MKDIR_P='/usr/bin/mkdir -p'
         [ 566]          [ 565] NVCC='nvcc'
       [CUDA Arch / Flags] line 567: 'NVCCFLAGS'
         [ 564]          [ 563] MAKEINFO='${SHELL} '\''/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing'\'' makeinfo'
         [ 565]          [ 564] MKDIR_P='/usr/bin/mkdir -p'
         [ 566]          [ 565] NVCC='nvcc'
         [ 567]          [ 566] NVCCFLAGS='-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp '
         [ 568]          [ 567] OBJEXT='o'
         [ 569]          [ 568] PACKAGE='clustalw'
         [ 570]          [ 569] PACKAGE_BUGREPORT='clustalw@ucd.ie'
       [CUDA Arch / Flags] line 567: 'arch=sm_86'
         [ 564]          [ 563] MAKEINFO='${SHELL} '\''/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing'\'' makeinfo'
         [ 565]          [ 564] MKDIR_P='/usr/bin/mkdir -p'
         [ 566]          [ 565] NVCC='nvcc'
         [ 567]          [ 566] NVCCFLAGS='-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp '
         [ 568]          [ 567] OBJEXT='o'
         [ 569]          [ 568] PACKAGE='clustalw'
         [ 570]          [ 569] PACKAGE_BUGREPORT='clustalw@ucd.ie'
       [CUDA Arch / Flags] line 593: 'NVCCFLAGS'
         [ 590] [DIRECTORY] m4
         [ 591]   |- Makefile.in
         [ 592]     -> Referências importantes (com snippet):
         [ 593]        [CUDA Arch / Flags] line 195: 'NVCCFLAGS'
         [ 594]          [ 192] MAKEINFO = @MAKEINFO@
         [ 595]          [ 193] MKDIR_P = @MKDIR_P@
         [ 596]          [ 194] NVCC = @NVCC@
       [CUDA Arch / Flags] line 597: 'NVCCFLAGS'
         [ 594]          [ 192] MAKEINFO = @MAKEINFO@
         [ 595]          [ 193] MKDIR_P = @MKDIR_P@
         [ 596]          [ 194] NVCC = @NVCC@
         [ 597]          [ 195] NVCCFLAGS = @NVCCFLAGS@
         [ 598]          [ 196] OBJEXT = @OBJEXT@
         [ 599]          [ 197] PACKAGE = @PACKAGE@
         [ 600]          [ 198] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 597: 'NVCCFLAGS'
         [ 594]          [ 192] MAKEINFO = @MAKEINFO@
         [ 595]          [ 193] MKDIR_P = @MKDIR_P@
         [ 596]          [ 194] NVCC = @NVCC@
         [ 597]          [ 195] NVCCFLAGS = @NVCCFLAGS@
         [ 598]          [ 196] OBJEXT = @OBJEXT@
         [ 599]          [ 197] PACKAGE = @PACKAGE@
         [ 600]          [ 198] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 601: 'NVCCFLAGS'
         [ 598]          [ 196] OBJEXT = @OBJEXT@
         [ 599]          [ 197] PACKAGE = @PACKAGE@
         [ 600]          [ 198] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
         [ 601]        [CUDA Arch / Flags] line 195: 'NVCCFLAGS'
         [ 602]          [ 192] MAKEINFO = @MAKEINFO@
         [ 603]          [ 193] MKDIR_P = @MKDIR_P@
         [ 604]          [ 194] NVCC = @NVCC@
       [CUDA Arch / Flags] line 605: 'NVCCFLAGS'
         [ 602]          [ 192] MAKEINFO = @MAKEINFO@
         [ 603]          [ 193] MKDIR_P = @MKDIR_P@
         [ 604]          [ 194] NVCC = @NVCC@
         [ 605]          [ 195] NVCCFLAGS = @NVCCFLAGS@
         [ 606]          [ 196] OBJEXT = @OBJEXT@
         [ 607]          [ 197] PACKAGE = @PACKAGE@
         [ 608]          [ 198] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 605: 'NVCCFLAGS'
         [ 602]          [ 192] MAKEINFO = @MAKEINFO@
         [ 603]          [ 193] MKDIR_P = @MKDIR_P@
         [ 604]          [ 194] NVCC = @NVCC@
         [ 605]          [ 195] NVCCFLAGS = @NVCCFLAGS@
         [ 606]          [ 196] OBJEXT = @OBJEXT@
         [ 607]          [ 197] PACKAGE = @PACKAGE@
         [ 608]          [ 198] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 611: 'NVCCFLAGS'
         [ 608]          [ 198] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
         [ 609]   |- Makefile
         [ 610]     -> Referências importantes (com snippet):
         [ 611]        [CUDA Arch / Flags] line 195: 'NVCCFLAGS'
         [ 612]          [ 192] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 613]          [ 193] MKDIR_P = /usr/bin/mkdir -p
         [ 614]          [ 194] NVCC = nvcc
       [CUDA Arch / Flags] line 615: 'NVCCFLAGS'
         [ 612]          [ 192] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 613]          [ 193] MKDIR_P = /usr/bin/mkdir -p
         [ 614]          [ 194] NVCC = nvcc
         [ 615]          [ 195] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 616]          [ 196] OBJEXT = o
         [ 617]          [ 197] PACKAGE = clustalw
         [ 618]          [ 198] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 615: 'arch=sm_86'
         [ 612]          [ 192] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 613]          [ 193] MKDIR_P = /usr/bin/mkdir -p
         [ 614]          [ 194] NVCC = nvcc
         [ 615]          [ 195] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 616]          [ 196] OBJEXT = o
         [ 617]          [ 197] PACKAGE = clustalw
         [ 618]          [ 198] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 619: 'arch=sm_86'
         [ 616]          [ 196] OBJEXT = o
         [ 617]          [ 197] PACKAGE = clustalw
         [ 618]          [ 198] PACKAGE_BUGREPORT = clustalw@ucd.ie
         [ 619]        [CUDA Arch / Flags] line 195: 'arch=sm_86'
         [ 620]          [ 192] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 621]          [ 193] MKDIR_P = /usr/bin/mkdir -p
         [ 622]          [ 194] NVCC = nvcc
       [CUDA Arch / Flags] line 623: 'NVCCFLAGS'
         [ 620]          [ 192] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 621]          [ 193] MKDIR_P = /usr/bin/mkdir -p
         [ 622]          [ 194] NVCC = nvcc
         [ 623]          [ 195] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 624]          [ 196] OBJEXT = o
         [ 625]          [ 197] PACKAGE = clustalw
         [ 626]          [ 198] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 623: 'arch=sm_86'
         [ 620]          [ 192] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 621]          [ 193] MKDIR_P = /usr/bin/mkdir -p
         [ 622]          [ 194] NVCC = nvcc
         [ 623]          [ 195] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 624]          [ 196] OBJEXT = o
         [ 625]          [ 197] PACKAGE = clustalw
         [ 626]          [ 198] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 632: 'NVCCFLAGS'
         [ 629] [DIRECTORY] autom4te.cache
         [ 630]   |- output.0
         [ 631]     -> Referências importantes (com snippet):
         [ 632]        [CUDA Arch / Flags] line 658: 'NVCCFLAGS'
         [ 633]          [ 655] EGREP
         [ 634]          [ 656] GREP
         [ 635]          [ 657] RANLIB
       [CUDA Arch / Flags] line 636: 'NVCCFLAGS'
         [ 633]          [ 655] EGREP
         [ 634]          [ 656] GREP
         [ 635]          [ 657] RANLIB
         [ 636]          [ 658] NVCCFLAGS
         [ 637]          [ 659] NVCC
         [ 638]          [ 660] CUDA_LIBS
         [ 639]          [ 661] CUDA_CFLAGS
       [CUDA Arch / Flags] line 640: 'NVCCFLAGS'
         [ 637]          [ 659] NVCC
         [ 638]          [ 660] CUDA_LIBS
         [ 639]          [ 661] CUDA_CFLAGS
         [ 640]        [CUDA Arch / Flags] line 5464: 'NVCCFLAGS'
         [ 641]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 642]          [5462]     NVCC="nvcc"
         [ 643]          [5463] fi
       [CUDA Arch / Flags] line 644: 'NVCCFLAGS'
         [ 641]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 642]          [5462]     NVCC="nvcc"
         [ 643]          [5463] fi
         [ 644]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 645]          [5465]
         [ 646]          [5466]
         [ 647]          [5467]
       [CUDA Arch / Flags] line 644: 'arch=sm_86'
         [ 641]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 642]          [5462]     NVCC="nvcc"
         [ 643]          [5463] fi
         [ 644]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 645]          [5465]
         [ 646]          [5466]
         [ 647]          [5467]
       [CUDA Arch / Flags] line 648: 'arch=sm_86'
         [ 645]          [5465]
         [ 646]          [5466]
         [ 647]          [5467]
         [ 648]        [CUDA Arch / Flags] line 5464: 'arch=sm_86'
         [ 649]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 650]          [5462]     NVCC="nvcc"
         [ 651]          [5463] fi
       [CUDA Arch / Flags] line 652: 'NVCCFLAGS'
         [ 649]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 650]          [5462]     NVCC="nvcc"
         [ 651]          [5463] fi
         [ 652]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 653]          [5465]
         [ 654]          [5466]
         [ 655]          [5467]
       [CUDA Arch / Flags] line 652: 'arch=sm_86'
         [ 649]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 650]          [5462]     NVCC="nvcc"
         [ 651]          [5463] fi
         [ 652]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 653]          [5465]
         [ 654]          [5466]
         [ 655]          [5467]
       [CUDA Arch / Flags] line 714: 'NVCCFLAGS'
         [ 711]          [7378] $extrasub
         [ 712]   |- traces.0
         [ 713]     -> Referências importantes (com snippet):
         [ 714]        [CUDA Arch / Flags] line 992: 'NVCCFLAGS'
         [ 715]          [ 989] m4trace:configure.ac:117: -1- m4_pattern_allow([^CUDA_CFLAGS$])
         [ 716]          [ 990] m4trace:configure.ac:118: -1- m4_pattern_allow([^CUDA_LIBS$])
         [ 717]          [ 991] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
       [CUDA Arch / Flags] line 718: 'NVCCFLAGS'
         [ 715]          [ 989] m4trace:configure.ac:117: -1- m4_pattern_allow([^CUDA_CFLAGS$])
         [ 716]          [ 990] m4trace:configure.ac:118: -1- m4_pattern_allow([^CUDA_LIBS$])
         [ 717]          [ 991] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 718]          [ 992] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 719]          [ 993] m4trace:configure.ac:129: -1- m4_pattern_allow([^RANLIB$])
         [ 720]          [ 994] m4trace:configure.ac:136: -1- _m4_warn([obsolete], [The macro `AC_HEADER_STDC' is obsolete.
         [ 721]          [ 995] You should run autoupdate.], [./lib/autoconf/headers.m4:704: AC_HEADER_STDC is expanded from...
       [CUDA Arch / Flags] line 741: 'NVCCFLAGS'
         [ 738]   |- traces.4t
         [ 739]   |- traces.2
         [ 740]     -> Referências importantes (com snippet):
         [ 741]        [CUDA Arch / Flags] line 478: 'NVCCFLAGS'
         [ 742]          [ 475] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
         [ 743]          [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [ 744]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
       [CUDA Arch / Flags] line 745: 'NVCCFLAGS'
         [ 742]          [ 475] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
         [ 743]          [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [ 744]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 745]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 746]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 747]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 748]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
       [CUDA Arch / Flags] line 746: 'NVCCFLAGS'
         [ 743]          [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [ 744]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 745]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 746]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 747]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 748]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 749]        [CUDA Arch / Flags] line 479: 'NVCCFLAGS'
       [CUDA Arch / Flags] line 747: 'NVCCFLAGS'
         [ 744]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 745]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 746]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 747]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 748]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 749]        [CUDA Arch / Flags] line 479: 'NVCCFLAGS'
         [ 750]          [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
       [CUDA Arch / Flags] line 749: 'NVCCFLAGS'
         [ 746]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 747]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 748]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 749]        [CUDA Arch / Flags] line 479: 'NVCCFLAGS'
         [ 750]          [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [ 751]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 752]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
       [CUDA Arch / Flags] line 752: 'NVCCFLAGS'
         [ 749]        [CUDA Arch / Flags] line 479: 'NVCCFLAGS'
         [ 750]          [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [ 751]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 752]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 753]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 754]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 755]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
       [CUDA Arch / Flags] line 753: 'NVCCFLAGS'
         [ 750]          [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [ 751]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 752]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 753]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 754]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 755]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 756]          [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
       [CUDA Arch / Flags] line 754: 'NVCCFLAGS'
         [ 751]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 752]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 753]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 754]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 755]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 756]          [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
         [ 757]        [CUDA Arch / Flags] line 480: 'NVCCFLAGS'
       [CUDA Arch / Flags] line 757: 'NVCCFLAGS'
         [ 754]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 755]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 756]          [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
         [ 757]        [CUDA Arch / Flags] line 480: 'NVCCFLAGS'
         [ 758]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 759]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 760]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
       [CUDA Arch / Flags] line 759: 'NVCCFLAGS'
         [ 756]          [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
         [ 757]        [CUDA Arch / Flags] line 480: 'NVCCFLAGS'
         [ 758]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 759]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 760]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 761]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 762]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
       [CUDA Arch / Flags] line 760: 'NVCCFLAGS'
         [ 757]        [CUDA Arch / Flags] line 480: 'NVCCFLAGS'
         [ 758]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 759]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 760]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 761]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 762]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 763]          [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
       [CUDA Arch / Flags] line 761: 'NVCCFLAGS'
         [ 758]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 759]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 760]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 761]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 762]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 763]          [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
         [ 764]          [ 483] m4trace:configure.ac:129: -1- m4_pattern_allow([^RANLIB$])
       [CUDA Arch / Flags] line 767: 'NVCCFLAGS'
         [ 764]          [ 483] m4trace:configure.ac:129: -1- m4_pattern_allow([^RANLIB$])
         [ 765]   |- output.2
         [ 766]     -> Referências importantes (com snippet):
         [ 767]        [CUDA Arch / Flags] line 658: 'NVCCFLAGS'
         [ 768]          [ 655] EGREP
         [ 769]          [ 656] GREP
         [ 770]          [ 657] RANLIB
       [CUDA Arch / Flags] line 771: 'NVCCFLAGS'
         [ 768]          [ 655] EGREP
         [ 769]          [ 656] GREP
         [ 770]          [ 657] RANLIB
         [ 771]          [ 658] NVCCFLAGS
         [ 772]          [ 659] NVCC
         [ 773]          [ 660] CUDA_LIBS
         [ 774]          [ 661] CUDA_CFLAGS
       [CUDA Arch / Flags] line 775: 'NVCCFLAGS'
         [ 772]          [ 659] NVCC
         [ 773]          [ 660] CUDA_LIBS
         [ 774]          [ 661] CUDA_CFLAGS
         [ 775]        [CUDA Arch / Flags] line 5464: 'NVCCFLAGS'
         [ 776]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 777]          [5462]     NVCC="nvcc"
         [ 778]          [5463] fi
       [CUDA Arch / Flags] line 779: 'NVCCFLAGS'
         [ 776]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 777]          [5462]     NVCC="nvcc"
         [ 778]          [5463] fi
         [ 779]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 780]          [5465]
         [ 781]          [5466]
         [ 782]          [5467]
       [CUDA Arch / Flags] line 779: 'arch=sm_86'
         [ 776]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 777]          [5462]     NVCC="nvcc"
         [ 778]          [5463] fi
         [ 779]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 780]          [5465]
         [ 781]          [5466]
         [ 782]          [5467]
       [CUDA Arch / Flags] line 783: 'arch=sm_86'
         [ 780]          [5465]
         [ 781]          [5466]
         [ 782]          [5467]
         [ 783]        [CUDA Arch / Flags] line 5464: 'arch=sm_86'
         [ 784]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 785]          [5462]     NVCC="nvcc"
         [ 786]          [5463] fi
       [CUDA Arch / Flags] line 787: 'NVCCFLAGS'
         [ 784]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 785]          [5462]     NVCC="nvcc"
         [ 786]          [5463] fi
         [ 787]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 788]          [5465]
         [ 789]          [5466]
         [ 790]          [5467]
       [CUDA Arch / Flags] line 787: 'arch=sm_86'
         [ 784]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 785]          [5462]     NVCC="nvcc"
         [ 786]          [5463] fi
         [ 787]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 788]          [5465]
         [ 789]          [5466]
         [ 790]          [5467]
       [CUDA Arch / Flags] line 849: 'NVCCFLAGS'
         [ 846]          [7378] $extrasub
         [ 847]   |- output.3
         [ 848]     -> Referências importantes (com snippet):
         [ 849]        [CUDA Arch / Flags] line 313: 'NVCCFLAGS'
         [ 850]          [ 310] # include <unistd.h>
         [ 851]          [ 311] #endif"
         [ 852]          [ 312]
       [CUDA Arch / Flags] line 853: 'NVCCFLAGS'
         [ 850]          [ 310] # include <unistd.h>
         [ 851]          [ 311] #endif"
         [ 852]          [ 312]
         [ 853]          [ 313] ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CLUSTALW_VERSION CLUSTALW_NAME INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CXX CXXFLAGS ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE noopenmp noopenmp_TRUE noopenmp_FALSE CUDA_CFLAGS CUDA_LIBS NVCC NVCCFLAGS RANLIB ac_ct_RANLIB CPP EGREP LIB@&t@OBJS LTLIBOBJS'
         [ 854]          [ 314] ac_subst_files=''
         [ 855]          [ 315]
         [ 856]          [ 316] # Initialize some variables set by options.
       [CUDA Arch / Flags] line 857: 'NVCCFLAGS'
         [ 854]          [ 314] ac_subst_files=''
         [ 855]          [ 315]
         [ 856]          [ 316] # Initialize some variables set by options.
         [ 857]        [CUDA Arch / Flags] line 3660: 'NVCCFLAGS'
         [ 858]          [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 859]          [3658]     NVCC="nvcc"
         [ 860]          [3659] fi
       [CUDA Arch / Flags] line 861: 'NVCCFLAGS'
         [ 858]          [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 859]          [3658]     NVCC="nvcc"
         [ 860]          [3659] fi
         [ 861]          [3660] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 862]          [3661]
         [ 863]          [3662]
         [ 864]          [3663]
       [CUDA Arch / Flags] line 861: 'arch=sm_86'
         [ 858]          [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 859]          [3658]     NVCC="nvcc"
         [ 860]          [3659] fi
         [ 861]          [3660] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 862]          [3661]
         [ 863]          [3662]
         [ 864]          [3663]
       [CUDA Arch / Flags] line 865: 'arch=sm_13'
         [ 862]          [3661]
         [ 863]          [3662]
         [ 864]          [3663]
         [ 865]        [CUDA Arch / Flags] line 3660: 'arch=sm_13'
         [ 866]          [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 867]          [3658]     NVCC="nvcc"
         [ 868]          [3659] fi
       [CUDA Arch / Flags] line 869: 'NVCCFLAGS'
         [ 866]          [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 867]          [3658]     NVCC="nvcc"
         [ 868]          [3659] fi
         [ 869]          [3660] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 870]          [3661]
         [ 871]          [3662]
         [ 872]          [3663]
       [CUDA Arch / Flags] line 869: 'arch=sm_86'
         [ 866]          [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 867]          [3658]     NVCC="nvcc"
         [ 868]          [3659] fi
         [ 869]          [3660] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 870]          [3661]
         [ 871]          [3662]
         [ 872]          [3663]
       [CUDA Arch / Flags] line 873: 'NVCCFLAGS'
         [ 870]          [3661]
         [ 871]          [3662]
         [ 872]          [3663]
         [ 873]        [CUDA Arch / Flags] line 5872: 'NVCCFLAGS'
         [ 874]          [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [ 875]          [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [ 876]          [5871] s,@NVCC@,$NVCC,;t t
       [CUDA Arch / Flags] line 877: 'NVCCFLAGS'
         [ 874]          [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [ 875]          [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [ 876]          [5871] s,@NVCC@,$NVCC,;t t
         [ 877]          [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [ 878]          [5873] s,@RANLIB@,$RANLIB,;t t
         [ 879]          [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [ 880]          [5875] s,@CPP@,$CPP,;t t
       [CUDA Arch / Flags] line 877: 'NVCCFLAGS'
         [ 874]          [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [ 875]          [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [ 876]          [5871] s,@NVCC@,$NVCC,;t t
         [ 877]          [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [ 878]          [5873] s,@RANLIB@,$RANLIB,;t t
         [ 879]          [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [ 880]          [5875] s,@CPP@,$CPP,;t t
       [CUDA Arch / Flags] line 881: 'NVCCFLAGS'
         [ 878]          [5873] s,@RANLIB@,$RANLIB,;t t
         [ 879]          [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [ 880]          [5875] s,@CPP@,$CPP,;t t
         [ 881]        [CUDA Arch / Flags] line 5872: 'NVCCFLAGS'
         [ 882]          [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [ 883]          [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [ 884]          [5871] s,@NVCC@,$NVCC,;t t
       [CUDA Arch / Flags] line 885: 'NVCCFLAGS'
         [ 882]          [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [ 883]          [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [ 884]          [5871] s,@NVCC@,$NVCC,;t t
         [ 885]          [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [ 886]          [5873] s,@RANLIB@,$RANLIB,;t t
         [ 887]          [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [ 888]          [5875] s,@CPP@,$CPP,;t t
       [CUDA Arch / Flags] line 885: 'NVCCFLAGS'
         [ 882]          [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [ 883]          [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [ 884]          [5871] s,@NVCC@,$NVCC,;t t
         [ 885]          [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [ 886]          [5873] s,@RANLIB@,$RANLIB,;t t
         [ 887]          [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [ 888]          [5875] s,@CPP@,$CPP,;t t
       [CUDA Arch / Flags] line 939: 'NVCCFLAGS'
         [ 936]          [4504]   typedef int charset[2];
         [ 937]   |- traces.3
         [ 938]     -> Referências importantes (com snippet):
         [ 939]        [CUDA Arch / Flags] line 179: 'NVCCFLAGS'
         [ 940]          [ 176] m4trace:configure.ac:117: -1- AC_SUBST([CUDA_CFLAGS])
         [ 941]          [ 177] m4trace:configure.ac:118: -1- AC_SUBST([CUDA_LIBS])
         [ 942]          [ 178] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
       [CUDA Arch / Flags] line 943: 'NVCCFLAGS'
         [ 940]          [ 176] m4trace:configure.ac:117: -1- AC_SUBST([CUDA_CFLAGS])
         [ 941]          [ 177] m4trace:configure.ac:118: -1- AC_SUBST([CUDA_LIBS])
         [ 942]          [ 178] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
         [ 943]          [ 179] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 944]          [ 180] m4trace:configure.ac:129: -1- AC_PROG_RANLIB
         [ 945]          [ 181] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 946]          [ 182] m4trace:configure.ac:129: -1- AC_SUBST([ac_ct_RANLIB])
       [CUDA Arch / Flags] line 951: 'NVCCFLAGS'
         [ 948]   |- output.4t
         [ 949]   |- output.1
         [ 950]     -> Referências importantes (com snippet):
         [ 951]        [CUDA Arch / Flags] line 658: 'NVCCFLAGS'
         [ 952]          [ 655] EGREP
         [ 953]          [ 656] GREP
         [ 954]          [ 657] RANLIB
       [CUDA Arch / Flags] line 955: 'NVCCFLAGS'
         [ 952]          [ 655] EGREP
         [ 953]          [ 656] GREP
         [ 954]          [ 657] RANLIB
         [ 955]          [ 658] NVCCFLAGS
         [ 956]          [ 659] NVCC
         [ 957]          [ 660] CUDA_LIBS
         [ 958]          [ 661] CUDA_CFLAGS
       [CUDA Arch / Flags] line 959: 'NVCCFLAGS'
         [ 956]          [ 659] NVCC
         [ 957]          [ 660] CUDA_LIBS
         [ 958]          [ 661] CUDA_CFLAGS
         [ 959]        [CUDA Arch / Flags] line 5464: 'NVCCFLAGS'
         [ 960]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 961]          [5462]     NVCC="nvcc"
         [ 962]          [5463] fi
       [CUDA Arch / Flags] line 963: 'NVCCFLAGS'
         [ 960]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 961]          [5462]     NVCC="nvcc"
         [ 962]          [5463] fi
         [ 963]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 964]          [5465]
         [ 965]          [5466]
         [ 966]          [5467]
       [CUDA Arch / Flags] line 963: 'arch=sm_86'
         [ 960]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 961]          [5462]     NVCC="nvcc"
         [ 962]          [5463] fi
         [ 963]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 964]          [5465]
         [ 965]          [5466]
         [ 966]          [5467]
       [CUDA Arch / Flags] line 967: 'arch=sm_86'
         [ 964]          [5465]
         [ 965]          [5466]
         [ 966]          [5467]
         [ 967]        [CUDA Arch / Flags] line 5464: 'arch=sm_86'
         [ 968]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 969]          [5462]     NVCC="nvcc"
         [ 970]          [5463] fi
       [CUDA Arch / Flags] line 971: 'NVCCFLAGS'
         [ 968]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 969]          [5462]     NVCC="nvcc"
         [ 970]          [5463] fi
         [ 971]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 972]          [5465]
         [ 973]          [5466]
         [ 974]          [5467]
       [CUDA Arch / Flags] line 971: 'arch=sm_86'
         [ 968]          [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 969]          [5462]     NVCC="nvcc"
         [ 970]          [5463] fi
         [ 971]          [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 972]          [5465]
         [ 973]          [5466]
         [ 974]          [5467]
       [CUDA Arch / Flags] line 1033: 'NVCCFLAGS'
         [1030]          [7378] $extrasub
         [1031]   |- output.4
         [1032]     -> Referências importantes (com snippet):
         [1033]        [CUDA Arch / Flags] line 313: 'NVCCFLAGS'
         [1034]          [ 310] # include <unistd.h>
         [1035]          [ 311] #endif"
         [1036]          [ 312]
       [CUDA Arch / Flags] line 1037: 'NVCCFLAGS'
         [1034]          [ 310] # include <unistd.h>
         [1035]          [ 311] #endif"
         [1036]          [ 312]
         [1037]          [ 313] ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CLUSTALW_VERSION CLUSTALW_NAME INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CXX CXXFLAGS ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE noopenmp noopenmp_TRUE noopenmp_FALSE CUDA_CFLAGS CUDA_LIBS NVCC NVCCFLAGS RANLIB ac_ct_RANLIB CPP EGREP LIB@&t@OBJS LTLIBOBJS'
         [1038]          [ 314] ac_subst_files=''
         [1039]          [ 315]
         [1040]          [ 316] # Initialize some variables set by options.
       [CUDA Arch / Flags] line 1041: 'NVCCFLAGS'
         [1038]          [ 314] ac_subst_files=''
         [1039]          [ 315]
         [1040]          [ 316] # Initialize some variables set by options.
         [1041]        [CUDA Arch / Flags] line 3660: 'NVCCFLAGS'
         [1042]          [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [1043]          [3658]     NVCC="nvcc"
         [1044]          [3659] fi
       [CUDA Arch / Flags] line 1045: 'NVCCFLAGS'
         [1042]          [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [1043]          [3658]     NVCC="nvcc"
         [1044]          [3659] fi
         [1045]          [3660] NVCCFLAGS="-use_fast_math -arch=sm_86  -Xptxas -v -Xcompiler -fopenmp "
         [1046]          [3661]
         [1047]          [3662]
         [1048]          [3663]
       [CUDA Arch / Flags] line 1045: 'arch=sm_86'
         [1042]          [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [1043]          [3658]     NVCC="nvcc"
         [1044]          [3659] fi
         [1045]          [3660] NVCCFLAGS="-use_fast_math -arch=sm_86  -Xptxas -v -Xcompiler -fopenmp "
         [1046]          [3661]
         [1047]          [3662]
         [1048]          [3663]
       [CUDA Arch / Flags] line 1049: 'arch=sm_13'
         [1046]          [3661]
         [1047]          [3662]
         [1048]          [3663]
         [1049]        [CUDA Arch / Flags] line 3660: 'arch=sm_13'
         [1050]          [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [1051]          [3658]     NVCC="nvcc"
         [1052]          [3659] fi
       [CUDA Arch / Flags] line 1053: 'NVCCFLAGS'
         [1050]          [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [1051]          [3658]     NVCC="nvcc"
         [1052]          [3659] fi
         [1053]          [3660] NVCCFLAGS="-use_fast_math -arch=sm_86  -Xptxas -v -Xcompiler -fopenmp "
         [1054]          [3661]
         [1055]          [3662]
         [1056]          [3663]
       [CUDA Arch / Flags] line 1053: 'arch=sm_86'
         [1050]          [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [1051]          [3658]     NVCC="nvcc"
         [1052]          [3659] fi
         [1053]          [3660] NVCCFLAGS="-use_fast_math -arch=sm_86  -Xptxas -v -Xcompiler -fopenmp "
         [1054]          [3661]
         [1055]          [3662]
         [1056]          [3663]
       [CUDA Arch / Flags] line 1057: 'NVCCFLAGS'
         [1054]          [3661]
         [1055]          [3662]
         [1056]          [3663]
         [1057]        [CUDA Arch / Flags] line 5872: 'NVCCFLAGS'
         [1058]          [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [1059]          [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [1060]          [5871] s,@NVCC@,$NVCC,;t t
       [CUDA Arch / Flags] line 1061: 'NVCCFLAGS'
         [1058]          [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [1059]          [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [1060]          [5871] s,@NVCC@,$NVCC,;t t
         [1061]          [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [1062]          [5873] s,@RANLIB@,$RANLIB,;t t
         [1063]          [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [1064]          [5875] s,@CPP@,$CPP,;t t
       [CUDA Arch / Flags] line 1061: 'NVCCFLAGS'
         [1058]          [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [1059]          [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [1060]          [5871] s,@NVCC@,$NVCC,;t t
         [1061]          [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [1062]          [5873] s,@RANLIB@,$RANLIB,;t t
         [1063]          [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [1064]          [5875] s,@CPP@,$CPP,;t t
       [CUDA Arch / Flags] line 1065: 'NVCCFLAGS'
         [1062]          [5873] s,@RANLIB@,$RANLIB,;t t
         [1063]          [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [1064]          [5875] s,@CPP@,$CPP,;t t
         [1065]        [CUDA Arch / Flags] line 5872: 'NVCCFLAGS'
         [1066]          [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [1067]          [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [1068]          [5871] s,@NVCC@,$NVCC,;t t
       [CUDA Arch / Flags] line 1069: 'NVCCFLAGS'
         [1066]          [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [1067]          [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [1068]          [5871] s,@NVCC@,$NVCC,;t t
         [1069]          [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [1070]          [5873] s,@RANLIB@,$RANLIB,;t t
         [1071]          [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [1072]          [5875] s,@CPP@,$CPP,;t t
       [CUDA Arch / Flags] line 1069: 'NVCCFLAGS'
         [1066]          [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [1067]          [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [1068]          [5871] s,@NVCC@,$NVCC,;t t
         [1069]          [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [1070]          [5873] s,@RANLIB@,$RANLIB,;t t
         [1071]          [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [1072]          [5875] s,@CPP@,$CPP,;t t
       [CUDA Arch / Flags] line 1123: 'NVCCFLAGS'
         [1120]          [4504]   typedef int charset[2];
         [1121]   |- traces.4
         [1122]     -> Referências importantes (com snippet):
         [1123]        [CUDA Arch / Flags] line 177: 'NVCCFLAGS'
         [1124]          [ 174] m4trace:configure.ac:117: -1- AC_SUBST([CUDA_CFLAGS])
         [1125]          [ 175] m4trace:configure.ac:118: -1- AC_SUBST([CUDA_LIBS])
         [1126]          [ 176] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
       [CUDA Arch / Flags] line 1127: 'NVCCFLAGS'
         [1124]          [ 174] m4trace:configure.ac:117: -1- AC_SUBST([CUDA_CFLAGS])
         [1125]          [ 175] m4trace:configure.ac:118: -1- AC_SUBST([CUDA_LIBS])
         [1126]          [ 176] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
         [1127]          [ 177] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [1128]          [ 178] m4trace:configure.ac:129: -1- AC_PROG_RANLIB
         [1129]          [ 179] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [1130]          [ 180] m4trace:configure.ac:129: -1- AC_SUBST([ac_ct_RANLIB])
       [CUDA Arch / Flags] line 1133: 'NVCCFLAGS'
         [1130]          [ 180] m4trace:configure.ac:129: -1- AC_SUBST([ac_ct_RANLIB])
         [1131]   |- traces.1
         [1132]     -> Referências importantes (com snippet):
         [1133]        [CUDA Arch / Flags] line 478: 'NVCCFLAGS'
         [1134]          [ 475] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
         [1135]          [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [1136]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
       [CUDA Arch / Flags] line 1137: 'NVCCFLAGS'
         [1134]          [ 475] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
         [1135]          [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [1136]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [1137]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [1138]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [1139]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [1140]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
       [CUDA Arch / Flags] line 1138: 'NVCCFLAGS'
         [1135]          [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [1136]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [1137]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [1138]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [1139]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [1140]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [1141]        [CUDA Arch / Flags] line 479: 'NVCCFLAGS'
       [CUDA Arch / Flags] line 1139: 'NVCCFLAGS'
         [1136]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [1137]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [1138]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [1139]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [1140]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [1141]        [CUDA Arch / Flags] line 479: 'NVCCFLAGS'
         [1142]          [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
       [CUDA Arch / Flags] line 1141: 'NVCCFLAGS'
         [1138]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [1139]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [1140]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [1141]        [CUDA Arch / Flags] line 479: 'NVCCFLAGS'
         [1142]          [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [1143]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [1144]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
       [CUDA Arch / Flags] line 1144: 'NVCCFLAGS'
         [1141]        [CUDA Arch / Flags] line 479: 'NVCCFLAGS'
         [1142]          [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [1143]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [1144]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [1145]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [1146]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [1147]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
       [CUDA Arch / Flags] line 1145: 'NVCCFLAGS'
         [1142]          [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [1143]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [1144]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [1145]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [1146]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [1147]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [1148]          [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
       [CUDA Arch / Flags] line 1146: 'NVCCFLAGS'
         [1143]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [1144]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [1145]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [1146]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [1147]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [1148]          [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
         [1149]        [CUDA Arch / Flags] line 480: 'NVCCFLAGS'
       [CUDA Arch / Flags] line 1149: 'NVCCFLAGS'
         [1146]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [1147]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [1148]          [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
         [1149]        [CUDA Arch / Flags] line 480: 'NVCCFLAGS'
         [1150]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [1151]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [1152]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
       [CUDA Arch / Flags] line 1151: 'NVCCFLAGS'
         [1148]          [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
         [1149]        [CUDA Arch / Flags] line 480: 'NVCCFLAGS'
         [1150]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [1151]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [1152]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [1153]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [1154]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
       [CUDA Arch / Flags] line 1152: 'NVCCFLAGS'
         [1149]        [CUDA Arch / Flags] line 480: 'NVCCFLAGS'
         [1150]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [1151]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [1152]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [1153]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [1154]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [1155]          [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
       [CUDA Arch / Flags] line 1153: 'NVCCFLAGS'
         [1150]          [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [1151]          [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [1152]          [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [1153]          [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [1154]          [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [1155]          [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
         [1156]          [ 483] m4trace:configure.ac:129: -1- m4_pattern_allow([^RANLIB$])
       [CUDA Arch / Flags] line 1330: 'NVCCFLAGS'
         [1327]   |- clustalw_version.h
         [1328]   |- Makefile.in
         [1329]     -> Referências importantes (com snippet):
         [1330]        [CUDA Arch / Flags] line 329: 'NVCCFLAGS'
         [1331]          [ 326] MAKEINFO = @MAKEINFO@
         [1332]          [ 327] MKDIR_P = @MKDIR_P@
         [1333]          [ 328] NVCC = @NVCC@
       [CUDA Arch / Flags] line 1334: 'NVCCFLAGS'
         [1331]          [ 326] MAKEINFO = @MAKEINFO@
         [1332]          [ 327] MKDIR_P = @MKDIR_P@
         [1333]          [ 328] NVCC = @NVCC@
         [1334]          [ 329] NVCCFLAGS = @NVCCFLAGS@
         [1335]          [ 330] OBJEXT = @OBJEXT@
         [1336]          [ 331] PACKAGE = @PACKAGE@
         [1337]          [ 332] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 1334: 'NVCCFLAGS'
         [1331]          [ 326] MAKEINFO = @MAKEINFO@
         [1332]          [ 327] MKDIR_P = @MKDIR_P@
         [1333]          [ 328] NVCC = @NVCC@
         [1334]          [ 329] NVCCFLAGS = @NVCCFLAGS@
         [1335]          [ 330] OBJEXT = @OBJEXT@
         [1336]          [ 331] PACKAGE = @PACKAGE@
         [1337]          [ 332] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 1338: 'NVCCFLAGS'
         [1335]          [ 330] OBJEXT = @OBJEXT@
         [1336]          [ 331] PACKAGE = @PACKAGE@
         [1337]          [ 332] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
         [1338]        [CUDA Arch / Flags] line 329: 'NVCCFLAGS'
         [1339]          [ 326] MAKEINFO = @MAKEINFO@
         [1340]          [ 327] MKDIR_P = @MKDIR_P@
         [1341]          [ 328] NVCC = @NVCC@
       [CUDA Arch / Flags] line 1342: 'NVCCFLAGS'
         [1339]          [ 326] MAKEINFO = @MAKEINFO@
         [1340]          [ 327] MKDIR_P = @MKDIR_P@
         [1341]          [ 328] NVCC = @NVCC@
         [1342]          [ 329] NVCCFLAGS = @NVCCFLAGS@
         [1343]          [ 330] OBJEXT = @OBJEXT@
         [1344]          [ 331] PACKAGE = @PACKAGE@
         [1345]          [ 332] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 1342: 'NVCCFLAGS'
         [1339]          [ 326] MAKEINFO = @MAKEINFO@
         [1340]          [ 327] MKDIR_P = @MKDIR_P@
         [1341]          [ 328] NVCC = @NVCC@
         [1342]          [ 329] NVCCFLAGS = @NVCCFLAGS@
         [1343]          [ 330] OBJEXT = @OBJEXT@
         [1344]          [ 331] PACKAGE = @PACKAGE@
         [1345]          [ 332] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 1346: 'NVCCFLAGS'
         [1343]          [ 330] OBJEXT = @OBJEXT@
         [1344]          [ 331] PACKAGE = @PACKAGE@
         [1345]          [ 332] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
         [1346]        [CUDA Arch / Flags] line 1843: 'NVCCFLAGS'
         [1347]          [1840]
         [1348]          [1841]
         [1349]          [1842] .cu.o:
       [CUDA Arch / Flags] line 1350: 'NVCCFLAGS'
         [1347]          [1840]
         [1348]          [1841]
         [1349]          [1842] .cu.o:
         [1350]          [1843] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1351]          [1844] .o:
         [1352]          [1845] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1353]          [1846]
       [CUDA Arch / Flags] line 1352: 'NVCCFLAGS'
         [1349]          [1842] .cu.o:
         [1350]          [1843] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1351]          [1844] .o:
         [1352]          [1845] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1353]          [1846]
         [1354]        [CUDA Arch / Flags] line 1845: 'NVCCFLAGS'
         [1355]          [1842] .cu.o:
       [CUDA Arch / Flags] line 1354: 'NVCCFLAGS'
         [1351]          [1844] .o:
         [1352]          [1845] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1353]          [1846]
         [1354]        [CUDA Arch / Flags] line 1845: 'NVCCFLAGS'
         [1355]          [1842] .cu.o:
         [1356]          [1843] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1357]          [1844] .o:
       [CUDA Arch / Flags] line 1356: 'NVCCFLAGS'
         [1353]          [1846]
         [1354]        [CUDA Arch / Flags] line 1845: 'NVCCFLAGS'
         [1355]          [1842] .cu.o:
         [1356]          [1843] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1357]          [1844] .o:
         [1358]          [1845] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1359]          [1846]
       [CUDA Arch / Flags] line 1358: 'NVCCFLAGS'
         [1355]          [1842] .cu.o:
         [1356]          [1843] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1357]          [1844] .o:
         [1358]          [1845] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1359]          [1846]
         [1360]          [1847] # Tell versions [3.59,3.63) of GNU make to not export all variables.
         [1361]          [1848] # Otherwise a system limit (for SysV at least) may be exceeded.
       [CUDA Arch / Flags] line 1364: 'NVCCFLAGS'
         [1361]          [1848] # Otherwise a system limit (for SysV at least) may be exceeded.
         [1362]   |- Makefile
         [1363]     -> Referências importantes (com snippet):
         [1364]        [CUDA Arch / Flags] line 329: 'NVCCFLAGS'
         [1365]          [ 326] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [1366]          [ 327] MKDIR_P = /usr/bin/mkdir -p
         [1367]          [ 328] NVCC = nvcc
       [CUDA Arch / Flags] line 1368: 'NVCCFLAGS'
         [1365]          [ 326] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [1366]          [ 327] MKDIR_P = /usr/bin/mkdir -p
         [1367]          [ 328] NVCC = nvcc
         [1368]          [ 329] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [1369]          [ 330] OBJEXT = o
         [1370]          [ 331] PACKAGE = clustalw
         [1371]          [ 332] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 1368: 'arch=sm_86'
         [1365]          [ 326] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [1366]          [ 327] MKDIR_P = /usr/bin/mkdir -p
         [1367]          [ 328] NVCC = nvcc
         [1368]          [ 329] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [1369]          [ 330] OBJEXT = o
         [1370]          [ 331] PACKAGE = clustalw
         [1371]          [ 332] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 1372: 'arch=sm_86'
         [1369]          [ 330] OBJEXT = o
         [1370]          [ 331] PACKAGE = clustalw
         [1371]          [ 332] PACKAGE_BUGREPORT = clustalw@ucd.ie
         [1372]        [CUDA Arch / Flags] line 329: 'arch=sm_86'
         [1373]          [ 326] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [1374]          [ 327] MKDIR_P = /usr/bin/mkdir -p
         [1375]          [ 328] NVCC = nvcc
       [CUDA Arch / Flags] line 1376: 'NVCCFLAGS'
         [1373]          [ 326] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [1374]          [ 327] MKDIR_P = /usr/bin/mkdir -p
         [1375]          [ 328] NVCC = nvcc
         [1376]          [ 329] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [1377]          [ 330] OBJEXT = o
         [1378]          [ 331] PACKAGE = clustalw
         [1379]          [ 332] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 1376: 'arch=sm_86'
         [1373]          [ 326] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [1374]          [ 327] MKDIR_P = /usr/bin/mkdir -p
         [1375]          [ 328] NVCC = nvcc
         [1376]          [ 329] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [1377]          [ 330] OBJEXT = o
         [1378]          [ 331] PACKAGE = clustalw
         [1379]          [ 332] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 1380: 'NVCCFLAGS'
         [1377]          [ 330] OBJEXT = o
         [1378]          [ 331] PACKAGE = clustalw
         [1379]          [ 332] PACKAGE_BUGREPORT = clustalw@ucd.ie
         [1380]        [CUDA Arch / Flags] line 1843: 'NVCCFLAGS'
         [1381]          [1840]
         [1382]          [1841]
         [1383]          [1842] .cu.o:
       [CUDA Arch / Flags] line 1384: 'NVCCFLAGS'
         [1381]          [1840]
         [1382]          [1841]
         [1383]          [1842] .cu.o:
         [1384]          [1843] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1385]          [1844] .o:
         [1386]          [1845] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1387]          [1846]
       [CUDA Arch / Flags] line 1386: 'NVCCFLAGS'
         [1383]          [1842] .cu.o:
         [1384]          [1843] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1385]          [1844] .o:
         [1386]          [1845] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1387]          [1846]
         [1388]        [CUDA Arch / Flags] line 1845: 'NVCCFLAGS'
         [1389]          [1842] .cu.o:
       [CUDA Arch / Flags] line 1388: 'NVCCFLAGS'
         [1385]          [1844] .o:
         [1386]          [1845] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1387]          [1846]
         [1388]        [CUDA Arch / Flags] line 1845: 'NVCCFLAGS'
         [1389]          [1842] .cu.o:
         [1390]          [1843] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1391]          [1844] .o:
       [CUDA Arch / Flags] line 1390: 'NVCCFLAGS'
         [1387]          [1846]
         [1388]        [CUDA Arch / Flags] line 1845: 'NVCCFLAGS'
         [1389]          [1842] .cu.o:
         [1390]          [1843] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1391]          [1844] .o:
         [1392]          [1845] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1393]          [1846]
       [CUDA Arch / Flags] line 1392: 'NVCCFLAGS'
         [1389]          [1842] .cu.o:
         [1390]          [1843] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1391]          [1844] .o:
         [1392]          [1845] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1393]          [1846]
         [1394]          [1847] # Tell versions [3.59,3.63) of GNU make to not export all variables.
         [1395]          [1848] # Otherwise a system limit (for SysV at least) may be exceeded.
       [CUDA Arch / Flags] line 1504: 'NVCCFLAGS'
         [1501]   |- stamp-h1
         [1502]   |- Makefile.am
         [1503]     -> Referências importantes (com snippet):
         [1504]        [CUDA Arch / Flags] line 22: 'NVCCFLAGS'
         [1505]          [  19] bin_PROGRAMS = clustalw2
         [1506]          [  20]
         [1507]          [  21] .cu.o:
       [CUDA Arch / Flags] line 1508: 'NVCCFLAGS'
         [1505]          [  19] bin_PROGRAMS = clustalw2
         [1506]          [  20]
         [1507]          [  21] .cu.o:
         [1508]          [  22] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1509]          [  23] .o:
         [1510]          [  24] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1511]          [  25]
       [CUDA Arch / Flags] line 1510: 'NVCCFLAGS'
         [1507]          [  21] .cu.o:
         [1508]          [  22] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1509]          [  23] .o:
         [1510]          [  24] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1511]          [  25]
         [1512]        [CUDA Arch / Flags] line 24: 'NVCCFLAGS'
         [1513]          [  21] .cu.o:
       [CUDA Arch / Flags] line 1512: 'NVCCFLAGS'
         [1509]          [  23] .o:
         [1510]          [  24] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1511]          [  25]
         [1512]        [CUDA Arch / Flags] line 24: 'NVCCFLAGS'
         [1513]          [  21] .cu.o:
         [1514]          [  22] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1515]          [  23] .o:
       [CUDA Arch / Flags] line 1514: 'NVCCFLAGS'
         [1511]          [  25]
         [1512]        [CUDA Arch / Flags] line 24: 'NVCCFLAGS'
         [1513]          [  21] .cu.o:
         [1514]          [  22] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1515]          [  23] .o:
         [1516]          [  24] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1517]          [  25]
       [CUDA Arch / Flags] line 1516: 'NVCCFLAGS'
         [1513]          [  21] .cu.o:
         [1514]          [  22] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ -c $< $(NVCCFLAGS)
         [1515]          [  23] .o:
         [1516]          [  24] 	$(NVCC) -DHAVE_CONFIG_H -I. -I../ -o $@ $< $(NVCCFLAGS)
         [1517]          [  25]
         [1518]          [  26]
         [1519]          [  27]
       [CUDA Arch / Flags] line 2473: 'sm_86'
         [2470]          [ 900]
         [2471]   |- Stack.o
         [2472]     -> Referências importantes (com snippet):
         [2473]        [CUDA Arch / Flags] line 11: 'sm_86'
         [2474]          [   8]
         [2475]          [   9]    CbF                            GCC: (Ubuntu 12.3.0-17ubuntu1) 12.3.0           GNU                    zR x                EC
         [2476]          [  10] Q      <           EC
       [CUDA Arch / Flags] line 5876: 'arch=sm_86'
         [5873]           void printVectorToFile(vector<short>& temp, char* name = "tempfile.out");
         [5874]                                                                    ^
         [5875] 
         [5876] cuda/cudaFullPairwiseAlign.cu(24): error: texture is not a template
         [5877]   texture<int, 1, cudaReadModeElementType> texMatrix;
         [5878]   ^
         [5879] 
       [API CUDA Obsoleta] line 39: 'cudaThreadSynchronize'
         [  36]          [   8]
         [  37]          [   9] - Mapeia diretórios, assinaturas de função
         [  38]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  39]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  40]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  41]          [  13] - Separa warnings e errors do 'make' e agrupa
         [  42]        [CUDA Arch / Flags] line 10: 'sm_86'
       [API CUDA Obsoleta] line 47: 'cudaThreadSynchronize'
         [  44]          [   8]
         [  45]          [   9] - Mapeia diretórios, assinaturas de função
         [  46]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  47]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  48]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  49]          [  13] - Separa warnings e errors do 'make' e agrupa
         [  50]        [CUDA Arch / Flags] line 10: 'NVCCFLAGS'
       [API CUDA Obsoleta] line 55: 'cudaThreadSynchronize'
         [  52]          [   8]
         [  53]          [   9] - Mapeia diretórios, assinaturas de função
         [  54]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  55]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  56]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  57]          [  13] - Separa warnings e errors do 'make' e agrupa
         [  58]        [CUDA Arch / Flags] line 51: 'gencode'
       [API CUDA Obsoleta] line 130: 'cudaThreadSynchronize'
         [ 127]          [ 335]         "3) Estatísticas ao final\n"
         [ 128]          [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 129]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
         [ 130]        [API CUDA Obsoleta] line 11: 'cudaThreadSynchronize'
         [ 131]          [   8]
         [ 132]          [   9] - Mapeia diretórios, assinaturas de função
         [ 133]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
       [API CUDA Obsoleta] line 134: 'cudaThreadSynchronize'
         [ 131]          [   8]
         [ 132]          [   9] - Mapeia diretórios, assinaturas de função
         [ 133]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 134]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 135]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 136]          [  13] - Separa warnings e errors do 'make' e agrupa
         [ 137]          [  14] - Gera contagem estatística de cada tipo de referência
       [API CUDA Obsoleta] line 138: 'cudaThreadSynchronize'
         [ 135]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 136]          [  13] - Separa warnings e errors do 'make' e agrupa
         [ 137]          [  14] - Gera contagem estatística de cada tipo de referência
         [ 138]        [API CUDA Obsoleta] line 56: 'cudaThreadSynchronize'
         [ 139]          [  53]
         [ 140]          [  54] # Listas de strings para buscas literais
         [ 141]          [  55] CUDA_OBSOLETE_APIS = [
       [API CUDA Obsoleta] line 142: 'cudaThreadSynchronize'
         [ 139]          [  53]
         [ 140]          [  54] # Listas de strings para buscas literais
         [ 141]          [  55] CUDA_OBSOLETE_APIS = [
         [ 142]          [  56]     r"cudaThreadSynchronize",
         [ 143]          [  57]     r"cudaThreadExit",
         [ 144]          [  58]     r"__syncthreadsCount",
         [ 145]          [  59]     r"cutil\.h",
       [API CUDA Obsoleta] line 149: 'cudaThreadSynchronize'
         [ 146]        [API CUDA Obsoleta] line 57: 'cudaThreadExit'
         [ 147]          [  54] # Listas de strings para buscas literais
         [ 148]          [  55] CUDA_OBSOLETE_APIS = [
         [ 149]          [  56]     r"cudaThreadSynchronize",
         [ 150]          [  57]     r"cudaThreadExit",
         [ 151]          [  58]     r"__syncthreadsCount",
         [ 152]          [  59]     r"cutil\.h",
       [API CUDA Obsoleta] line 156: 'cudaThreadSynchronize'
         [ 153]          [  60]     r"helper_cuda\.h",
         [ 154]        [API CUDA Obsoleta] line 58: '__syncthreadsCount'
         [ 155]          [  55] CUDA_OBSOLETE_APIS = [
         [ 156]          [  56]     r"cudaThreadSynchronize",
         [ 157]          [  57]     r"cudaThreadExit",
         [ 158]          [  58]     r"__syncthreadsCount",
         [ 159]          [  59]     r"cutil\.h",
       [API CUDA Obsoleta] line 173: 'cudaThreadSynchronize'
         [ 170]        [Marcador de problema] line 12: 'TODO'
         [ 171]          [   9] - Mapeia diretórios, assinaturas de função
         [ 172]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 173]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 174]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 175]          [  13] - Separa warnings e errors do 'make' e agrupa
         [ 176]          [  14] - Gera contagem estatística de cada tipo de referência
       [API CUDA Obsoleta] line 197: 'cudaThreadSynchronize'
         [ 194]        [Marcador de problema] line 12: 'FIXME'
         [ 195]          [   9] - Mapeia diretórios, assinaturas de função
         [ 196]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 197]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 198]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 199]          [  13] - Separa warnings e errors do 'make' e agrupa
         [ 200]          [  14] - Gera contagem estatística de cada tipo de referência
       [API CUDA Obsoleta] line 2447: 'cudaThreadSynchronize'
         [2444] 
         [2445]     cout << cudaGetErrorString(cudaGetLastError()
         [2446]     -> Referências importantes (com snippet):
         [2447]        [API CUDA Obsoleta] line 1039: 'cudaThreadSynchronize'
         [2448]          [1036]     }
         [2449]          [1037]
         [2450]          [1038]
       [API CUDA Obsoleta] line 2451: 'cudaThreadSynchronize'
         [2448]          [1036]     }
         [2449]          [1037]
         [2450]          [1038]
         [2451]          [1039]     cudaThreadSynchronize();
         [2452]          [1040]     cudaUnbindTexture(texMatrix);
         [2453]          [1041]     cudaFree(gElement);
         [2454]          [1042]     cudaFree(gDistMatrix);
       [API CUDA Obsoleta] line 143: 'cudaThreadExit'
         [ 140]          [  54] # Listas de strings para buscas literais
         [ 141]          [  55] CUDA_OBSOLETE_APIS = [
         [ 142]          [  56]     r"cudaThreadSynchronize",
         [ 143]          [  57]     r"cudaThreadExit",
         [ 144]          [  58]     r"__syncthreadsCount",
         [ 145]          [  59]     r"cutil\.h",
         [ 146]        [API CUDA Obsoleta] line 57: 'cudaThreadExit'
       [API CUDA Obsoleta] line 146: 'cudaThreadExit'
         [ 143]          [  57]     r"cudaThreadExit",
         [ 144]          [  58]     r"__syncthreadsCount",
         [ 145]          [  59]     r"cutil\.h",
         [ 146]        [API CUDA Obsoleta] line 57: 'cudaThreadExit'
         [ 147]          [  54] # Listas de strings para buscas literais
         [ 148]          [  55] CUDA_OBSOLETE_APIS = [
         [ 149]          [  56]     r"cudaThreadSynchronize",
       [API CUDA Obsoleta] line 150: 'cudaThreadExit'
         [ 147]          [  54] # Listas de strings para buscas literais
         [ 148]          [  55] CUDA_OBSOLETE_APIS = [
         [ 149]          [  56]     r"cudaThreadSynchronize",
         [ 150]          [  57]     r"cudaThreadExit",
         [ 151]          [  58]     r"__syncthreadsCount",
         [ 152]          [  59]     r"cutil\.h",
         [ 153]          [  60]     r"helper_cuda\.h",
       [API CUDA Obsoleta] line 157: 'cudaThreadExit'
         [ 154]        [API CUDA Obsoleta] line 58: '__syncthreadsCount'
         [ 155]          [  55] CUDA_OBSOLETE_APIS = [
         [ 156]          [  56]     r"cudaThreadSynchronize",
         [ 157]          [  57]     r"cudaThreadExit",
         [ 158]          [  58]     r"__syncthreadsCount",
         [ 159]          [  59]     r"cutil\.h",
         [ 160]          [  60]     r"helper_cuda\.h",
       [API CUDA Obsoleta] line 144: '__syncthreadsCount'
         [ 141]          [  55] CUDA_OBSOLETE_APIS = [
         [ 142]          [  56]     r"cudaThreadSynchronize",
         [ 143]          [  57]     r"cudaThreadExit",
         [ 144]          [  58]     r"__syncthreadsCount",
         [ 145]          [  59]     r"cutil\.h",
         [ 146]        [API CUDA Obsoleta] line 57: 'cudaThreadExit'
         [ 147]          [  54] # Listas de strings para buscas literais
       [API CUDA Obsoleta] line 151: '__syncthreadsCount'
         [ 148]          [  55] CUDA_OBSOLETE_APIS = [
         [ 149]          [  56]     r"cudaThreadSynchronize",
         [ 150]          [  57]     r"cudaThreadExit",
         [ 151]          [  58]     r"__syncthreadsCount",
         [ 152]          [  59]     r"cutil\.h",
         [ 153]          [  60]     r"helper_cuda\.h",
         [ 154]        [API CUDA Obsoleta] line 58: '__syncthreadsCount'
       [API CUDA Obsoleta] line 154: '__syncthreadsCount'
         [ 151]          [  58]     r"__syncthreadsCount",
         [ 152]          [  59]     r"cutil\.h",
         [ 153]          [  60]     r"helper_cuda\.h",
         [ 154]        [API CUDA Obsoleta] line 58: '__syncthreadsCount'
         [ 155]          [  55] CUDA_OBSOLETE_APIS = [
         [ 156]          [  56]     r"cudaThreadSynchronize",
         [ 157]          [  57]     r"cudaThreadExit",
       [API CUDA Obsoleta] line 158: '__syncthreadsCount'
         [ 155]          [  55] CUDA_OBSOLETE_APIS = [
         [ 156]          [  56]     r"cudaThreadSynchronize",
         [ 157]          [  57]     r"cudaThreadExit",
         [ 158]          [  58]     r"__syncthreadsCount",
         [ 159]          [  59]     r"cutil\.h",
         [ 160]          [  60]     r"helper_cuda\.h",
         [ 161]          [  61]     r"texture\<",
       [API CUDA Obsoleta] line 2455: 'texture<'
         [2452]          [1040]     cudaUnbindTexture(texMatrix);
         [2453]          [1041]     cudaFree(gElement);
         [2454]          [1042]     cudaFree(gDistMatrix);
         [2455]        [API CUDA Obsoleta] line 24: 'texture<'
         [2456]          [  21]
         [2457]          [  22]
         [2458]          [  23] #define Matrix(k) tex1Dfetch(texMatrix, k)
       [API CUDA Obsoleta] line 2459: 'texture<'
         [2456]          [  21]
         [2457]          [  22]
         [2458]          [  23] #define Matrix(k) tex1Dfetch(texMatrix, k)
         [2459]          [  24] texture<int, 1, cudaReadModeElementType> texMatrix;
         [2460]          [  25]
         [2461]          [  26] __device__ __constant__ pairwiseAlignInfoStruct gpair;
         [2462]          [  27] using namespace std;
       [API CUDA Obsoleta] line 5891: 'texture<'
         [5888]   static __attribute__((device)) typename __nv_itex_trait<T>::type tex1Dfetch(T *ptr, cudaTextureObject_t obj, int x)
         [5889]                                                                    ^
         [5890] 
         [5891] cuda/cudaFullPairwiseAlign.cu(897): error: identifier "cudaBindTexture" is undefined
         [5892]       cudaBindTexture(0, texMatrix, gMatrix, NUMRES*NUMRES*sizeof(int));
         [5893]       ^
         [5894] 
       [API CUDA Obsoleta] line 162: 'BindTexture'
         [ 159]          [  59]     r"cutil\.h",
         [ 160]          [  60]     r"helper_cuda\.h",
         [ 161]          [  61]     r"texture\<",
         [ 162]        [API CUDA Obsoleta] line 62: 'BindTexture'
         [ 163]          [  59]     r"cutil\.h",
         [ 164]          [  60]     r"helper_cuda\.h",
         [ 165]          [  61]     r"texture\<",
       [API CUDA Obsoleta] line 166: 'BindTexture'
         [ 163]          [  59]     r"cutil\.h",
         [ 164]          [  60]     r"helper_cuda\.h",
         [ 165]          [  61]     r"texture\<",
         [ 166]          [  62]     r"BindTexture",
         [ 167]          [  63] ]
         [ 168]          [  64]
         [ 169]          [  65] PROBLEM_MARKERS = [
       [API CUDA Obsoleta] line 2463: 'BindTexture'
         [2460]          [  25]
         [2461]          [  26] __device__ __constant__ pairwiseAlignInfoStruct gpair;
         [2462]          [  27] using namespace std;
         [2463]        [API CUDA Obsoleta] line 897: 'BindTexture'
         [2464]          [ 894]     cudaMalloc((void**)&gMatrix, sizeof(int)*NUMRES*NUMRES );
         [2465]          [ 895]     for(int i = 0 ; i < 32 ; i += 32)
         [2466]          [ 896]         cudaMemcpy(&gMatrix[i], &matrix[i], sizeof(int)*NUMRES*NUMRES, cudaMemcpyHostToDevice);
       [API CUDA Obsoleta] line 2467: 'BindTexture'
         [2464]          [ 894]     cudaMalloc((void**)&gMatrix, sizeof(int)*NUMRES*NUMRES );
         [2465]          [ 895]     for(int i = 0 ; i < 32 ; i += 32)
         [2466]          [ 896]         cudaMemcpy(&gMatrix[i], &matrix[i], sizeof(int)*NUMRES*NUMRES, cudaMemcpyHostToDevice);
         [2467]          [ 897]     cudaBindTexture(0, texMatrix, gMatrix, NUMRES*NUMRES*sizeof(int));
         [2468]          [ 898]
         [2469]          [ 899]
         [2470]          [ 900]
       [API CUDA Obsoleta] line 5905: 'BindTexture'
         [5902] make[1]: *** [Makefile:540: all] Error 2
         [5903] make: *** [Makefile:371: all-recursive] Error 1
         [5904] 
         [5905] === Warnings Coletados ===
         [5906] 
         [5907] (nenhum warning encontrado)
         [5908] 
       [API CUDA Obsoleta] line 5906: 'BindTexture'
         [5903] make: *** [Makefile:371: all-recursive] Error 1
         [5904] 
         [5905] === Warnings Coletados ===
         [5906] 
         [5907] (nenhum warning encontrado)
         [5908] 
         [5909] === Errors Coletados ===
       [API CUDA Obsoleta] line 5927: 'BindTexture'
       [Marcador de problema] line 7: 'TODO'
         [   4] 
         [   5] Inclui:
         [   6] 1) Árvore de diretórios, assinaturas de função
         [   7] 2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.
         [   8] 3) Estatísticas ao final
         [   9] 4) Execução do 'make', com parse de warnings e errors
         [  10] 5) Enfim, informações detalhadas para migração/debug.
       [Marcador de problema] line 40: 'TODO'
         [  37]          [   9] - Mapeia diretórios, assinaturas de função
         [  38]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  39]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  40]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  41]          [  13] - Separa warnings e errors do 'make' e agrupa
         [  42]        [CUDA Arch / Flags] line 10: 'sm_86'
         [  43]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
       [Marcador de problema] line 48: 'TODO'
         [  45]          [   9] - Mapeia diretórios, assinaturas de função
         [  46]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  47]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  48]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  49]          [  13] - Separa warnings e errors do 'make' e agrupa
         [  50]        [CUDA Arch / Flags] line 10: 'NVCCFLAGS'
         [  51]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
       [Marcador de problema] line 56: 'TODO'
         [  53]          [   9] - Mapeia diretórios, assinaturas de função
         [  54]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  55]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  56]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  57]          [  13] - Separa warnings e errors do 'make' e agrupa
         [  58]        [CUDA Arch / Flags] line 51: 'gencode'
         [  59]          [  48]
       [Marcador de problema] line 118: 'TODO'
         [ 115]          [ 331]         "============================================================\n\n"
         [ 116]          [ 332]         "Inclui:\n"
         [ 117]          [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 118]          [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 119]          [ 335]         "3) Estatísticas ao final\n"
         [ 120]          [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 121]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [Marcador de problema] line 126: 'TODO'
         [ 123]          [ 331]         "============================================================\n\n"
         [ 124]          [ 332]         "Inclui:\n"
         [ 125]          [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 126]          [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 127]          [ 335]         "3) Estatísticas ao final\n"
         [ 128]          [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 129]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [Marcador de problema] line 135: 'TODO'
         [ 132]          [   9] - Mapeia diretórios, assinaturas de função
         [ 133]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 134]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 135]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 136]          [  13] - Separa warnings e errors do 'make' e agrupa
         [ 137]          [  14] - Gera contagem estatística de cada tipo de referência
         [ 138]        [API CUDA Obsoleta] line 56: 'cudaThreadSynchronize'
       [Marcador de problema] line 170: 'TODO'
         [ 167]          [  63] ]
         [ 168]          [  64]
         [ 169]          [  65] PROBLEM_MARKERS = [
         [ 170]        [Marcador de problema] line 12: 'TODO'
         [ 171]          [   9] - Mapeia diretórios, assinaturas de função
         [ 172]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 173]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
       [Marcador de problema] line 174: 'TODO'
         [ 171]          [   9] - Mapeia diretórios, assinaturas de função
         [ 172]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 173]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 174]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 175]          [  13] - Separa warnings e errors do 'make' e agrupa
         [ 176]          [  14] - Gera contagem estatística de cada tipo de referência
         [ 177]          [  15]
       [Marcador de problema] line 178: 'TODO'
         [ 175]          [  13] - Separa warnings e errors do 'make' e agrupa
         [ 176]          [  14] - Gera contagem estatística de cada tipo de referência
         [ 177]          [  15]
         [ 178]        [Marcador de problema] line 66: 'TODO'
         [ 179]          [  63] ]
         [ 180]          [  64]
         [ 181]          [  65] PROBLEM_MARKERS = [
       [Marcador de problema] line 182: 'TODO'
         [ 179]          [  63] ]
         [ 180]          [  64]
         [ 181]          [  65] PROBLEM_MARKERS = [
         [ 182]          [  66]     r"TODO",
         [ 183]          [  67]     r"FIXME",
         [ 184]          [  68]     r"DEPRECATED",
         [ 185]          [  69]     r"AW:",
       [Marcador de problema] line 186: 'TODO'
         [ 183]          [  67]     r"FIXME",
         [ 184]          [  68]     r"DEPRECATED",
         [ 185]          [  69]     r"AW:",
         [ 186]        [Marcador de problema] line 334: 'TODO'
         [ 187]          [ 331]         "============================================================\n\n"
         [ 188]          [ 332]         "Inclui:\n"
         [ 189]          [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
       [Marcador de problema] line 190: 'TODO'
         [ 187]          [ 331]         "============================================================\n\n"
         [ 188]          [ 332]         "Inclui:\n"
         [ 189]          [ 333]         "1) Árvore de diretórios, assinaturas de função\n"
         [ 190]          [ 334]         "2) Snippets para menções a sm_13, sm_86, APIs obsoletas, TODO, etc.\n"
         [ 191]          [ 335]         "3) Estatísticas ao final\n"
         [ 192]          [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 193]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
       [Marcador de problema] line 198: 'TODO'
         [ 195]          [   9] - Mapeia diretórios, assinaturas de função
         [ 196]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 197]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 198]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 199]          [  13] - Separa warnings e errors do 'make' e agrupa
         [ 200]          [  14] - Gera contagem estatística de cada tipo de referência
         [ 201]          [  15]
       [Marcador de problema] line 205: 'TODO'
         [ 202]        [Marcador de problema] line 67: 'FIXME'
         [ 203]          [  64]
         [ 204]          [  65] PROBLEM_MARKERS = [
         [ 205]          [  66]     r"TODO",
         [ 206]          [  67]     r"FIXME",
         [ 207]          [  68]     r"DEPRECATED",
         [ 208]          [  69]     r"AW:",
       [Marcador de problema] line 212: 'TODO'
         [ 209]          [  70]     r"eight[ -_]years",
         [ 210]        [Marcador de problema] line 68: 'DEPRECATED'
         [ 211]          [  65] PROBLEM_MARKERS = [
         [ 212]          [  66]     r"TODO",
         [ 213]          [  67]     r"FIXME",
         [ 214]          [  68]     r"DEPRECATED",
         [ 215]          [  69]     r"AW:",
       [Marcador de problema] line 219: 'TODO'
         [ 216]          [  70]     r"eight[ -_]years",
         [ 217]          [  71] ]
         [ 218]        [Marcador de problema] line 69: 'AW:'
         [ 219]          [  66]     r"TODO",
         [ 220]          [  67]     r"FIXME",
         [ 221]          [  68]     r"DEPRECATED",
         [ 222]          [  69]     r"AW:",
       [Marcador de problema] line 362: 'TODO'
         [ 359]          [5465]
         [ 360]          [5466]
         [ 361]          [5467]
         [ 362]        [Marcador de problema] line 7486: 'TODO'
         [ 363]          [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 364]          [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [ 365]          [7485]   # if we detect the quoting.
       [Marcador de problema] line 366: 'TODO'
         [ 363]          [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 364]          [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [ 365]          [7485]   # if we detect the quoting.
         [ 366]          [7486]   # TODO: see whether this extra hack can be removed once we start
         [ 367]          [7487]   # requiring Autoconf 2.70 or later.
         [ 368]          [7488]   case $CONFIG_FILES in #(
         [ 369]          [7489]   *\'*) :
       [Marcador de problema] line 537: 'TODO'
         [ 534]          [ 621] S["NVCC"]="nvcc"
         [ 535]          [ 622] S["CUDA_LIBS"]="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 536]          [ 623] S["CUDA_CFLAGS"]="-I/usr/local/cuda/include"
         [ 537]        [Marcador de problema] line 1124: 'TODO'
         [ 538]          [1121]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 539]          [1122]   # are listed without --file.  Let's play safe and only enable the eval
         [ 540]          [1123]   # if we detect the quoting.
       [Marcador de problema] line 541: 'TODO'
         [ 538]          [1121]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 539]          [1122]   # are listed without --file.  Let's play safe and only enable the eval
         [ 540]          [1123]   # if we detect the quoting.
         [ 541]          [1124]   # TODO: see whether this extra hack can be removed once we start
         [ 542]          [1125]   # requiring Autoconf 2.70 or later.
         [ 543]          [1126]   case $CONFIG_FILES in #(
         [ 544]          [1127]   *\'*) :
       [Marcador de problema] line 573: 'TODO'
         [ 570]          [ 569] PACKAGE_BUGREPORT='clustalw@ucd.ie'
         [ 571]   |- aclocal.m4
         [ 572]     -> Referências importantes (com snippet):
         [ 573]        [Marcador de problema] line 348: 'TODO'
         [ 574]          [ 345]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 575]          [ 346]   # are listed without --file.  Let's play safe and only enable the eval
         [ 576]          [ 347]   # if we detect the quoting.
       [Marcador de problema] line 577: 'TODO'
         [ 574]          [ 345]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 575]          [ 346]   # are listed without --file.  Let's play safe and only enable the eval
         [ 576]          [ 347]   # if we detect the quoting.
         [ 577]          [ 348]   # TODO: see whether this extra hack can be removed once we start
         [ 578]          [ 349]   # requiring Autoconf 2.70 or later.
         [ 579]          [ 350]   AS_CASE([$CONFIG_FILES],
         [ 580]          [ 351]           [*\'*], [eval set x "$CONFIG_FILES"],
       [Marcador de problema] line 656: 'TODO'
         [ 653]          [5465]
         [ 654]          [5466]
         [ 655]          [5467]
         [ 656]        [Marcador de problema] line 7486: 'TODO'
         [ 657]          [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 658]          [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [ 659]          [7485]   # if we detect the quoting.
       [Marcador de problema] line 660: 'TODO'
         [ 657]          [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 658]          [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [ 659]          [7485]   # if we detect the quoting.
         [ 660]          [7486]   # TODO: see whether this extra hack can be removed once we start
         [ 661]          [7487]   # requiring Autoconf 2.70 or later.
         [ 662]          [7488]   case $CONFIG_FILES in @%:@(
         [ 663]          [7489]   *\'*) :
       [Marcador de problema] line 722: 'TODO'
         [ 719]          [ 993] m4trace:configure.ac:129: -1- m4_pattern_allow([^RANLIB$])
         [ 720]          [ 994] m4trace:configure.ac:136: -1- _m4_warn([obsolete], [The macro `AC_HEADER_STDC' is obsolete.
         [ 721]          [ 995] You should run autoupdate.], [./lib/autoconf/headers.m4:704: AC_HEADER_STDC is expanded from...
         [ 722]        [Marcador de problema] line 190: 'TODO'
         [ 723]          [ 187]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 724]          [ 188]   # are listed without --file.  Let's play safe and only enable the eval
         [ 725]          [ 189]   # if we detect the quoting.
       [Marcador de problema] line 726: 'TODO'
         [ 723]          [ 187]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 724]          [ 188]   # are listed without --file.  Let's play safe and only enable the eval
         [ 725]          [ 189]   # if we detect the quoting.
         [ 726]          [ 190]   # TODO: see whether this extra hack can be removed once we start
         [ 727]          [ 191]   # requiring Autoconf 2.70 or later.
         [ 728]          [ 192]   AS_CASE([$CONFIG_FILES],
         [ 729]          [ 193]           [*\'*], [eval set x "$CONFIG_FILES"],
       [Marcador de problema] line 791: 'TODO'
         [ 788]          [5465]
         [ 789]          [5466]
         [ 790]          [5467]
         [ 791]        [Marcador de problema] line 7486: 'TODO'
         [ 792]          [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 793]          [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [ 794]          [7485]   # if we detect the quoting.
       [Marcador de problema] line 795: 'TODO'
         [ 792]          [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 793]          [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [ 794]          [7485]   # if we detect the quoting.
         [ 795]          [7486]   # TODO: see whether this extra hack can be removed once we start
         [ 796]          [7487]   # requiring Autoconf 2.70 or later.
         [ 797]          [7488]   case $CONFIG_FILES in @%:@(
         [ 798]          [7489]   *\'*) :
       [Marcador de problema] line 975: 'TODO'
         [ 972]          [5465]
         [ 973]          [5466]
         [ 974]          [5467]
         [ 975]        [Marcador de problema] line 7486: 'TODO'
         [ 976]          [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 977]          [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [ 978]          [7485]   # if we detect the quoting.
       [Marcador de problema] line 979: 'TODO'
         [ 976]          [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 977]          [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [ 978]          [7485]   # if we detect the quoting.
         [ 979]          [7486]   # TODO: see whether this extra hack can be removed once we start
         [ 980]          [7487]   # requiring Autoconf 2.70 or later.
         [ 981]          [7488]   case $CONFIG_FILES in @%:@(
         [ 982]          [7489]   *\'*) :
       [Marcador de problema] line 40: 'FIXME'
         [  37]          [   9] - Mapeia diretórios, assinaturas de função
         [  38]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  39]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  40]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  41]          [  13] - Separa warnings e errors do 'make' e agrupa
         [  42]        [CUDA Arch / Flags] line 10: 'sm_86'
         [  43]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
       [Marcador de problema] line 48: 'FIXME'
         [  45]          [   9] - Mapeia diretórios, assinaturas de função
         [  46]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  47]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  48]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  49]          [  13] - Separa warnings e errors do 'make' e agrupa
         [  50]        [CUDA Arch / Flags] line 10: 'NVCCFLAGS'
         [  51]          [   7] Gera um relatório ultra-completo do projeto CUDA-clustalW:
       [Marcador de problema] line 56: 'FIXME'
         [  53]          [   9] - Mapeia diretórios, assinaturas de função
         [  54]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [  55]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [  56]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [  57]          [  13] - Separa warnings e errors do 'make' e agrupa
         [  58]        [CUDA Arch / Flags] line 51: 'gencode'
         [  59]          [  48]
       [Marcador de problema] line 135: 'FIXME'
         [ 132]          [   9] - Mapeia diretórios, assinaturas de função
         [ 133]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 134]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 135]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 136]          [  13] - Separa warnings e errors do 'make' e agrupa
         [ 137]          [  14] - Gera contagem estatística de cada tipo de referência
         [ 138]        [API CUDA Obsoleta] line 56: 'cudaThreadSynchronize'
       [Marcador de problema] line 174: 'FIXME'
         [ 171]          [   9] - Mapeia diretórios, assinaturas de função
         [ 172]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 173]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 174]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 175]          [  13] - Separa warnings e errors do 'make' e agrupa
         [ 176]          [  14] - Gera contagem estatística de cada tipo de referência
         [ 177]          [  15]
       [Marcador de problema] line 183: 'FIXME'
         [ 180]          [  64]
         [ 181]          [  65] PROBLEM_MARKERS = [
         [ 182]          [  66]     r"TODO",
         [ 183]          [  67]     r"FIXME",
         [ 184]          [  68]     r"DEPRECATED",
         [ 185]          [  69]     r"AW:",
         [ 186]        [Marcador de problema] line 334: 'TODO'
       [Marcador de problema] line 194: 'FIXME'
         [ 191]          [ 335]         "3) Estatísticas ao final\n"
         [ 192]          [ 336]         "4) Execução do 'make', com parse de warnings e errors\n"
         [ 193]          [ 337]         "5) Enfim, informações detalhadas para migração/debug.\n\n"
         [ 194]        [Marcador de problema] line 12: 'FIXME'
         [ 195]          [   9] - Mapeia diretórios, assinaturas de função
         [ 196]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 197]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
       [Marcador de problema] line 198: 'FIXME'
         [ 195]          [   9] - Mapeia diretórios, assinaturas de função
         [ 196]          [  10] - Mostra referências a "sm_13", "sm_86", NVCCFLAGS, etc., exibindo snippet de código
         [ 197]          [  11] - Localiza APIs obsoletas (cudaThreadSynchronize, etc.) e exibe snippet
         [ 198]          [  12] - Exibe TODO, FIXME, etc. com snippet
         [ 199]          [  13] - Separa warnings e errors do 'make' e agrupa
         [ 200]          [  14] - Gera contagem estatística de cada tipo de referência
         [ 201]          [  15]
       [Marcador de problema] line 202: 'FIXME'
         [ 199]          [  13] - Separa warnings e errors do 'make' e agrupa
         [ 200]          [  14] - Gera contagem estatística de cada tipo de referência
         [ 201]          [  15]
         [ 202]        [Marcador de problema] line 67: 'FIXME'
         [ 203]          [  64]
         [ 204]          [  65] PROBLEM_MARKERS = [
         [ 205]          [  66]     r"TODO",
       [Marcador de problema] line 206: 'FIXME'
         [ 203]          [  64]
         [ 204]          [  65] PROBLEM_MARKERS = [
         [ 205]          [  66]     r"TODO",
         [ 206]          [  67]     r"FIXME",
         [ 207]          [  68]     r"DEPRECATED",
         [ 208]          [  69]     r"AW:",
         [ 209]          [  70]     r"eight[ -_]years",
       [Marcador de problema] line 213: 'FIXME'
         [ 210]        [Marcador de problema] line 68: 'DEPRECATED'
         [ 211]          [  65] PROBLEM_MARKERS = [
         [ 212]          [  66]     r"TODO",
         [ 213]          [  67]     r"FIXME",
         [ 214]          [  68]     r"DEPRECATED",
         [ 215]          [  69]     r"AW:",
         [ 216]          [  70]     r"eight[ -_]years",
       [Marcador de problema] line 220: 'FIXME'
         [ 217]          [  71] ]
         [ 218]        [Marcador de problema] line 69: 'AW:'
         [ 219]          [  66]     r"TODO",
         [ 220]          [  67]     r"FIXME",
         [ 221]          [  68]     r"DEPRECATED",
         [ 222]          [  69]     r"AW:",
         [ 223]          [  70]     r"eight[ -_]years",
       [Marcador de problema] line 229: 'FIXME'
         [ 226]   |- LICENSE
         [ 227]   |- compile
         [ 228]     -> Referências importantes (com snippet):
         [ 229]        [Marcador de problema] line 324: 'FIXME'
         [ 230]          [ 321]   fi
         [ 231]          [ 322]   sleep 1
         [ 232]          [ 323] done
       [Marcador de problema] line 233: 'FIXME'
         [ 230]          [ 321]   fi
         [ 231]          [ 322]   sleep 1
         [ 232]          [ 323] done
         [ 233]          [ 324] # FIXME: race condition here if user kills between mkdir and trap.
         [ 234]          [ 325] trap "rmdir '$lockdir'; exit 1" 1 2 15
         [ 235]          [ 326]
         [ 236]          [ 327] # Run the compile.
       [Marcador de problema] line 241: 'FIXME'
         [ 238]   |- intltool-merge.in
         [ 239]   |- depcomp
         [ 240]     -> Referências importantes (com snippet):
         [ 241]        [Marcador de problema] line 330: 'FIXME'
         [ 242]          [ 327]
         [ 243]          [ 328] tcc)
         [ 244]          [ 329]   # tcc (Tiny C Compiler) understand '-MD -MF file' since version 0.9.26
       [Marcador de problema] line 245: 'FIXME'
         [ 242]          [ 327]
         [ 243]          [ 328] tcc)
         [ 244]          [ 329]   # tcc (Tiny C Compiler) understand '-MD -MF file' since version 0.9.26
         [ 245]          [ 330]   # FIXME: That version still under development at the moment of writing.
         [ 246]          [ 331]   #        Make that this statement remains true also for stable, released
         [ 247]          [ 332]   #        versions.
         [ 248]          [ 333]   # It will wrap lines (doesn't matter whether long or short) with a
       [Marcador de problema] line 297: 'FIXME'
         [ 294]   |- missing
         [ 295]   |- config.sub
         [ 296]     -> Referências importantes (com snippet):
         [ 297]        [Marcador de problema] line 769: 'FIXME'
         [ 298]          [ 766] 		vendor=hp
         [ 299]          [ 767] 		;;
         [ 300]          [ 768] 	hp9k78[0-9] | hp78[0-9])
       [Marcador de problema] line 301: 'FIXME'
         [ 298]          [ 766] 		vendor=hp
         [ 299]          [ 767] 		;;
         [ 300]          [ 768] 	hp9k78[0-9] | hp78[0-9])
         [ 301]          [ 769] 		# FIXME: really hppa2.0-hp
         [ 302]          [ 770] 		cpu=hppa1.1
         [ 303]          [ 771] 		vendor=hp
         [ 304]          [ 772] 		;;
       [Marcador de problema] line 305: 'FIXME'
         [ 302]          [ 770] 		cpu=hppa1.1
         [ 303]          [ 771] 		vendor=hp
         [ 304]          [ 772] 		;;
         [ 305]        [Marcador de problema] line 774: 'FIXME'
         [ 306]          [ 771] 		vendor=hp
         [ 307]          [ 772] 		;;
         [ 308]          [ 773] 	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
       [Marcador de problema] line 309: 'FIXME'
         [ 306]          [ 771] 		vendor=hp
         [ 307]          [ 772] 		;;
         [ 308]          [ 773] 	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
         [ 309]          [ 774] 		# FIXME: really hppa2.0-hp
         [ 310]          [ 775] 		cpu=hppa1.1
         [ 311]          [ 776] 		vendor=hp
         [ 312]          [ 777] 		;;
       [Marcador de problema] line 370: 'FIXME'
         [ 367]          [7487]   # requiring Autoconf 2.70 or later.
         [ 368]          [7488]   case $CONFIG_FILES in #(
         [ 369]          [7489]   *\'*) :
         [ 370]        [Marcador de problema] line 1199: 'FIXME'
         [ 371]          [1196]     export $ac_envvar ;;
         [ 372]          [1197]
         [ 373]          [1198]   *)
       [Marcador de problema] line 374: 'FIXME'
         [ 371]          [1196]     export $ac_envvar ;;
         [ 372]          [1197]
         [ 373]          [1198]   *)
         [ 374]          [1199]     # FIXME: should be removed in autoconf 3.0.
         [ 375]          [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 376]          [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 377]          [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 378: 'FIXME'
         [ 375]          [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 376]          [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 377]          [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
         [ 378]        [Marcador de problema] line 1245: 'FIXME'
         [ 379]          [1242]
         [ 380]          [1243] # There might be people who depend on the old broken behavior: `$host'
         [ 381]          [1244] # used to hold the argument of --host etc.
       [Marcador de problema] line 382: 'FIXME'
         [ 379]          [1242]
         [ 380]          [1243] # There might be people who depend on the old broken behavior: `$host'
         [ 381]          [1244] # used to hold the argument of --host etc.
         [ 382]          [1245] # FIXME: To remove some day.
         [ 383]          [1246] build=$build_alias
         [ 384]          [1247] host=$host_alias
         [ 385]          [1248] target=$target_alias
       [Marcador de problema] line 386: 'FIXME'
         [ 383]          [1246] build=$build_alias
         [ 384]          [1247] host=$host_alias
         [ 385]          [1248] target=$target_alias
         [ 386]        [Marcador de problema] line 1250: 'FIXME'
         [ 387]          [1247] host=$host_alias
         [ 388]          [1248] target=$target_alias
         [ 389]          [1249]
       [Marcador de problema] line 390: 'FIXME'
         [ 387]          [1247] host=$host_alias
         [ 388]          [1248] target=$target_alias
         [ 389]          [1249]
         [ 390]          [1250] # FIXME: To remove some day.
         [ 391]          [1251] if test "x$host_alias" != x; then
         [ 392]          [1252]   if test "x$build_alias" = x; then
         [ 393]          [1253]     cross_compiling=maybe
       [Marcador de problema] line 394: 'FIXME'
         [ 391]          [1251] if test "x$host_alias" != x; then
         [ 392]          [1252]   if test "x$build_alias" = x; then
         [ 393]          [1253]     cross_compiling=maybe
         [ 394]        [Marcador de problema] line 4654: 'FIXME'
         [ 395]          [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [ 396]          [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [ 397]          [4653]    # Losing compiler, so override with the script.
       [Marcador de problema] line 398: 'FIXME'
         [ 395]          [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [ 396]          [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [ 397]          [4653]    # Losing compiler, so override with the script.
         [ 398]          [4654]    # FIXME: It is wrong to rewrite CC.
         [ 399]          [4655]    # But if we don't then we get into trouble of one sort or another.
         [ 400]          [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [ 401]          [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
       [Marcador de problema] line 402: 'FIXME'
         [ 399]          [4655]    # But if we don't then we get into trouble of one sort or another.
         [ 400]          [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [ 401]          [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
         [ 402]        [Marcador de problema] line 7344: 'FIXME'
         [ 403]          [7341]
         [ 404]          [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [ 405]          [7343] # If the template does not know about datarootdir, expand it.
       [Marcador de problema] line 406: 'FIXME'
         [ 403]          [7341]
         [ 404]          [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [ 405]          [7343] # If the template does not know about datarootdir, expand it.
         [ 406]          [7344] # FIXME: This hack should be removed a few years after 2.60.
         [ 407]          [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [ 408]          [7346] ac_sed_dataroot='
         [ 409]          [7347] /datarootdir/ {
       [Marcador de problema] line 410: 'FIXME'
         [ 407]          [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [ 408]          [7346] ac_sed_dataroot='
         [ 409]          [7347] /datarootdir/ {
         [ 410]        [Marcador de problema] line 7375: 'FIXME'
         [ 411]          [7372]
         [ 412]          [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [ 413]          [7374] # Shell code in configure.ac might set extrasub.
       [Marcador de problema] line 414: 'FIXME'
         [ 411]          [7372]
         [ 412]          [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [ 413]          [7374] # Shell code in configure.ac might set extrasub.
         [ 414]          [7375] # FIXME: do we really want to maintain this feature?
         [ 415]          [7376] cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
         [ 416]          [7377] ac_sed_extra="$ac_vpsub
         [ 417]          [7378] $extrasub
       [Marcador de problema] line 463: 'FIXME'
         [ 460]          [6658] RANLIB!$RANLIB$ac_delim
         [ 461]          [6659] CPP!$CPP$ac_delim
         [ 462]          [6660] GREP!$GREP$ac_delim
         [ 463]        [Marcador de problema] line 1107: 'FIXME'
         [ 464]          [1104]     export $ac_envvar ;;
         [ 465]          [1105]
         [ 466]          [1106]   *)
       [Marcador de problema] line 467: 'FIXME'
         [ 464]          [1104]     export $ac_envvar ;;
         [ 465]          [1105]
         [ 466]          [1106]   *)
         [ 467]          [1107]     # FIXME: should be removed in autoconf 3.0.
         [ 468]          [1108]     echo "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 469]          [1109]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 470]          [1110]       echo "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 471: 'FIXME'
         [ 468]          [1108]     echo "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 469]          [1109]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 470]          [1110]       echo "$as_me: WARNING: invalid host type: $ac_option" >&2
         [ 471]        [Marcador de problema] line 1140: 'FIXME'
         [ 472]          [1137]
         [ 473]          [1138] # There might be people who depend on the old broken behavior: `$host'
         [ 474]          [1139] # used to hold the argument of --host etc.
       [Marcador de problema] line 475: 'FIXME'
         [ 472]          [1137]
         [ 473]          [1138] # There might be people who depend on the old broken behavior: `$host'
         [ 474]          [1139] # used to hold the argument of --host etc.
         [ 475]          [1140] # FIXME: To remove some day.
         [ 476]          [1141] build=$build_alias
         [ 477]          [1142] host=$host_alias
         [ 478]          [1143] target=$target_alias
       [Marcador de problema] line 479: 'FIXME'
         [ 476]          [1141] build=$build_alias
         [ 477]          [1142] host=$host_alias
         [ 478]          [1143] target=$target_alias
         [ 479]        [Marcador de problema] line 1145: 'FIXME'
         [ 480]          [1142] host=$host_alias
         [ 481]          [1143] target=$target_alias
         [ 482]          [1144]
       [Marcador de problema] line 483: 'FIXME'
         [ 480]          [1142] host=$host_alias
         [ 481]          [1143] target=$target_alias
         [ 482]          [1144]
         [ 483]          [1145] # FIXME: To remove some day.
         [ 484]          [1146] if test "x$host_alias" != x; then
         [ 485]          [1147]   if test "x$build_alias" = x; then
         [ 486]          [1148]     cross_compiling=maybe
       [Marcador de problema] line 487: 'FIXME'
         [ 484]          [1146] if test "x$host_alias" != x; then
         [ 485]          [1147]   if test "x$build_alias" = x; then
         [ 486]          [1148]     cross_compiling=maybe
         [ 487]        [Marcador de problema] line 2942: 'FIXME'
         [ 488]          [2939] # the compiler is broken, or we cross compile.
         [ 489]          [2940] { echo "$as_me:$LINENO: checking whether the C compiler works" >&5
         [ 490]          [2941] echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6; }
       [Marcador de problema] line 491: 'FIXME'
         [ 488]          [2939] # the compiler is broken, or we cross compile.
         [ 489]          [2940] { echo "$as_me:$LINENO: checking whether the C compiler works" >&5
         [ 490]          [2941] echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6; }
         [ 491]          [2942] # FIXME: These cross compiler hacks should be removed for Autoconf 3.0
         [ 492]          [2943] # If not cross compiling, check that we can run a simple program.
         [ 493]          [2944] if test "$cross_compiling" != yes; then
         [ 494]          [2945]   if { ac_try='./$ac_file'
       [Marcador de problema] line 495: 'FIXME'
         [ 492]          [2943] # If not cross compiling, check that we can run a simple program.
         [ 493]          [2944] if test "$cross_compiling" != yes; then
         [ 494]          [2945]   if { ac_try='./$ac_file'
         [ 495]        [Marcador de problema] line 5210: 'FIXME'
         [ 496]          [5207] int
         [ 497]          [5208] main ()
         [ 498]          [5209] {
       [Marcador de problema] line 499: 'FIXME'
         [ 496]          [5207] int
         [ 497]          [5208] main ()
         [ 498]          [5209] {
         [ 499]          [5210] /* FIXME: Include the comments suggested by Paul. */
         [ 500]          [5211] #ifndef __cplusplus
         [ 501]          [5212]   /* Ultrix mips cc rejects this.  */
         [ 502]          [5213]   typedef int charset[2];
       [Marcador de problema] line 503: 'FIXME'
         [ 500]          [5211] #ifndef __cplusplus
         [ 501]          [5212]   /* Ultrix mips cc rejects this.  */
         [ 502]          [5213]   typedef int charset[2];
         [ 503]        [Marcador de problema] line 6902: 'FIXME'
         [ 504]          [6899]
         [ 505]          [6900] cat >>$CONFIG_STATUS <<\_ACEOF
         [ 506]          [6901] # If the template does not know about datarootdir, expand it.
       [Marcador de problema] line 507: 'FIXME'
         [ 504]          [6899]
         [ 505]          [6900] cat >>$CONFIG_STATUS <<\_ACEOF
         [ 506]          [6901] # If the template does not know about datarootdir, expand it.
         [ 507]          [6902] # FIXME: This hack should be removed a few years after 2.60.
         [ 508]          [6903] ac_datarootdir_hack=; ac_datarootdir_seen=
         [ 509]          [6904]
         [ 510]          [6905] case `sed -n '/datarootdir/ {
       [Marcador de problema] line 511: 'FIXME'
         [ 508]          [6903] ac_datarootdir_hack=; ac_datarootdir_seen=
         [ 509]          [6904]
         [ 510]          [6905] case `sed -n '/datarootdir/ {
         [ 511]        [Marcador de problema] line 6933: 'FIXME'
         [ 512]          [6930]
         [ 513]          [6931] # Neutralize VPATH when `$srcdir' = `.'.
         [ 514]          [6932] # Shell code in configure.ac might set extrasub.
       [Marcador de problema] line 515: 'FIXME'
         [ 512]          [6930]
         [ 513]          [6931] # Neutralize VPATH when `$srcdir' = `.'.
         [ 514]          [6932] # Shell code in configure.ac might set extrasub.
         [ 515]          [6933] # FIXME: do we really want to maintain this feature?
         [ 516]          [6934] cat >>$CONFIG_STATUS <<_ACEOF
         [ 517]          [6935]   sed "$ac_vpsub
         [ 518]          [6936] $extrasub
       [Marcador de problema] line 545: 'FIXME'
         [ 542]          [1125]   # requiring Autoconf 2.70 or later.
         [ 543]          [1126]   case $CONFIG_FILES in #(
         [ 544]          [1127]   *\'*) :
         [ 545]        [Marcador de problema] line 977: 'FIXME'
         [ 546]          [ 974]   */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
         [ 547]          [ 975]   esac
         [ 548]          [ 976] # If the template does not know about datarootdir, expand it.
       [Marcador de problema] line 549: 'FIXME'
         [ 546]          [ 974]   */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
         [ 547]          [ 975]   esac
         [ 548]          [ 976] # If the template does not know about datarootdir, expand it.
         [ 549]          [ 977] # FIXME: This hack should be removed a few years after 2.60.
         [ 550]          [ 978] ac_datarootdir_hack=; ac_datarootdir_seen=
         [ 551]          [ 979] ac_sed_dataroot='
         [ 552]          [ 980] /datarootdir/ {
       [Marcador de problema] line 581: 'FIXME'
         [ 578]          [ 349]   # requiring Autoconf 2.70 or later.
         [ 579]          [ 350]   AS_CASE([$CONFIG_FILES],
         [ 580]          [ 351]           [*\'*], [eval set x "$CONFIG_FILES"],
         [ 581]        [Marcador de problema] line 831: 'FIXME'
         [ 582]          [ 828]   unset am_i])
         [ 583]          [ 829] if test "$am_cv_prog_cc_c_o" != yes; then
         [ 584]          [ 830]    # Losing compiler, so override with the script.
       [Marcador de problema] line 585: 'FIXME'
         [ 582]          [ 828]   unset am_i])
         [ 583]          [ 829] if test "$am_cv_prog_cc_c_o" != yes; then
         [ 584]          [ 830]    # Losing compiler, so override with the script.
         [ 585]          [ 831]    # FIXME: It is wrong to rewrite CC.
         [ 586]          [ 832]    # But if we don't then we get into trouble of one sort or another.
         [ 587]          [ 833]    # A longer-term fix would be to have automake use am__CC in this case,
         [ 588]          [ 834]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
       [Marcador de problema] line 664: 'FIXME'
         [ 661]          [7487]   # requiring Autoconf 2.70 or later.
         [ 662]          [7488]   case $CONFIG_FILES in @%:@(
         [ 663]          [7489]   *\'*) :
         [ 664]        [Marcador de problema] line 1199: 'FIXME'
         [ 665]          [1196]     export $ac_envvar ;;
         [ 666]          [1197]
         [ 667]          [1198]   *)
       [Marcador de problema] line 668: 'FIXME'
         [ 665]          [1196]     export $ac_envvar ;;
         [ 666]          [1197]
         [ 667]          [1198]   *)
         [ 668]          [1199]     # FIXME: should be removed in autoconf 3.0.
         [ 669]          [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 670]          [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 671]          [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 672: 'FIXME'
         [ 669]          [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 670]          [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 671]          [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
         [ 672]        [Marcador de problema] line 1245: 'FIXME'
         [ 673]          [1242]
         [ 674]          [1243] # There might be people who depend on the old broken behavior: `$host'
         [ 675]          [1244] # used to hold the argument of --host etc.
       [Marcador de problema] line 676: 'FIXME'
         [ 673]          [1242]
         [ 674]          [1243] # There might be people who depend on the old broken behavior: `$host'
         [ 675]          [1244] # used to hold the argument of --host etc.
         [ 676]          [1245] # FIXME: To remove some day.
         [ 677]          [1246] build=$build_alias
         [ 678]          [1247] host=$host_alias
         [ 679]          [1248] target=$target_alias
       [Marcador de problema] line 680: 'FIXME'
         [ 677]          [1246] build=$build_alias
         [ 678]          [1247] host=$host_alias
         [ 679]          [1248] target=$target_alias
         [ 680]        [Marcador de problema] line 1250: 'FIXME'
         [ 681]          [1247] host=$host_alias
         [ 682]          [1248] target=$target_alias
         [ 683]          [1249]
       [Marcador de problema] line 684: 'FIXME'
         [ 681]          [1247] host=$host_alias
         [ 682]          [1248] target=$target_alias
         [ 683]          [1249]
         [ 684]          [1250] # FIXME: To remove some day.
         [ 685]          [1251] if test "x$host_alias" != x; then
         [ 686]          [1252]   if test "x$build_alias" = x; then
         [ 687]          [1253]     cross_compiling=maybe
       [Marcador de problema] line 688: 'FIXME'
         [ 685]          [1251] if test "x$host_alias" != x; then
         [ 686]          [1252]   if test "x$build_alias" = x; then
         [ 687]          [1253]     cross_compiling=maybe
         [ 688]        [Marcador de problema] line 4654: 'FIXME'
         [ 689]          [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [ 690]          [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [ 691]          [4653]    # Losing compiler, so override with the script.
       [Marcador de problema] line 692: 'FIXME'
         [ 689]          [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [ 690]          [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [ 691]          [4653]    # Losing compiler, so override with the script.
         [ 692]          [4654]    # FIXME: It is wrong to rewrite CC.
         [ 693]          [4655]    # But if we don't then we get into trouble of one sort or another.
         [ 694]          [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [ 695]          [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
       [Marcador de problema] line 696: 'FIXME'
         [ 693]          [4655]    # But if we don't then we get into trouble of one sort or another.
         [ 694]          [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [ 695]          [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
         [ 696]        [Marcador de problema] line 7344: 'FIXME'
         [ 697]          [7341]
         [ 698]          [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [ 699]          [7343] # If the template does not know about datarootdir, expand it.
       [Marcador de problema] line 700: 'FIXME'
         [ 697]          [7341]
         [ 698]          [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [ 699]          [7343] # If the template does not know about datarootdir, expand it.
         [ 700]          [7344] # FIXME: This hack should be removed a few years after 2.60.
         [ 701]          [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [ 702]          [7346] ac_sed_dataroot='
         [ 703]          [7347] /datarootdir/ {
       [Marcador de problema] line 704: 'FIXME'
         [ 701]          [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [ 702]          [7346] ac_sed_dataroot='
         [ 703]          [7347] /datarootdir/ {
         [ 704]        [Marcador de problema] line 7375: 'FIXME'
         [ 705]          [7372]
         [ 706]          [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [ 707]          [7374] # Shell code in configure.ac might set extrasub.
       [Marcador de problema] line 708: 'FIXME'
         [ 705]          [7372]
         [ 706]          [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [ 707]          [7374] # Shell code in configure.ac might set extrasub.
         [ 708]          [7375] # FIXME: do we really want to maintain this feature?
         [ 709]          [7376] cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
         [ 710]          [7377] ac_sed_extra="$ac_vpsub
         [ 711]          [7378] $extrasub
       [Marcador de problema] line 730: 'FIXME'
         [ 727]          [ 191]   # requiring Autoconf 2.70 or later.
         [ 728]          [ 192]   AS_CASE([$CONFIG_FILES],
         [ 729]          [ 193]           [*\'*], [eval set x "$CONFIG_FILES"],
         [ 730]        [Marcador de problema] line 513: 'FIXME'
         [ 731]          [ 510]   unset am_i])
         [ 732]          [ 511] if test "$am_cv_prog_cc_c_o" != yes; then
         [ 733]          [ 512]    # Losing compiler, so override with the script.
       [Marcador de problema] line 734: 'FIXME'
         [ 731]          [ 510]   unset am_i])
         [ 732]          [ 511] if test "$am_cv_prog_cc_c_o" != yes; then
         [ 733]          [ 512]    # Losing compiler, so override with the script.
         [ 734]          [ 513]    # FIXME: It is wrong to rewrite CC.
         [ 735]          [ 514]    # But if we don't then we get into trouble of one sort or another.
         [ 736]          [ 515]    # A longer-term fix would be to have automake use am__CC in this case,
         [ 737]          [ 516]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
       [Marcador de problema] line 799: 'FIXME'
         [ 796]          [7487]   # requiring Autoconf 2.70 or later.
         [ 797]          [7488]   case $CONFIG_FILES in @%:@(
         [ 798]          [7489]   *\'*) :
         [ 799]        [Marcador de problema] line 1199: 'FIXME'
         [ 800]          [1196]     export $ac_envvar ;;
         [ 801]          [1197]
         [ 802]          [1198]   *)
       [Marcador de problema] line 803: 'FIXME'
         [ 800]          [1196]     export $ac_envvar ;;
         [ 801]          [1197]
         [ 802]          [1198]   *)
         [ 803]          [1199]     # FIXME: should be removed in autoconf 3.0.
         [ 804]          [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 805]          [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 806]          [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 807: 'FIXME'
         [ 804]          [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 805]          [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 806]          [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
         [ 807]        [Marcador de problema] line 1245: 'FIXME'
         [ 808]          [1242]
         [ 809]          [1243] # There might be people who depend on the old broken behavior: `$host'
         [ 810]          [1244] # used to hold the argument of --host etc.
       [Marcador de problema] line 811: 'FIXME'
         [ 808]          [1242]
         [ 809]          [1243] # There might be people who depend on the old broken behavior: `$host'
         [ 810]          [1244] # used to hold the argument of --host etc.
         [ 811]          [1245] # FIXME: To remove some day.
         [ 812]          [1246] build=$build_alias
         [ 813]          [1247] host=$host_alias
         [ 814]          [1248] target=$target_alias
       [Marcador de problema] line 815: 'FIXME'
         [ 812]          [1246] build=$build_alias
         [ 813]          [1247] host=$host_alias
         [ 814]          [1248] target=$target_alias
         [ 815]        [Marcador de problema] line 1250: 'FIXME'
         [ 816]          [1247] host=$host_alias
         [ 817]          [1248] target=$target_alias
         [ 818]          [1249]
       [Marcador de problema] line 819: 'FIXME'
         [ 816]          [1247] host=$host_alias
         [ 817]          [1248] target=$target_alias
         [ 818]          [1249]
         [ 819]          [1250] # FIXME: To remove some day.
         [ 820]          [1251] if test "x$host_alias" != x; then
         [ 821]          [1252]   if test "x$build_alias" = x; then
         [ 822]          [1253]     cross_compiling=maybe
       [Marcador de problema] line 823: 'FIXME'
         [ 820]          [1251] if test "x$host_alias" != x; then
         [ 821]          [1252]   if test "x$build_alias" = x; then
         [ 822]          [1253]     cross_compiling=maybe
         [ 823]        [Marcador de problema] line 4654: 'FIXME'
         [ 824]          [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [ 825]          [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [ 826]          [4653]    # Losing compiler, so override with the script.
       [Marcador de problema] line 827: 'FIXME'
         [ 824]          [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [ 825]          [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [ 826]          [4653]    # Losing compiler, so override with the script.
         [ 827]          [4654]    # FIXME: It is wrong to rewrite CC.
         [ 828]          [4655]    # But if we don't then we get into trouble of one sort or another.
         [ 829]          [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [ 830]          [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
       [Marcador de problema] line 831: 'FIXME'
         [ 828]          [4655]    # But if we don't then we get into trouble of one sort or another.
         [ 829]          [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [ 830]          [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
         [ 831]        [Marcador de problema] line 7344: 'FIXME'
         [ 832]          [7341]
         [ 833]          [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [ 834]          [7343] # If the template does not know about datarootdir, expand it.
       [Marcador de problema] line 835: 'FIXME'
         [ 832]          [7341]
         [ 833]          [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [ 834]          [7343] # If the template does not know about datarootdir, expand it.
         [ 835]          [7344] # FIXME: This hack should be removed a few years after 2.60.
         [ 836]          [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [ 837]          [7346] ac_sed_dataroot='
         [ 838]          [7347] /datarootdir/ {
       [Marcador de problema] line 839: 'FIXME'
         [ 836]          [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [ 837]          [7346] ac_sed_dataroot='
         [ 838]          [7347] /datarootdir/ {
         [ 839]        [Marcador de problema] line 7375: 'FIXME'
         [ 840]          [7372]
         [ 841]          [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [ 842]          [7374] # Shell code in configure.ac might set extrasub.
       [Marcador de problema] line 843: 'FIXME'
         [ 840]          [7372]
         [ 841]          [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [ 842]          [7374] # Shell code in configure.ac might set extrasub.
         [ 843]          [7375] # FIXME: do we really want to maintain this feature?
         [ 844]          [7376] cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
         [ 845]          [7377] ac_sed_extra="$ac_vpsub
         [ 846]          [7378] $extrasub
       [Marcador de problema] line 889: 'FIXME'
         [ 886]          [5873] s,@RANLIB@,$RANLIB,;t t
         [ 887]          [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [ 888]          [5875] s,@CPP@,$CPP,;t t
         [ 889]        [Marcador de problema] line 643: 'FIXME'
         [ 890]          [ 640]     export $ac_envvar ;;
         [ 891]          [ 641]
         [ 892]          [ 642]   *)
       [Marcador de problema] line 893: 'FIXME'
         [ 890]          [ 640]     export $ac_envvar ;;
         [ 891]          [ 641]
         [ 892]          [ 642]   *)
         [ 893]          [ 643]     # FIXME: should be removed in autoconf 3.0.
         [ 894]          [ 644]     echo "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 895]          [ 645]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 896]          [ 646]       echo "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 897: 'FIXME'
         [ 894]          [ 644]     echo "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 895]          [ 645]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 896]          [ 646]       echo "$as_me: WARNING: invalid host type: $ac_option" >&2
         [ 897]        [Marcador de problema] line 684: 'FIXME'
         [ 898]          [ 681]
         [ 899]          [ 682] # There might be people who depend on the old broken behavior: `$host'
         [ 900]          [ 683] # used to hold the argument of --host etc.
       [Marcador de problema] line 901: 'FIXME'
         [ 898]          [ 681]
         [ 899]          [ 682] # There might be people who depend on the old broken behavior: `$host'
         [ 900]          [ 683] # used to hold the argument of --host etc.
         [ 901]          [ 684] # FIXME: To remove some day.
         [ 902]          [ 685] build=$build_alias
         [ 903]          [ 686] host=$host_alias
         [ 904]          [ 687] target=$target_alias
       [Marcador de problema] line 905: 'FIXME'
         [ 902]          [ 685] build=$build_alias
         [ 903]          [ 686] host=$host_alias
         [ 904]          [ 687] target=$target_alias
         [ 905]        [Marcador de problema] line 689: 'FIXME'
         [ 906]          [ 686] host=$host_alias
         [ 907]          [ 687] target=$target_alias
         [ 908]          [ 688]
       [Marcador de problema] line 909: 'FIXME'
         [ 906]          [ 686] host=$host_alias
         [ 907]          [ 687] target=$target_alias
         [ 908]          [ 688]
         [ 909]          [ 689] # FIXME: To remove some day.
         [ 910]          [ 690] if test "x$host_alias" != x; then
         [ 911]          [ 691]   if test "x$build_alias" = x; then
         [ 912]          [ 692]     cross_compiling=maybe
       [Marcador de problema] line 913: 'FIXME'
         [ 910]          [ 690] if test "x$host_alias" != x; then
         [ 911]          [ 691]   if test "x$build_alias" = x; then
         [ 912]          [ 692]     cross_compiling=maybe
         [ 913]        [Marcador de problema] line 2347: 'FIXME'
         [ 914]          [2344] 	break;;
         [ 915]          [2345]     *.* )
         [ 916]          [2346] 	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
       [Marcador de problema] line 917: 'FIXME'
         [ 914]          [2344] 	break;;
         [ 915]          [2345]     *.* )
         [ 916]          [2346] 	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
         [ 917]          [2347] 	# FIXME: I believe we export ac_cv_exeext for Libtool,
         [ 918]          [2348] 	# but it would be cool to find out if it's true.  Does anybody
         [ 919]          [2349] 	# maintain Libtool? --akim.
         [ 920]          [2350] 	export ac_cv_exeext
       [Marcador de problema] line 921: 'FIXME'
         [ 918]          [2348] 	# but it would be cool to find out if it's true.  Does anybody
         [ 919]          [2349] 	# maintain Libtool? --akim.
         [ 920]          [2350] 	export ac_cv_exeext
         [ 921]        [Marcador de problema] line 2375: 'FIXME'
         [ 922]          [2372] # the compiler is broken, or we cross compile.
         [ 923]          [2373] echo "$as_me:$LINENO: checking whether the C compiler works" >&5
         [ 924]          [2374] echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
       [Marcador de problema] line 925: 'FIXME'
         [ 922]          [2372] # the compiler is broken, or we cross compile.
         [ 923]          [2373] echo "$as_me:$LINENO: checking whether the C compiler works" >&5
         [ 924]          [2374] echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
         [ 925]          [2375] # FIXME: These cross compiler hacks should be removed for Autoconf 3.0
         [ 926]          [2376] # If not cross compiling, check that we can run a simple program.
         [ 927]          [2377] if test "$cross_compiling" != yes; then
         [ 928]          [2378]   if { ac_try='./$ac_file'
       [Marcador de problema] line 929: 'FIXME'
         [ 926]          [2376] # If not cross compiling, check that we can run a simple program.
         [ 927]          [2377] if test "$cross_compiling" != yes; then
         [ 928]          [2378]   if { ac_try='./$ac_file'
         [ 929]        [Marcador de problema] line 4501: 'FIXME'
         [ 930]          [4498] int
         [ 931]          [4499] main ()
         [ 932]          [4500] {
       [Marcador de problema] line 933: 'FIXME'
         [ 930]          [4498] int
         [ 931]          [4499] main ()
         [ 932]          [4500] {
         [ 933]          [4501] /* FIXME: Include the comments suggested by Paul. */
         [ 934]          [4502] #ifndef __cplusplus
         [ 935]          [4503]   /* Ultrix mips cc rejects this.  */
         [ 936]          [4504]   typedef int charset[2];
       [Marcador de problema] line 983: 'FIXME'
         [ 980]          [7487]   # requiring Autoconf 2.70 or later.
         [ 981]          [7488]   case $CONFIG_FILES in @%:@(
         [ 982]          [7489]   *\'*) :
         [ 983]        [Marcador de problema] line 1199: 'FIXME'
         [ 984]          [1196]     export $ac_envvar ;;
         [ 985]          [1197]
         [ 986]          [1198]   *)
       [Marcador de problema] line 987: 'FIXME'
         [ 984]          [1196]     export $ac_envvar ;;
         [ 985]          [1197]
         [ 986]          [1198]   *)
         [ 987]          [1199]     # FIXME: should be removed in autoconf 3.0.
         [ 988]          [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 989]          [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 990]          [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 991: 'FIXME'
         [ 988]          [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 989]          [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 990]          [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
         [ 991]        [Marcador de problema] line 1245: 'FIXME'
         [ 992]          [1242]
         [ 993]          [1243] # There might be people who depend on the old broken behavior: `$host'
         [ 994]          [1244] # used to hold the argument of --host etc.
       [Marcador de problema] line 995: 'FIXME'
         [ 992]          [1242]
         [ 993]          [1243] # There might be people who depend on the old broken behavior: `$host'
         [ 994]          [1244] # used to hold the argument of --host etc.
         [ 995]          [1245] # FIXME: To remove some day.
         [ 996]          [1246] build=$build_alias
         [ 997]          [1247] host=$host_alias
         [ 998]          [1248] target=$target_alias
       [Marcador de problema] line 999: 'FIXME'
         [ 996]          [1246] build=$build_alias
         [ 997]          [1247] host=$host_alias
         [ 998]          [1248] target=$target_alias
         [ 999]        [Marcador de problema] line 1250: 'FIXME'
         [1000]          [1247] host=$host_alias
         [1001]          [1248] target=$target_alias
         [1002]          [1249]
       [Marcador de problema] line 1003: 'FIXME'
         [1000]          [1247] host=$host_alias
         [1001]          [1248] target=$target_alias
         [1002]          [1249]
         [1003]          [1250] # FIXME: To remove some day.
         [1004]          [1251] if test "x$host_alias" != x; then
         [1005]          [1252]   if test "x$build_alias" = x; then
         [1006]          [1253]     cross_compiling=maybe
       [Marcador de problema] line 1007: 'FIXME'
         [1004]          [1251] if test "x$host_alias" != x; then
         [1005]          [1252]   if test "x$build_alias" = x; then
         [1006]          [1253]     cross_compiling=maybe
         [1007]        [Marcador de problema] line 4654: 'FIXME'
         [1008]          [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [1009]          [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [1010]          [4653]    # Losing compiler, so override with the script.
       [Marcador de problema] line 1011: 'FIXME'
         [1008]          [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [1009]          [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [1010]          [4653]    # Losing compiler, so override with the script.
         [1011]          [4654]    # FIXME: It is wrong to rewrite CC.
         [1012]          [4655]    # But if we don't then we get into trouble of one sort or another.
         [1013]          [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [1014]          [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
       [Marcador de problema] line 1015: 'FIXME'
         [1012]          [4655]    # But if we don't then we get into trouble of one sort or another.
         [1013]          [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [1014]          [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
         [1015]        [Marcador de problema] line 7344: 'FIXME'
         [1016]          [7341]
         [1017]          [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [1018]          [7343] # If the template does not know about datarootdir, expand it.
       [Marcador de problema] line 1019: 'FIXME'
         [1016]          [7341]
         [1017]          [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [1018]          [7343] # If the template does not know about datarootdir, expand it.
         [1019]          [7344] # FIXME: This hack should be removed a few years after 2.60.
         [1020]          [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [1021]          [7346] ac_sed_dataroot='
         [1022]          [7347] /datarootdir/ {
       [Marcador de problema] line 1023: 'FIXME'
         [1020]          [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [1021]          [7346] ac_sed_dataroot='
         [1022]          [7347] /datarootdir/ {
         [1023]        [Marcador de problema] line 7375: 'FIXME'
         [1024]          [7372]
         [1025]          [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [1026]          [7374] # Shell code in configure.ac might set extrasub.
       [Marcador de problema] line 1027: 'FIXME'
         [1024]          [7372]
         [1025]          [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [1026]          [7374] # Shell code in configure.ac might set extrasub.
         [1027]          [7375] # FIXME: do we really want to maintain this feature?
         [1028]          [7376] cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
         [1029]          [7377] ac_sed_extra="$ac_vpsub
         [1030]          [7378] $extrasub
       [Marcador de problema] line 1073: 'FIXME'
         [1070]          [5873] s,@RANLIB@,$RANLIB,;t t
         [1071]          [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [1072]          [5875] s,@CPP@,$CPP,;t t
         [1073]        [Marcador de problema] line 643: 'FIXME'
         [1074]          [ 640]     export $ac_envvar ;;
         [1075]          [ 641]
         [1076]          [ 642]   *)
       [Marcador de problema] line 1077: 'FIXME'
         [1074]          [ 640]     export $ac_envvar ;;
         [1075]          [ 641]
         [1076]          [ 642]   *)
         [1077]          [ 643]     # FIXME: should be removed in autoconf 3.0.
         [1078]          [ 644]     echo "$as_me: WARNING: you should use --build, --host, --target" >&2
         [1079]          [ 645]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [1080]          [ 646]       echo "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 1081: 'FIXME'
         [1078]          [ 644]     echo "$as_me: WARNING: you should use --build, --host, --target" >&2
         [1079]          [ 645]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [1080]          [ 646]       echo "$as_me: WARNING: invalid host type: $ac_option" >&2
         [1081]        [Marcador de problema] line 684: 'FIXME'
         [1082]          [ 681]
         [1083]          [ 682] # There might be people who depend on the old broken behavior: `$host'
         [1084]          [ 683] # used to hold the argument of --host etc.
       [Marcador de problema] line 1085: 'FIXME'
         [1082]          [ 681]
         [1083]          [ 682] # There might be people who depend on the old broken behavior: `$host'
         [1084]          [ 683] # used to hold the argument of --host etc.
         [1085]          [ 684] # FIXME: To remove some day.
         [1086]          [ 685] build=$build_alias
         [1087]          [ 686] host=$host_alias
         [1088]          [ 687] target=$target_alias
       [Marcador de problema] line 1089: 'FIXME'
         [1086]          [ 685] build=$build_alias
         [1087]          [ 686] host=$host_alias
         [1088]          [ 687] target=$target_alias
         [1089]        [Marcador de problema] line 689: 'FIXME'
         [1090]          [ 686] host=$host_alias
         [1091]          [ 687] target=$target_alias
         [1092]          [ 688]
       [Marcador de problema] line 1093: 'FIXME'
         [1090]          [ 686] host=$host_alias
         [1091]          [ 687] target=$target_alias
         [1092]          [ 688]
         [1093]          [ 689] # FIXME: To remove some day.
         [1094]          [ 690] if test "x$host_alias" != x; then
         [1095]          [ 691]   if test "x$build_alias" = x; then
         [1096]          [ 692]     cross_compiling=maybe
       [Marcador de problema] line 1097: 'FIXME'
         [1094]          [ 690] if test "x$host_alias" != x; then
         [1095]          [ 691]   if test "x$build_alias" = x; then
         [1096]          [ 692]     cross_compiling=maybe
         [1097]        [Marcador de problema] line 2347: 'FIXME'
         [1098]          [2344] 	break;;
         [1099]          [2345]     *.* )
         [1100]          [2346] 	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
       [Marcador de problema] line 1101: 'FIXME'
         [1098]          [2344] 	break;;
         [1099]          [2345]     *.* )
         [1100]          [2346] 	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
         [1101]          [2347] 	# FIXME: I believe we export ac_cv_exeext for Libtool,
         [1102]          [2348] 	# but it would be cool to find out if it's true.  Does anybody
         [1103]          [2349] 	# maintain Libtool? --akim.
         [1104]          [2350] 	export ac_cv_exeext
       [Marcador de problema] line 1105: 'FIXME'
         [1102]          [2348] 	# but it would be cool to find out if it's true.  Does anybody
         [1103]          [2349] 	# maintain Libtool? --akim.
         [1104]          [2350] 	export ac_cv_exeext
         [1105]        [Marcador de problema] line 2375: 'FIXME'
         [1106]          [2372] # the compiler is broken, or we cross compile.
         [1107]          [2373] echo "$as_me:$LINENO: checking whether the C compiler works" >&5
         [1108]          [2374] echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
       [Marcador de problema] line 1109: 'FIXME'
         [1106]          [2372] # the compiler is broken, or we cross compile.
         [1107]          [2373] echo "$as_me:$LINENO: checking whether the C compiler works" >&5
         [1108]          [2374] echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
         [1109]          [2375] # FIXME: These cross compiler hacks should be removed for Autoconf 3.0
         [1110]          [2376] # If not cross compiling, check that we can run a simple program.
         [1111]          [2377] if test "$cross_compiling" != yes; then
         [1112]          [2378]   if { ac_try='./$ac_file'
       [Marcador de problema] line 1113: 'FIXME'
         [1110]          [2376] # If not cross compiling, check that we can run a simple program.
         [1111]          [2377] if test "$cross_compiling" != yes; then
         [1112]          [2378]   if { ac_try='./$ac_file'
         [1113]        [Marcador de problema] line 4501: 'FIXME'
         [1114]          [4498] int
         [1115]          [4499] main ()
         [1116]          [4500] {
       [Marcador de problema] line 1117: 'FIXME'
         [1114]          [4498] int
         [1115]          [4499] main ()
         [1116]          [4500] {
         [1117]          [4501] /* FIXME: Include the comments suggested by Paul. */
         [1118]          [4502] #ifndef __cplusplus
         [1119]          [4503]   /* Ultrix mips cc rejects this.  */
         [1120]          [4504]   typedef int charset[2];
       [Marcador de problema] line 1415: 'FIXME'
         [1412]        [line 64]
         [1413]         CommandLineParser cmdLineParser(&args, false)
         [1414]     -> Referências importantes (com snippet):
         [1415]        [Marcador de problema] line 76: 'FIXME'
         [1416]          [  73]     }
         [1417]          [  74]     if (argc<=1 || userParameters->getInteractive())
         [1418]          [  75]     {
       [Marcador de problema] line 1419: 'FIXME'
         [1416]          [  73]     }
         [1417]          [  74]     if (argc<=1 || userParameters->getInteractive())
         [1418]          [  75]     {
         [1419]          [  76]         // FIXME: additional parameters like infile are ignored!
         [1420]          [  77]         InteractiveMenu menu;
         [1421]          [  78]         userParameters->setMenuFlag(true);
         [1422]          [  79]         userParameters->setInteractive(true);
       [Marcador de problema] line 2780: 'FIXME'
         [2777]     else if (outputPhylip)
         [2778]        [line 433]
         [2779]     else if (outputNexus)
         [2780]     -> Referências importantes (com snippet):
         [2781]        [Marcador de problema] line 35: 'FIXME'
         [2782]          [  32]
         [2783]          [  33] UserParameters::UserParameters(bool log)
       [Marcador de problema] line 2795: 'FIXME'
         [2792]          [ 176]
         [2793]          [ 177] // FIXME:never used
         [2794]          [ 178] void UserParameters::setParamsToDefault()
         [2795]          [ 179] {
         [2796]          [ 180]     DNAGapOpen = 15.0;
         [2797]        [Marcador de problema] line 290: 'FIXME'
         [2798]          [ 287]  * a file. It is used for testing and for saving parameters.
       [Marcador de problema] line 2799: 'FIXME'
         [2796]          [ 180]     DNAGapOpen = 15.0;
         [2797]        [Marcador de problema] line 290: 'FIXME'
         [2798]          [ 287]  * a file. It is used for testing and for saving parameters.
         [2799]          [ 288]  *
         [2800]          [ 289]  *
         [2801]          [ 290]  * FIXME: AW: Some parameters are missing here (e.g. the new ones like
         [2802]          [ 291]  * clustering, etc)
       [Marcador de problema] line 2803: 'FIXME'
         [2800]          [ 289]  *
         [2801]          [ 290]  * FIXME: AW: Some parameters are missing here (e.g. the new ones like
         [2802]          [ 291]  * clustering, etc)
         [2803]          [ 292]  *
         [2804]          [ 293]  */
         [2805]        [Marcador de problema] line 290: 'AW:'
         [2806]          [ 287]  * a file. It is used for testing and for saving parameters.
       [Marcador de problema] line 2807: 'FIXME'
         [2804]          [ 293]  */
         [2805]        [Marcador de problema] line 290: 'AW:'
         [2806]          [ 287]  * a file. It is used for testing and for saving parameters.
         [2807]          [ 288]  *
         [2808]          [ 289]  *
         [2809]          [ 290]  * FIXME: AW: Some parameters are missing here (e.g. the new ones like
         [2810]          [ 291]  * clustering, etc)
       [Marcador de problema] line 2811: 'FIXME'
         [2808]          [ 289]  *
         [2809]          [ 290]  * FIXME: AW: Some parameters are missing here (e.g. the new ones like
         [2810]          [ 291]  * clustering, etc)
         [2811]          [ 292]  *
         [2812]          [ 293]  */
         [2813]   |- Stats.h
         [2814]     -> Found 12 function(s):
       [Marcador de problema] line 2815: 'FIXME'
         [2812]          [ 293]  */
         [2813]   |- Stats.h
         [2814]     -> Found 12 function(s):
         [2815]        [line 2]  Author: Andreas Wilm
         [2816]  *
         [2817]  * Copyright (c)
         [2818]        [line 26]
       [Marcador de problema] line 2823: 'FIXME'
         [2820]     void setStatsFile(string f)
         [2821]        [line 28]
         [2822]     string getStatsFile()
         [2823]        [line 29]
         [2824] 
         [2825]     void setEnabled(bool b)
         [2826]        [line 31]
       [Marcador de problema] line 3842: 'FIXME'
         [3839]             if(logObject && DEBUGLOG)
         [3840]        [line 467]
         [3841]             else if(temp == 1)
         [3842]        [line 471]
         [3843]             else if(temp == 2)
         [3844]        [line 485]  DEBUGFULL
         [3845]             if(logObject && DEBUGLOG)
       [Marcador de problema] line 4116: 'FIXME'
         [4113]          [ 242]     cmdLineVerb[ctr++] = getCmdLineDataStruct("", NULL, -1, NULL);
         [4114]          [ 243]     // FIXME: final ctr index is hardcoded in CommandLineParser.h
         [4115]          [ 244]
         [4116]          [ 245]     // NOTE Start back here!!!!!!!!!!!!
         [4117]          [ 246]     ctr=0;
         [4118]        [Marcador de problema] line 308: 'FIXME'
         [4119]          [ 305]     cmdLinePara[ctr++] = getCmdLineDataStruct("maxseqlen", &setMaxSeqLen, INTARG, NULL);
       [Marcador de problema] line 4120: 'FIXME'
         [4117]          [ 246]     ctr=0;
         [4118]        [Marcador de problema] line 308: 'FIXME'
         [4119]          [ 305]     cmdLinePara[ctr++] = getCmdLineDataStruct("maxseqlen", &setMaxSeqLen, INTARG, NULL);
         [4120]          [ 306]     cmdLinePara[ctr++] = getCmdLineDataStruct("stats", &setStatsFile, FILARG, NULL);
         [4121]          [ 307]     cmdLinePara[ctr++] = getCmdLineDataStruct("", NULL, -1, NULL);
         [4122]          [ 308]     // FIXME: final ctr index is hardcoded in CommandLineParser
         [4123]          [ 309]
       [Marcador de problema] line 4124: 'FIXME'
         [4121]          [ 307]     cmdLinePara[ctr++] = getCmdLineDataStruct("", NULL, -1, NULL);
         [4122]          [ 308]     // FIXME: final ctr index is hardcoded in CommandLineParser
         [4123]          [ 309]
         [4124]          [ 310]     parseParams(args, xmenus);
         [4125]          [ 311] }
         [4126]        [Marcador de problema] line 1536: 'FIXME'
         [4127]          [1533]                     userParameters->setOutputFasta(true);
       [Marcador de problema] line 4128: 'FIXME'
         [4125]          [ 311] }
         [4126]        [Marcador de problema] line 1536: 'FIXME'
         [4127]          [1533]                     userParameters->setOutputFasta(true);
         [4128]          [1534]                     break;
         [4129]          [1535]                 default:
         [4130]          [1536]                     // FIXME AW: 1.83 behaves the same, but shouldnt
         [4131]          [1537]                     // we exit here?
       [Marcador de problema] line 4132: 'FIXME'
         [4129]          [1535]                 default:
         [4130]          [1536]                     // FIXME AW: 1.83 behaves the same, but shouldnt
         [4131]          [1537]                     // we exit here?
         [4132]          [1538]                     cout << "\nUnknown OUTPUT type: " << (*paramArg)[setOutput] << endl;
         [4133]          [1539]             }
         [4134]        [Marcador de problema] line 1117: 'AW:'
         [4135]          [1114]         return 0;
       [Marcador de problema] line 4136: 'FIXME'
         [4133]          [1539]             }
         [4134]        [Marcador de problema] line 1117: 'AW:'
         [4135]          [1114]         return 0;
         [4136]          [1115]     }
         [4137]          [1116]
         [4138]          [1117]     // AW: first arg is an input file if it doesnt start with commandsep
         [4139]          [1118]     if (VALID_COMMAND_SEP.find((*args)[0][0], 0) == string::npos)
       [Marcador de problema] line 4140: 'FIXME'
         [4137]          [1116]
         [4138]          [1117]     // AW: first arg is an input file if it doesnt start with commandsep
         [4139]          [1118]     if (VALID_COMMAND_SEP.find((*args)[0][0], 0) == string::npos)
         [4140]          [1119]     {
         [4141]          [1120]         name1 = true;
         [4142]        [Marcador de problema] line 1145: 'AW:'
         [4143]          [1142]     num = i;
       [Marcador de problema] line 4144: 'FIXME'
         [4141]          [1120]         name1 = true;
         [4142]        [Marcador de problema] line 1145: 'AW:'
         [4143]          [1142]     num = i;
         [4144]          [1143]
         [4145]          [1144]
         [4146]          [1145]     // AW:
         [4147]          [1146]     // params are now setup
       [Marcador de problema] line 4168: 'FIXME'
         [4165]         else if(userParameters->getDoRemoveFirstIteration()
         [4166]        [line 248]
         [4167] 
         [4168]             default:
         [4169]                 fprintf(stdout, "\n\nUnrecognised Command\n\n")
         [4170]        [line 718]  Create alignment output file(s)
         [4171]        [line 803]  fixed << setprecision(2)
       [Marcador de problema] line 5278: 'FIXME'
         [5275]  *
         [5276]  * Copyright (c)
         [5277]        [line 48]
         [5278]         bool openAlignmentOutput(string path)
         [5279]        [line 49]
         [5280]         bool QTOpenFilesForOutput(AlignmentFileNames fileNames)
         [5281]        [line 50]
       [Marcador de problema] line 5282: 'FIXME'
         [5279]        [line 49]
         [5280]         bool QTOpenFilesForOutput(AlignmentFileNames fileNames)
         [5281]        [line 50]
         [5282]         void createAlignmentOutput(Alignment* alignPtr, int firstSeq, int lastSeq)
         [5283]        [line 51]
         [5284]         void printSecStructMask(int prfLength, vector<char>* mask, vector<char>* structMask)
         [5285]        [line 56]
       [Marcador de problema] line 5622: 'FIXME'
         [5619]          [  46]  *
         [5620]          [  47]  * FIXME AW: only PearsonFileParser::getSeqRange is special, rest is the
         [5621]          [  48]  * same. should be defined in FileParser and then overloaded in special
         [5622]          [  49]  * cases like here
         [5623]          [  50]  */
         [5624]   |- InFileStream.cpp
         [5625]     -> Found 7 function(s):
       [Marcador de problema] line 5626: 'FIXME'
         [5623]          [  50]  */
         [5624]   |- InFileStream.cpp
         [5625]     -> Found 7 function(s):
         [5626]        [line 2]  Author: Nigel Brown
         [5627]  *
         [5628]  * Copyright (c)
         [5629]        [line 8]  This is then used by the getline()
       [Marcador de problema] line 5634: 'FIXME'
         [5631]        [line 109]  for CR or LF or CRLF (or LFCR)
         [5632]        [line 114]
         [5633]             else if (c == LF)
         [5634]        [line 116]
         [5635]             else if (type)
         [5636]        [line 137]  is UNIX (default)
         [5637]   |- ClustalFileParser.cpp
       [Marcador de problema] line 5757: 'FIXME'
         [5754]          [ 134]                 _fileIn->close();
         [5755]          [ 135]                 // FIXME AW: why return with a name but otherwise empty seq?
         [5756]          [ 136]                 return Sequence(blank, name, blank);
         [5757]          [ 137]             }
         [5758]          [ 138]         }
         [5759]   |- MSFFileParser.h
         [5760]     -> Found 5 function(s):
       [Marcador de problema] line 5761: 'FIXME'
         [5758]          [ 138]         }
         [5759]   |- MSFFileParser.h
         [5760]     -> Found 5 function(s):
         [5761]        [line 2]  Author: Mark Larkin
         [5762]  *
         [5763]  * Copyright (c)
         [5764]        [line 19]
       [Marcador de problema] line 5769: 'FIXME'
         [5766]        [line 20]
         [5767]         virtual vector<Sequence> getSeqRange(int firstSeq, int num)
         [5768]        [line 21]
         [5769]         virtual int countSeqs()
         [5770]        [line 22]
         [5771]         virtual void getSecStructure(vector<char>& gapPenaltyMask,
         [5772]                                      vector<char>& secStructMask, string& secStructName,
       [Marcador de problema] line 5801: 'FIXME'
         [5798] 
         [5799]             if (structPenalties != NONE)
         [5800]        [line 352]
         [5801]         else if(code == NOSEQUENCESINFILE)
         [5802]        [line 374]  Clear old info
         [5803] 
         [5804]             if (structPenalties != NONE)
       [Marcador de problema] line 5844: 'FIXME'
         [5841]          [ 217]         return fileParser->getParseExitCode();
         [5842]          [ 218]     // FIXME AW: noEmptySequence check should be done internally by FileParser instances
         [5843]          [ 219]     if (noEmptySequence(seqRangeVector) == false)
         [5844]          [ 220]         return EMPTYSEQUENCE; // Error there are same names.
         [5845]          [ 221]
         [5846] 
         [5847] === Execução do 'make' ===
       [Marcador de problema] line 5848: 'FIXME'
         [5845]          [ 221]
         [5846] 
         [5847] === Execução do 'make' ===
         [5848] 
         [5849] Código de retorno do 'make': 2
         [5850] 
         [5851] >> RAW MAKE OUTPUT <<
       [Marcador de problema] line 5856: 'FIXME'
         [5853] Making all in m4
         [5854] make[1]: Entering directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/m4'
         [5855] make[1]: Nothing to be done for 'all'.
         [5856] make[1]: Leaving directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/m4'
         [5857] Making all in src
         [5858] make[1]: Entering directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/src'
         [5859] make  all-recursive
       [Marcador de problema] line 184: 'DEPRECATED'
         [ 181]          [  65] PROBLEM_MARKERS = [
         [ 182]          [  66]     r"TODO",
         [ 183]          [  67]     r"FIXME",
         [ 184]          [  68]     r"DEPRECATED",
         [ 185]          [  69]     r"AW:",
         [ 186]        [Marcador de problema] line 334: 'TODO'
         [ 187]          [ 331]         "============================================================\n\n"
       [Marcador de problema] line 207: 'DEPRECATED'
         [ 204]          [  65] PROBLEM_MARKERS = [
         [ 205]          [  66]     r"TODO",
         [ 206]          [  67]     r"FIXME",
         [ 207]          [  68]     r"DEPRECATED",
         [ 208]          [  69]     r"AW:",
         [ 209]          [  70]     r"eight[ -_]years",
         [ 210]        [Marcador de problema] line 68: 'DEPRECATED'
       [Marcador de problema] line 210: 'DEPRECATED'
         [ 207]          [  68]     r"DEPRECATED",
         [ 208]          [  69]     r"AW:",
         [ 209]          [  70]     r"eight[ -_]years",
         [ 210]        [Marcador de problema] line 68: 'DEPRECATED'
         [ 211]          [  65] PROBLEM_MARKERS = [
         [ 212]          [  66]     r"TODO",
         [ 213]          [  67]     r"FIXME",
       [Marcador de problema] line 214: 'DEPRECATED'
         [ 211]          [  65] PROBLEM_MARKERS = [
         [ 212]          [  66]     r"TODO",
         [ 213]          [  67]     r"FIXME",
         [ 214]          [  68]     r"DEPRECATED",
         [ 215]          [  69]     r"AW:",
         [ 216]          [  70]     r"eight[ -_]years",
         [ 217]          [  71] ]
       [Marcador de problema] line 221: 'DEPRECATED'
         [ 218]        [Marcador de problema] line 69: 'AW:'
         [ 219]          [  66]     r"TODO",
         [ 220]          [  67]     r"FIXME",
         [ 221]          [  68]     r"DEPRECATED",
         [ 222]          [  69]     r"AW:",
         [ 223]          [  70]     r"eight[ -_]years",
         [ 224]          [  71] ]
       [Marcador de problema] line 185: 'AW:'
         [ 182]          [  66]     r"TODO",
         [ 183]          [  67]     r"FIXME",
         [ 184]          [  68]     r"DEPRECATED",
         [ 185]          [  69]     r"AW:",
         [ 186]        [Marcador de problema] line 334: 'TODO'
         [ 187]          [ 331]         "============================================================\n\n"
         [ 188]          [ 332]         "Inclui:\n"
       [Marcador de problema] line 208: 'AW:'
         [ 205]          [  66]     r"TODO",
         [ 206]          [  67]     r"FIXME",
         [ 207]          [  68]     r"DEPRECATED",
         [ 208]          [  69]     r"AW:",
         [ 209]          [  70]     r"eight[ -_]years",
         [ 210]        [Marcador de problema] line 68: 'DEPRECATED'
         [ 211]          [  65] PROBLEM_MARKERS = [
       [Marcador de problema] line 215: 'AW:'
         [ 212]          [  66]     r"TODO",
         [ 213]          [  67]     r"FIXME",
         [ 214]          [  68]     r"DEPRECATED",
         [ 215]          [  69]     r"AW:",
         [ 216]          [  70]     r"eight[ -_]years",
         [ 217]          [  71] ]
         [ 218]        [Marcador de problema] line 69: 'AW:'
       [Marcador de problema] line 218: 'AW:'
         [ 215]          [  69]     r"AW:",
         [ 216]          [  70]     r"eight[ -_]years",
         [ 217]          [  71] ]
         [ 218]        [Marcador de problema] line 69: 'AW:'
         [ 219]          [  66]     r"TODO",
         [ 220]          [  67]     r"FIXME",
         [ 221]          [  68]     r"DEPRECATED",
       [Marcador de problema] line 222: 'AW:'
         [ 219]          [  66]     r"TODO",
         [ 220]          [  67]     r"FIXME",
         [ 221]          [  68]     r"DEPRECATED",
         [ 222]          [  69]     r"AW:",
         [ 223]          [  70]     r"eight[ -_]years",
         [ 224]          [  71] ]
         [ 225]          [  72]
       [Marcador de problema] line 1840: 'AW:'
         [1837]     if (numSeqs >= 2)
         [1838]        [line 614]  new MSA()
         [1839]     -> Referências importantes (com snippet):
         [1840]        [Marcador de problema] line 431: 'AW:'
         [1841]          [ 428]         clusterTree->treeFromDistMatrix(distMat, alignPtr, seq1, nSeqs, copyOfPhylipName);
         [1842]          [ 429]
         [1843]          [ 430]         *phylipName = copyOfPhylipName;
       [Marcador de problema] line 1844: 'AW:'
         [1841]          [ 428]         clusterTree->treeFromDistMatrix(distMat, alignPtr, seq1, nSeqs, copyOfPhylipName);
         [1842]          [ 429]
         [1843]          [ 430]         *phylipName = copyOfPhylipName;
         [1844]          [ 431]         // AW: message outputted by OutputFile function
         [1845]          [ 432]         // utilityObject->info("Guide tree        file created:   [%s]",
         [1846]          [ 433]         //                              phylipName->c_str());
         [1847]          [ 434]         delete clusterTree;
       [Marcador de problema] line 1848: 'AW:'
         [1845]          [ 432]         // utilityObject->info("Guide tree        file created:   [%s]",
         [1846]          [ 433]         //                              phylipName->c_str());
         [1847]          [ 434]         delete clusterTree;
         [1848]        [Marcador de problema] line 516: 'AW:'
         [1849]          [ 513]                                                    nSeqs, copyOfPhylipName);
         [1850]          [ 514]
         [1851]          [ 515]         *phylipName = copyOfPhylipName;
       [Marcador de problema] line 1852: 'AW:'
         [1849]          [ 513]                                                    nSeqs, copyOfPhylipName);
         [1850]          [ 514]
         [1851]          [ 515]         *phylipName = copyOfPhylipName;
         [1852]          [ 516]         // AW: message outputted by OutputFile function
         [1853]          [ 517]         // utilityObject->info("Guide tree        file created:   [%s]",
         [1854]          [ 518]         //                              phylipName->c_str());
         [1855]          [ 519]     }
       [Marcador de problema] line 2780: 'AW:'
         [2777]     else if (outputPhylip)
         [2778]        [line 433]
         [2779]     else if (outputNexus)
         [2780]     -> Referências importantes (com snippet):
         [2781]        [Marcador de problema] line 35: 'FIXME'
         [2782]          [  32]
         [2783]          [  33] UserParameters::UserParameters(bool log)
       [Marcador de problema] line 2815: 'AW:'
         [2812]          [ 293]  */
         [2813]   |- Stats.h
         [2814]     -> Found 12 function(s):
         [2815]        [line 2]  Author: Andreas Wilm
         [2816]  *
         [2817]  * Copyright (c)
         [2818]        [line 26]
       [Marcador de problema] line 2819: 'AW:'
         [2816]  *
         [2817]  * Copyright (c)
         [2818]        [line 26]
         [2819] 
         [2820]     void setStatsFile(string f)
         [2821]        [line 28]
         [2822]     string getStatsFile()
       [Marcador de problema] line 2823: 'AW:'
         [2820]     void setStatsFile(string f)
         [2821]        [line 28]
         [2822]     string getStatsFile()
         [2823]        [line 29]
         [2824] 
         [2825]     void setEnabled(bool b)
         [2826]        [line 31]
       [Marcador de problema] line 3682: 'AW:'
         [3679]  *
         [3680]  * Copyright (c)
         [3681]   |- Utility.h
         [3682]     -> Found 30 function(s):
         [3683]        [line 2]  Author: Mark Larkin
         [3684]  *
         [3685]  * Copyright (c)
       [Marcador de problema] line 3686: 'AW:'
         [3683]        [line 2]  Author: Mark Larkin
         [3684]  *
         [3685]  * Copyright (c)
         [3686]        [line 22]
         [3687]     public:
         [3688]         Utility()
         [3689]        [line 24]
       [Marcador de problema] line 3922: 'AW:'
         [3919]        [line 1198]  Andreas Wilm (UCD)
         [3920]        [line 1199]  this convert nonarg params to lowercase (-QuIcKtReE etc)
         [3921]        [line 1240]  Andreas Wilm (UCD)
         [3922]        [line 1245]  UNIX
         [3923]                  * else if (cmdLinePara[match[i]].type != FILARG && (*paramArg)
         [3924]        [line 1250]  else if (cmdLinePara[match[i]].type != FILARG && (*paramArg)
         [3925]        [line 1253]  lowercase arg if not a filename to support mixed case
       [Marcador de problema] line 4144: 'AW:'
         [4141]          [1120]         name1 = true;
         [4142]        [Marcador de problema] line 1145: 'AW:'
         [4143]          [1142]     num = i;
         [4144]          [1143]
         [4145]          [1144]
         [4146]          [1145]     // AW:
         [4147]          [1146]     // params are now setup
       [Marcador de problema] line 4148: 'AW:'
         [4145]          [1144]
         [4146]          [1145]     // AW:
         [4147]          [1146]     // params are now setup
         [4148]          [1147]     // extract paramArgs in next step
         [4149]          [1148]
         [4150]        [Marcador de problema] line 1536: 'AW:'
         [4151]          [1533]                     userParameters->setOutputFasta(true);
       [Marcador de problema] line 4152: 'AW:'
         [4149]          [1148]
         [4150]        [Marcador de problema] line 1536: 'AW:'
         [4151]          [1533]                     userParameters->setOutputFasta(true);
         [4152]          [1534]                     break;
         [4153]          [1535]                 default:
         [4154]          [1536]                     // FIXME AW: 1.83 behaves the same, but shouldnt
         [4155]          [1537]                     // we exit here?
       [Marcador de problema] line 4156: 'AW:'
         [4153]          [1535]                 default:
         [4154]          [1536]                     // FIXME AW: 1.83 behaves the same, but shouldnt
         [4155]          [1537]                     // we exit here?
         [4156]          [1538]                     cout << "\nUnknown OUTPUT type: " << (*paramArg)[setOutput] << endl;
         [4157]          [1539]             }
         [4158]   |- InteractiveMenu.cpp
         [4159]     -> Found 16 function(s):
       [Marcador de problema] line 4160: 'AW:'
         [4157]          [1539]             }
         [4158]   |- InteractiveMenu.cpp
         [4159]     -> Found 16 function(s):
         [4160]        [line 2]  Author: Mark Larkin
         [4161]  *
         [4162]  * Copyright (c)
         [4163]        [line 33]  new Clustal()
       [Marcador de problema] line 4164: 'AW:'
         [4161]  *
         [4162]  * Copyright (c)
         [4163]        [line 33]  new Clustal()
         [4164]        [line 178]
         [4165]         else if(userParameters->getDoRemoveFirstIteration()
         [4166]        [line 248]
         [4167] 
       [Marcador de problema] line 4168: 'AW:'
         [4165]         else if(userParameters->getDoRemoveFirstIteration()
         [4166]        [line 248]
         [4167] 
         [4168]             default:
         [4169]                 fprintf(stdout, "\n\nUnrecognised Command\n\n")
         [4170]        [line 718]  Create alignment output file(s)
         [4171]        [line 803]  fixed << setprecision(2)
       [Marcador de problema] line 5626: 'AW:'
         [5623]          [  50]  */
         [5624]   |- InFileStream.cpp
         [5625]     -> Found 7 function(s):
         [5626]        [line 2]  Author: Nigel Brown
         [5627]  *
         [5628]  * Copyright (c)
         [5629]        [line 8]  This is then used by the getline()
       [Marcador de problema] line 5630: 'AW:'
         [5627]  *
         [5628]  * Copyright (c)
         [5629]        [line 8]  This is then used by the getline()
         [5630]        [line 66]  but for symmetry to open()
         [5631]        [line 109]  for CR or LF or CRLF (or LFCR)
         [5632]        [line 114]
         [5633]             else if (c == LF)
       [Marcador de problema] line 5634: 'AW:'
         [5631]        [line 109]  for CR or LF or CRLF (or LFCR)
         [5632]        [line 114]
         [5633]             else if (c == LF)
         [5634]        [line 116]
         [5635]             else if (type)
         [5636]        [line 137]  is UNIX (default)
         [5637]   |- ClustalFileParser.cpp
       [Marcador de problema] line 5761: 'AW:'
         [5758]          [ 138]         }
         [5759]   |- MSFFileParser.h
         [5760]     -> Found 5 function(s):
         [5761]        [line 2]  Author: Mark Larkin
         [5762]  *
         [5763]  * Copyright (c)
         [5764]        [line 19]
       [Marcador de problema] line 5765: 'AW:'
         [5762]  *
         [5763]  * Copyright (c)
         [5764]        [line 19]
         [5765]         virtual Sequence getSeq(int seqNum)
         [5766]        [line 20]
         [5767]         virtual vector<Sequence> getSeqRange(int firstSeq, int num)
         [5768]        [line 21]
       [Marcador de problema] line 5769: 'AW:'
         [5766]        [line 20]
         [5767]         virtual vector<Sequence> getSeqRange(int firstSeq, int num)
         [5768]        [line 21]
         [5769]         virtual int countSeqs()
         [5770]        [line 22]
         [5771]         virtual void getSecStructure(vector<char>& gapPenaltyMask,
         [5772]                                      vector<char>& secStructMask, string& secStructName,
       [Marcador de problema] line 5801: 'AW:'
         [5798] 
         [5799]             if (structPenalties != NONE)
         [5800]        [line 352]
         [5801]         else if(code == NOSEQUENCESINFILE)
         [5802]        [line 374]  Clear old info
         [5803] 
         [5804]             if (structPenalties != NONE)
       [Marcador de problema] line 5848: 'AW:'
         [5845]          [ 221]
         [5846] 
         [5847] === Execução do 'make' ===
         [5848] 
         [5849] Código de retorno do 'make': 2
         [5850] 
         [5851] >> RAW MAKE OUTPUT <<
       [Marcador de problema] line 5852: 'AW:'
         [5849] Código de retorno do 'make': 2
         [5850] 
         [5851] >> RAW MAKE OUTPUT <<
         [5852] 
         [5853] Making all in m4
         [5854] make[1]: Entering directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/m4'
         [5855] make[1]: Nothing to be done for 'all'.
       [Marcador de problema] line 5856: 'AW:'
         [5853] Making all in m4
         [5854] make[1]: Entering directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/m4'
         [5855] make[1]: Nothing to be done for 'all'.
         [5856] make[1]: Leaving directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/m4'
         [5857] Making all in src
         [5858] make[1]: Entering directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/src'
         [5859] make  all-recursive
  |- stamp-h1
  |- Makefile.am
  |- intltool-update.in
  |- configure~
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 718: 'NVCCFLAGS'
         [ 715] CUDA_CFLAGS
         [ 716] CUDA_LIBS
         [ 717] NVCC
         [ 718] NVCCFLAGS
         [ 719] RANLIB
         [ 720] CPP
         [ 721] GREP
       [CUDA Arch / Flags] line 4176: 'NVCCFLAGS'
         [4173]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [4174]     NVCC="nvcc"
         [4175] fi
         [4176] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [4177] 
         [4178] 
         [4179] 
       [CUDA Arch / Flags] line 4176: 'arch=sm_86'
         [4173]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [4174]     NVCC="nvcc"
         [4175] fi
         [4176] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [4177] 
         [4178] 
         [4179] 
       [CUDA Arch / Flags] line 6657: 'NVCCFLAGS'
         [6654] CUDA_CFLAGS!$CUDA_CFLAGS$ac_delim
         [6655] CUDA_LIBS!$CUDA_LIBS$ac_delim
         [6656] NVCC!$NVCC$ac_delim
         [6657] NVCCFLAGS!$NVCCFLAGS$ac_delim
         [6658] RANLIB!$RANLIB$ac_delim
         [6659] CPP!$CPP$ac_delim
         [6660] GREP!$GREP$ac_delim
       [CUDA Arch / Flags] line 6657: 'NVCCFLAGS'
         [6654] CUDA_CFLAGS!$CUDA_CFLAGS$ac_delim
         [6655] CUDA_LIBS!$CUDA_LIBS$ac_delim
         [6656] NVCC!$NVCC$ac_delim
         [6657] NVCCFLAGS!$NVCCFLAGS$ac_delim
         [6658] RANLIB!$RANLIB$ac_delim
         [6659] CPP!$CPP$ac_delim
         [6660] GREP!$GREP$ac_delim
       [Marcador de problema] line 1107: 'FIXME'
         [1104]     export $ac_envvar ;;
         [1105] 
         [1106]   *)
         [1107]     # FIXME: should be removed in autoconf 3.0.
         [1108]     echo "$as_me: WARNING: you should use --build, --host, --target" >&2
         [1109]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [1110]       echo "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 1140: 'FIXME'
         [1137] 
         [1138] # There might be people who depend on the old broken behavior: `$host'
         [1139] # used to hold the argument of --host etc.
         [1140] # FIXME: To remove some day.
         [1141] build=$build_alias
         [1142] host=$host_alias
         [1143] target=$target_alias
       [Marcador de problema] line 1145: 'FIXME'
         [1142] host=$host_alias
         [1143] target=$target_alias
         [1144] 
         [1145] # FIXME: To remove some day.
         [1146] if test "x$host_alias" != x; then
         [1147]   if test "x$build_alias" = x; then
         [1148]     cross_compiling=maybe
       [Marcador de problema] line 2942: 'FIXME'
         [2939] # the compiler is broken, or we cross compile.
         [2940] { echo "$as_me:$LINENO: checking whether the C compiler works" >&5
         [2941] echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6; }
         [2942] # FIXME: These cross compiler hacks should be removed for Autoconf 3.0
         [2943] # If not cross compiling, check that we can run a simple program.
         [2944] if test "$cross_compiling" != yes; then
         [2945]   if { ac_try='./$ac_file'
       [Marcador de problema] line 5210: 'FIXME'
         [5207] int
         [5208] main ()
         [5209] {
         [5210] /* FIXME: Include the comments suggested by Paul. */
         [5211] #ifndef __cplusplus
         [5212]   /* Ultrix mips cc rejects this.  */
         [5213]   typedef int charset[2];
       [Marcador de problema] line 6902: 'FIXME'
         [6899] 
         [6900] cat >>$CONFIG_STATUS <<\_ACEOF
         [6901] # If the template does not know about datarootdir, expand it.
         [6902] # FIXME: This hack should be removed a few years after 2.60.
         [6903] ac_datarootdir_hack=; ac_datarootdir_seen=
         [6904] 
         [6905] case `sed -n '/datarootdir/ {
       [Marcador de problema] line 6933: 'FIXME'
         [6930] 
         [6931] # Neutralize VPATH when `$srcdir' = `.'.
         [6932] # Shell code in configure.ac might set extrasub.
         [6933] # FIXME: do we really want to maintain this feature?
         [6934] cat >>$CONFIG_STATUS <<_ACEOF
         [6935]   sed "$ac_vpsub
         [6936] $extrasub
  |- config.status
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 620: 'NVCCFLAGS'
         [ 617] S["EGREP"]="/usr/bin/grep -E"
         [ 618] S["GREP"]="/usr/bin/grep"
         [ 619] S["RANLIB"]="ranlib"
         [ 620] S["NVCCFLAGS"]="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 621] S["NVCC"]="nvcc"
         [ 622] S["CUDA_LIBS"]="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 623] S["CUDA_CFLAGS"]="-I/usr/local/cuda/include"
       [CUDA Arch / Flags] line 620: 'arch=sm_86'
         [ 617] S["EGREP"]="/usr/bin/grep -E"
         [ 618] S["GREP"]="/usr/bin/grep"
         [ 619] S["RANLIB"]="ranlib"
         [ 620] S["NVCCFLAGS"]="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [ 621] S["NVCC"]="nvcc"
         [ 622] S["CUDA_LIBS"]="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [ 623] S["CUDA_CFLAGS"]="-I/usr/local/cuda/include"
       [Marcador de problema] line 1124: 'TODO'
         [1121]   # Older Autoconf quotes --file arguments for eval, but not when files
         [1122]   # are listed without --file.  Let's play safe and only enable the eval
         [1123]   # if we detect the quoting.
         [1124]   # TODO: see whether this extra hack can be removed once we start
         [1125]   # requiring Autoconf 2.70 or later.
         [1126]   case $CONFIG_FILES in #(
         [1127]   *\'*) :
       [Marcador de problema] line 977: 'FIXME'
         [ 974]   */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
         [ 975]   esac
         [ 976] # If the template does not know about datarootdir, expand it.
         [ 977] # FIXME: This hack should be removed a few years after 2.60.
         [ 978] ac_datarootdir_hack=; ac_datarootdir_seen=
         [ 979] ac_sed_dataroot='
         [ 980] /datarootdir/ {
  |- config.log
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 569: 'NVCCFLAGS'
         [ 566] MAKEINFO='${SHELL} '\''/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing'\'' makeinfo'
         [ 567] MKDIR_P='/usr/bin/mkdir -p'
         [ 568] NVCC='nvcc'
         [ 569] NVCCFLAGS='-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp '
         [ 570] OBJEXT='o'
         [ 571] PACKAGE='clustalw'
         [ 572] PACKAGE_BUGREPORT='clustalw@ucd.ie'
       [CUDA Arch / Flags] line 569: 'arch=sm_86'
         [ 566] MAKEINFO='${SHELL} '\''/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing'\'' makeinfo'
         [ 567] MKDIR_P='/usr/bin/mkdir -p'
         [ 568] NVCC='nvcc'
         [ 569] NVCCFLAGS='-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp '
         [ 570] OBJEXT='o'
         [ 571] PACKAGE='clustalw'
         [ 572] PACKAGE_BUGREPORT='clustalw@ucd.ie'
  |- aclocal.m4
    -> Referências importantes (com snippet):
       [Marcador de problema] line 348: 'TODO'
         [ 345]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 346]   # are listed without --file.  Let's play safe and only enable the eval
         [ 347]   # if we detect the quoting.
         [ 348]   # TODO: see whether this extra hack can be removed once we start
         [ 349]   # requiring Autoconf 2.70 or later.
         [ 350]   AS_CASE([$CONFIG_FILES],
         [ 351]           [*\'*], [eval set x "$CONFIG_FILES"],
       [Marcador de problema] line 831: 'FIXME'
         [ 828]   unset am_i])
         [ 829] if test "$am_cv_prog_cc_c_o" != yes; then
         [ 830]    # Losing compiler, so override with the script.
         [ 831]    # FIXME: It is wrong to rewrite CC.
         [ 832]    # But if we don't then we get into trouble of one sort or another.
         [ 833]    # A longer-term fix would be to have automake use am__CC in this case,
         [ 834]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"

[DIRECTORY] m4
  |- Makefile.in
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 195: 'NVCCFLAGS'
         [ 192] MAKEINFO = @MAKEINFO@
         [ 193] MKDIR_P = @MKDIR_P@
         [ 194] NVCC = @NVCC@
         [ 195] NVCCFLAGS = @NVCCFLAGS@
         [ 196] OBJEXT = @OBJEXT@
         [ 197] PACKAGE = @PACKAGE@
         [ 198] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 195: 'NVCCFLAGS'
         [ 192] MAKEINFO = @MAKEINFO@
         [ 193] MKDIR_P = @MKDIR_P@
         [ 194] NVCC = @NVCC@
         [ 195] NVCCFLAGS = @NVCCFLAGS@
         [ 196] OBJEXT = @OBJEXT@
         [ 197] PACKAGE = @PACKAGE@
         [ 198] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
  |- Makefile
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 195: 'NVCCFLAGS'
         [ 192] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 193] MKDIR_P = /usr/bin/mkdir -p
         [ 194] NVCC = nvcc
         [ 195] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 196] OBJEXT = o
         [ 197] PACKAGE = clustalw
         [ 198] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 195: 'arch=sm_86'
         [ 192] MAKEINFO = ${SHELL} '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/missing' makeinfo
         [ 193] MKDIR_P = /usr/bin/mkdir -p
         [ 194] NVCC = nvcc
         [ 195] NVCCFLAGS = -arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp
         [ 196] OBJEXT = o
         [ 197] PACKAGE = clustalw
         [ 198] PACKAGE_BUGREPORT = clustalw@ucd.ie
  |- Makefile.am

[DIRECTORY] autom4te.cache
  |- output.0
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 658: 'NVCCFLAGS'
         [ 655] EGREP
         [ 656] GREP
         [ 657] RANLIB
         [ 658] NVCCFLAGS
         [ 659] NVCC
         [ 660] CUDA_LIBS
         [ 661] CUDA_CFLAGS
       [CUDA Arch / Flags] line 5464: 'NVCCFLAGS'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [CUDA Arch / Flags] line 5464: 'arch=sm_86'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [Marcador de problema] line 7486: 'TODO'
         [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [7485]   # if we detect the quoting.
         [7486]   # TODO: see whether this extra hack can be removed once we start
         [7487]   # requiring Autoconf 2.70 or later.
         [7488]   case $CONFIG_FILES in @%:@(
         [7489]   *\'*) :
       [Marcador de problema] line 1199: 'FIXME'
         [1196]     export $ac_envvar ;;
         [1197] 
         [1198]   *)
         [1199]     # FIXME: should be removed in autoconf 3.0.
         [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 1245: 'FIXME'
         [1242] 
         [1243] # There might be people who depend on the old broken behavior: `$host'
         [1244] # used to hold the argument of --host etc.
         [1245] # FIXME: To remove some day.
         [1246] build=$build_alias
         [1247] host=$host_alias
         [1248] target=$target_alias
       [Marcador de problema] line 1250: 'FIXME'
         [1247] host=$host_alias
         [1248] target=$target_alias
         [1249] 
         [1250] # FIXME: To remove some day.
         [1251] if test "x$host_alias" != x; then
         [1252]   if test "x$build_alias" = x; then
         [1253]     cross_compiling=maybe
       [Marcador de problema] line 4654: 'FIXME'
         [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [4653]    # Losing compiler, so override with the script.
         [4654]    # FIXME: It is wrong to rewrite CC.
         [4655]    # But if we don't then we get into trouble of one sort or another.
         [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
       [Marcador de problema] line 7344: 'FIXME'
         [7341] 
         [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [7343] # If the template does not know about datarootdir, expand it.
         [7344] # FIXME: This hack should be removed a few years after 2.60.
         [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [7346] ac_sed_dataroot='
         [7347] /datarootdir/ {
       [Marcador de problema] line 7375: 'FIXME'
         [7372] 
         [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [7374] # Shell code in configure.ac might set extrasub.
         [7375] # FIXME: do we really want to maintain this feature?
         [7376] cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
         [7377] ac_sed_extra="$ac_vpsub
         [7378] $extrasub
  |- traces.0
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 992: 'NVCCFLAGS'
         [ 989] m4trace:configure.ac:117: -1- m4_pattern_allow([^CUDA_CFLAGS$])
         [ 990] m4trace:configure.ac:118: -1- m4_pattern_allow([^CUDA_LIBS$])
         [ 991] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 992] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 993] m4trace:configure.ac:129: -1- m4_pattern_allow([^RANLIB$])
         [ 994] m4trace:configure.ac:136: -1- _m4_warn([obsolete], [The macro `AC_HEADER_STDC' is obsolete.
         [ 995] You should run autoupdate.], [./lib/autoconf/headers.m4:704: AC_HEADER_STDC is expanded from...
       [Marcador de problema] line 190: 'TODO'
         [ 187]   # Older Autoconf quotes --file arguments for eval, but not when files
         [ 188]   # are listed without --file.  Let's play safe and only enable the eval
         [ 189]   # if we detect the quoting.
         [ 190]   # TODO: see whether this extra hack can be removed once we start
         [ 191]   # requiring Autoconf 2.70 or later.
         [ 192]   AS_CASE([$CONFIG_FILES],
         [ 193]           [*\'*], [eval set x "$CONFIG_FILES"],
       [Marcador de problema] line 513: 'FIXME'
         [ 510]   unset am_i])
         [ 511] if test "$am_cv_prog_cc_c_o" != yes; then
         [ 512]    # Losing compiler, so override with the script.
         [ 513]    # FIXME: It is wrong to rewrite CC.
         [ 514]    # But if we don't then we get into trouble of one sort or another.
         [ 515]    # A longer-term fix would be to have automake use am__CC in this case,
         [ 516]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
  |- traces.4t
  |- traces.2
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 478: 'NVCCFLAGS'
         [ 475] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
         [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
       [CUDA Arch / Flags] line 479: 'NVCCFLAGS'
         [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
       [CUDA Arch / Flags] line 480: 'NVCCFLAGS'
         [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
         [ 483] m4trace:configure.ac:129: -1- m4_pattern_allow([^RANLIB$])
  |- output.2
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 658: 'NVCCFLAGS'
         [ 655] EGREP
         [ 656] GREP
         [ 657] RANLIB
         [ 658] NVCCFLAGS
         [ 659] NVCC
         [ 660] CUDA_LIBS
         [ 661] CUDA_CFLAGS
       [CUDA Arch / Flags] line 5464: 'NVCCFLAGS'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [CUDA Arch / Flags] line 5464: 'arch=sm_86'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [Marcador de problema] line 7486: 'TODO'
         [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [7485]   # if we detect the quoting.
         [7486]   # TODO: see whether this extra hack can be removed once we start
         [7487]   # requiring Autoconf 2.70 or later.
         [7488]   case $CONFIG_FILES in @%:@(
         [7489]   *\'*) :
       [Marcador de problema] line 1199: 'FIXME'
         [1196]     export $ac_envvar ;;
         [1197] 
         [1198]   *)
         [1199]     # FIXME: should be removed in autoconf 3.0.
         [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 1245: 'FIXME'
         [1242] 
         [1243] # There might be people who depend on the old broken behavior: `$host'
         [1244] # used to hold the argument of --host etc.
         [1245] # FIXME: To remove some day.
         [1246] build=$build_alias
         [1247] host=$host_alias
         [1248] target=$target_alias
       [Marcador de problema] line 1250: 'FIXME'
         [1247] host=$host_alias
         [1248] target=$target_alias
         [1249] 
         [1250] # FIXME: To remove some day.
         [1251] if test "x$host_alias" != x; then
         [1252]   if test "x$build_alias" = x; then
         [1253]     cross_compiling=maybe
       [Marcador de problema] line 4654: 'FIXME'
         [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [4653]    # Losing compiler, so override with the script.
         [4654]    # FIXME: It is wrong to rewrite CC.
         [4655]    # But if we don't then we get into trouble of one sort or another.
         [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
       [Marcador de problema] line 7344: 'FIXME'
         [7341] 
         [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [7343] # If the template does not know about datarootdir, expand it.
         [7344] # FIXME: This hack should be removed a few years after 2.60.
         [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [7346] ac_sed_dataroot='
         [7347] /datarootdir/ {
       [Marcador de problema] line 7375: 'FIXME'
         [7372] 
         [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [7374] # Shell code in configure.ac might set extrasub.
         [7375] # FIXME: do we really want to maintain this feature?
         [7376] cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
         [7377] ac_sed_extra="$ac_vpsub
         [7378] $extrasub
  |- output.3
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 313: 'NVCCFLAGS'
         [ 310] # include <unistd.h>
         [ 311] #endif"
         [ 312] 
         [ 313] ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CLUSTALW_VERSION CLUSTALW_NAME INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CXX CXXFLAGS ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE noopenmp noopenmp_TRUE noopenmp_FALSE CUDA_CFLAGS CUDA_LIBS NVCC NVCCFLAGS RANLIB ac_ct_RANLIB CPP EGREP LIB@&t@OBJS LTLIBOBJS'
         [ 314] ac_subst_files=''
         [ 315] 
         [ 316] # Initialize some variables set by options.
       [CUDA Arch / Flags] line 3660: 'NVCCFLAGS'
         [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [3658]     NVCC="nvcc"
         [3659] fi
         [3660] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [3661] 
         [3662] 
         [3663] 
       [CUDA Arch / Flags] line 3660: 'arch=sm_86'
         [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [3658]     NVCC="nvcc"
         [3659] fi
         [3660] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [3661] 
         [3662] 
         [3663] 
       [CUDA Arch / Flags] line 5872: 'NVCCFLAGS'
         [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [5871] s,@NVCC@,$NVCC,;t t
         [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [5873] s,@RANLIB@,$RANLIB,;t t
         [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [5875] s,@CPP@,$CPP,;t t
       [CUDA Arch / Flags] line 5872: 'NVCCFLAGS'
         [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [5871] s,@NVCC@,$NVCC,;t t
         [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [5873] s,@RANLIB@,$RANLIB,;t t
         [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [5875] s,@CPP@,$CPP,;t t
       [Marcador de problema] line 643: 'FIXME'
         [ 640]     export $ac_envvar ;;
         [ 641] 
         [ 642]   *)
         [ 643]     # FIXME: should be removed in autoconf 3.0.
         [ 644]     echo "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 645]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 646]       echo "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 684: 'FIXME'
         [ 681] 
         [ 682] # There might be people who depend on the old broken behavior: `$host'
         [ 683] # used to hold the argument of --host etc.
         [ 684] # FIXME: To remove some day.
         [ 685] build=$build_alias
         [ 686] host=$host_alias
         [ 687] target=$target_alias
       [Marcador de problema] line 689: 'FIXME'
         [ 686] host=$host_alias
         [ 687] target=$target_alias
         [ 688] 
         [ 689] # FIXME: To remove some day.
         [ 690] if test "x$host_alias" != x; then
         [ 691]   if test "x$build_alias" = x; then
         [ 692]     cross_compiling=maybe
       [Marcador de problema] line 2347: 'FIXME'
         [2344] 	break;;
         [2345]     *.* )
         [2346] 	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
         [2347] 	# FIXME: I believe we export ac_cv_exeext for Libtool,
         [2348] 	# but it would be cool to find out if it's true.  Does anybody
         [2349] 	# maintain Libtool? --akim.
         [2350] 	export ac_cv_exeext
       [Marcador de problema] line 2375: 'FIXME'
         [2372] # the compiler is broken, or we cross compile.
         [2373] echo "$as_me:$LINENO: checking whether the C compiler works" >&5
         [2374] echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
         [2375] # FIXME: These cross compiler hacks should be removed for Autoconf 3.0
         [2376] # If not cross compiling, check that we can run a simple program.
         [2377] if test "$cross_compiling" != yes; then
         [2378]   if { ac_try='./$ac_file'
       [Marcador de problema] line 4501: 'FIXME'
         [4498] int
         [4499] main ()
         [4500] {
         [4501] /* FIXME: Include the comments suggested by Paul. */
         [4502] #ifndef __cplusplus
         [4503]   /* Ultrix mips cc rejects this.  */
         [4504]   typedef int charset[2];
  |- traces.3
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 179: 'NVCCFLAGS'
         [ 176] m4trace:configure.ac:117: -1- AC_SUBST([CUDA_CFLAGS])
         [ 177] m4trace:configure.ac:118: -1- AC_SUBST([CUDA_LIBS])
         [ 178] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
         [ 179] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 180] m4trace:configure.ac:129: -1- AC_PROG_RANLIB
         [ 181] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 182] m4trace:configure.ac:129: -1- AC_SUBST([ac_ct_RANLIB])
  |- requests
  |- output.4t
  |- output.1
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 658: 'NVCCFLAGS'
         [ 655] EGREP
         [ 656] GREP
         [ 657] RANLIB
         [ 658] NVCCFLAGS
         [ 659] NVCC
         [ 660] CUDA_LIBS
         [ 661] CUDA_CFLAGS
       [CUDA Arch / Flags] line 5464: 'NVCCFLAGS'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [CUDA Arch / Flags] line 5464: 'arch=sm_86'
         [5461]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [5462]     NVCC="nvcc"
         [5463] fi
         [5464] NVCCFLAGS="-arch=sm_86 -use_fast_math  -Xptxas -v -Xcompiler -fopenmp "
         [5465] 
         [5466] 
         [5467] 
       [Marcador de problema] line 7486: 'TODO'
         [7483]   # Older Autoconf quotes --file arguments for eval, but not when files
         [7484]   # are listed without --file.  Let's play safe and only enable the eval
         [7485]   # if we detect the quoting.
         [7486]   # TODO: see whether this extra hack can be removed once we start
         [7487]   # requiring Autoconf 2.70 or later.
         [7488]   case $CONFIG_FILES in @%:@(
         [7489]   *\'*) :
       [Marcador de problema] line 1199: 'FIXME'
         [1196]     export $ac_envvar ;;
         [1197] 
         [1198]   *)
         [1199]     # FIXME: should be removed in autoconf 3.0.
         [1200]     printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
         [1201]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [1202]       printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 1245: 'FIXME'
         [1242] 
         [1243] # There might be people who depend on the old broken behavior: `$host'
         [1244] # used to hold the argument of --host etc.
         [1245] # FIXME: To remove some day.
         [1246] build=$build_alias
         [1247] host=$host_alias
         [1248] target=$target_alias
       [Marcador de problema] line 1250: 'FIXME'
         [1247] host=$host_alias
         [1248] target=$target_alias
         [1249] 
         [1250] # FIXME: To remove some day.
         [1251] if test "x$host_alias" != x; then
         [1252]   if test "x$build_alias" = x; then
         [1253]     cross_compiling=maybe
       [Marcador de problema] line 4654: 'FIXME'
         [4651] printf "%s\n" "$am_cv_prog_cc_c_o" >&6; }
         [4652] if test "$am_cv_prog_cc_c_o" != yes; then
         [4653]    # Losing compiler, so override with the script.
         [4654]    # FIXME: It is wrong to rewrite CC.
         [4655]    # But if we don't then we get into trouble of one sort or another.
         [4656]    # A longer-term fix would be to have automake use am__CC in this case,
         [4657]    # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
       [Marcador de problema] line 7344: 'FIXME'
         [7341] 
         [7342] cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
         [7343] # If the template does not know about datarootdir, expand it.
         [7344] # FIXME: This hack should be removed a few years after 2.60.
         [7345] ac_datarootdir_hack=; ac_datarootdir_seen=
         [7346] ac_sed_dataroot='
         [7347] /datarootdir/ {
       [Marcador de problema] line 7375: 'FIXME'
         [7372] 
         [7373] # Neutralize VPATH when `$srcdir' = `.'.
         [7374] # Shell code in configure.ac might set extrasub.
         [7375] # FIXME: do we really want to maintain this feature?
         [7376] cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
         [7377] ac_sed_extra="$ac_vpsub
         [7378] $extrasub
  |- output.4
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 313: 'NVCCFLAGS'
         [ 310] # include <unistd.h>
         [ 311] #endif"
         [ 312] 
         [ 313] ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CLUSTALW_VERSION CLUSTALW_NAME INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CXX CXXFLAGS ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE noopenmp noopenmp_TRUE noopenmp_FALSE CUDA_CFLAGS CUDA_LIBS NVCC NVCCFLAGS RANLIB ac_ct_RANLIB CPP EGREP LIB@&t@OBJS LTLIBOBJS'
         [ 314] ac_subst_files=''
         [ 315] 
         [ 316] # Initialize some variables set by options.
       [CUDA Arch / Flags] line 3660: 'NVCCFLAGS'
         [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [3658]     NVCC="nvcc"
         [3659] fi
         [3660] NVCCFLAGS="-use_fast_math -arch=sm_86  -Xptxas -v -Xcompiler -fopenmp "
         [3661] 
         [3662] 
         [3663] 
       [CUDA Arch / Flags] line 3660: 'arch=sm_86'
         [3657]     CUDA_LIBS="-L/usr/local/cuda/lib64 -lcuda -lcudart "
         [3658]     NVCC="nvcc"
         [3659] fi
         [3660] NVCCFLAGS="-use_fast_math -arch=sm_86  -Xptxas -v -Xcompiler -fopenmp "
         [3661] 
         [3662] 
         [3663] 
       [CUDA Arch / Flags] line 5872: 'NVCCFLAGS'
         [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [5871] s,@NVCC@,$NVCC,;t t
         [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [5873] s,@RANLIB@,$RANLIB,;t t
         [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [5875] s,@CPP@,$CPP,;t t
       [CUDA Arch / Flags] line 5872: 'NVCCFLAGS'
         [5869] s,@CUDA_CFLAGS@,$CUDA_CFLAGS,;t t
         [5870] s,@CUDA_LIBS@,$CUDA_LIBS,;t t
         [5871] s,@NVCC@,$NVCC,;t t
         [5872] s,@NVCCFLAGS@,$NVCCFLAGS,;t t
         [5873] s,@RANLIB@,$RANLIB,;t t
         [5874] s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
         [5875] s,@CPP@,$CPP,;t t
       [Marcador de problema] line 643: 'FIXME'
         [ 640]     export $ac_envvar ;;
         [ 641] 
         [ 642]   *)
         [ 643]     # FIXME: should be removed in autoconf 3.0.
         [ 644]     echo "$as_me: WARNING: you should use --build, --host, --target" >&2
         [ 645]     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
         [ 646]       echo "$as_me: WARNING: invalid host type: $ac_option" >&2
       [Marcador de problema] line 684: 'FIXME'
         [ 681] 
         [ 682] # There might be people who depend on the old broken behavior: `$host'
         [ 683] # used to hold the argument of --host etc.
         [ 684] # FIXME: To remove some day.
         [ 685] build=$build_alias
         [ 686] host=$host_alias
         [ 687] target=$target_alias
       [Marcador de problema] line 689: 'FIXME'
         [ 686] host=$host_alias
         [ 687] target=$target_alias
         [ 688] 
         [ 689] # FIXME: To remove some day.
         [ 690] if test "x$host_alias" != x; then
         [ 691]   if test "x$build_alias" = x; then
         [ 692]     cross_compiling=maybe
       [Marcador de problema] line 2347: 'FIXME'
         [2344] 	break;;
         [2345]     *.* )
         [2346] 	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
         [2347] 	# FIXME: I believe we export ac_cv_exeext for Libtool,
         [2348] 	# but it would be cool to find out if it's true.  Does anybody
         [2349] 	# maintain Libtool? --akim.
         [2350] 	export ac_cv_exeext
       [Marcador de problema] line 2375: 'FIXME'
         [2372] # the compiler is broken, or we cross compile.
         [2373] echo "$as_me:$LINENO: checking whether the C compiler works" >&5
         [2374] echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
         [2375] # FIXME: These cross compiler hacks should be removed for Autoconf 3.0
         [2376] # If not cross compiling, check that we can run a simple program.
         [2377] if test "$cross_compiling" != yes; then
         [2378]   if { ac_try='./$ac_file'
       [Marcador de problema] line 4501: 'FIXME'
         [4498] int
         [4499] main ()
         [4500] {
         [4501] /* FIXME: Include the comments suggested by Paul. */
         [4502] #ifndef __cplusplus
         [4503]   /* Ultrix mips cc rejects this.  */
         [4504]   typedef int charset[2];
  |- traces.4
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 177: 'NVCCFLAGS'
         [ 174] m4trace:configure.ac:117: -1- AC_SUBST([CUDA_CFLAGS])
         [ 175] m4trace:configure.ac:118: -1- AC_SUBST([CUDA_LIBS])
         [ 176] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
         [ 177] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 178] m4trace:configure.ac:129: -1- AC_PROG_RANLIB
         [ 179] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 180] m4trace:configure.ac:129: -1- AC_SUBST([ac_ct_RANLIB])
  |- traces.1
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 478: 'NVCCFLAGS'
         [ 475] m4trace:configure.ac:119: -1- AC_SUBST([NVCC])
         [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
       [CUDA Arch / Flags] line 479: 'NVCCFLAGS'
         [ 476] m4trace:configure.ac:119: -1- AC_SUBST_TRACE([NVCC])
         [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
       [CUDA Arch / Flags] line 480: 'NVCCFLAGS'
         [ 477] m4trace:configure.ac:119: -1- m4_pattern_allow([^NVCC$])
         [ 478] m4trace:configure.ac:120: -1- AC_SUBST([NVCCFLAGS])
         [ 479] m4trace:configure.ac:120: -1- AC_SUBST_TRACE([NVCCFLAGS])
         [ 480] m4trace:configure.ac:120: -1- m4_pattern_allow([^NVCCFLAGS$])
         [ 481] m4trace:configure.ac:129: -1- AC_SUBST([RANLIB])
         [ 482] m4trace:configure.ac:129: -1- AC_SUBST_TRACE([RANLIB])
         [ 483] m4trace:configure.ac:129: -1- m4_pattern_allow([^RANLIB$])

[DIRECTORY] src
  |- Clustal.o
  |- Clustal.cpp
    -> Found 51 function(s):
       [line 2]  Author: Mark Larkin
 *
 * Copyright (c)
       [line 17]  added call to calculateMaxLengths()
       [line 118] 
    else if(createOutput)
       [line 182]  new FastPairwiseAlign()
       [line 186]  new FullPairwiseAlign()
       [line 199] 
    vector<int> seqWeight(_numSeqs + 1)
       [line 202]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 228]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 236]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 252]  new MSA()
       [line 294]  STEP 4: OUTPUT THE ALIGNMENT 
    if(createOutput)
       [line 374] 
        else if (userParameters->getStructPenalties2()
       [line 440] 
    vector<int> seqWeights(_numSeqs + 1)
       [line 466]  new FastPairwiseAlign()
       [line 470]  new FullPairwiseAlign()
       [line 503]  new MSA()
       [line 639]  new string(treeName)
       [line 667]  new string(treeName)
       [line 689]  new MSA()
       [line 769]  new FastPairwiseAlign()
       [line 773]  new FullPairwiseAlign()
       [line 842]  new string(path)
       [line 851]  new string(answer)
       [line 886]  new FastPairwiseAlign()
       [line 890]  new FullPairwiseAlign()
       [line 901] 
    vector<int> seqWeights(_numSeqs + 1)
       [line 913]  new MSA()
       [line 929]  new string("")
       [line 957]  Andreas Wilm (UCD)
       [line 957]  edited to support new help system (separate
 * file now which is compiled in)
       [line 1125] 
        else if(code == NOSEQUENCESINFILE)
       [line 1129] 
        else if(code == ALLNAMESNOTDIFFERENT)
       [line 1133] 
        else if(code == EMPTYSEQUENCE)
       [line 1137] 
        else if(code == SEQUENCETOOBIG)
       [line 1141] 
        else if(code == BADFORMAT)
       [line 1290] 
        else if (tolower((*mask)
       [line 1399]  STEP 1: Calculate the sequence weights
    QTcalcWeightsForLowScoreSeg(params)
       [line 1423]  STEP 2: Calculate the profile
    LowScoreSegProfile lowScoreProfile(params->nCols, params->firstSeq,
                                       params->firstSeq + params->nSeqs)
       [line 1528]  the cutoff 

    QTremoveShortSegments(params)
       [line 1545]  are temporarily hidden in the display

    for(i = 0; i < params->nSeqs; i++)
       [line 1595] 
    DistMatrix distMat(alignmentObj.getNumSeqs()
       [line 1610]  it again (it takes too long)
       [line 1621]  nSeqs
        for (i = params->firstSeq + 1; i <= params->firstSeq + params->nSeqs; i++)
       [line 1623]  nSeqs
            for (j = i + 1; j <= params->firstSeq + params->nSeqs; j++)
       [line 1676]  the alignment
    if(alignmentObj.getNumSeqs()
       [line 1756] 
    else if(type == Profile1)
       [line 1761] 
    else if(type == Profile2)
       [line 1790]  new string(treeName)
       [line 1800] 
    else if (!userParameters->getMenuFlag()
       [line 1815] 
    else if(type == Profile2)
       [line 1827]  new string("")
  |- clustalw2
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 10213: 'sm_86'
         [10210]       
         [10211]              $	8 > o o ~ 
         [10212]       
         [10213]              bC~ p p 	d 
         [10214]       
         [10215]              L{ p p r m 
         [10216]       
       [CUDA Arch / Flags] line 11865: 'sm_86'
         [11862] ?  _i .  9  /      z b }8  R  X  /   
         [11863] h  cα  l  w  /  }8   ?  d        /   
         [11864] #  e/      /        fa   κ  Ժ  /   
         [11865]   gJ      /     
         [11866] ¯  h   
         [11867]   /   c  i    &  ,  /   
         [11868] r  jX @  K  /     
  |- MyersMillerProfileAlign.o
  |- ProfileStandard.o
  |- NJTree.o
  |- config.h.in~
  |- cudaMultiSeqAlign.o
  |- clustalw_version.h.in
  |- GDEFileParser.o
  |- Tree.o
  |- MSA.o
  |- Help.cpp
    -> Found 58 function(s):
       [line 2]  Author: Andreas Wilm
 *
 * Copyright (c)
       [line 8]  Andreas Wilm (UCD)
       [line 84]  help for CLUSTAL W (" + version + ")
       [line 91]  which is used to indicate a GAP (\".\" in MSF-RSF)
       [line 102]  can be calculated from old alignments (read in\n"
"with \"-\" characters to indicate gaps)
       [line 115]  at the start of the file (the token for the entry name field)
       [line 144]  alignments are carried out in 3 stages (automatically done from menu\n"
"item 1 ...Do complete multiple alignments now)
       [line 147]  all sequences are compared to each other (pairwise alignments)
       [line 149]  a dendrogram (like a phylogenetic tree)
       [line 150]  groupings of the sequences by similarity (stored in a file)
       [line 172]  can skip the first stages (pairwise alignments; dendrogram)
       [line 173]  dendrogram file (menu item 3)
       [line 174]  no final multiple alignment (menu item 2)
       [line 178]  alignment formats (CLUSTAL, GCG, NBRF-PIR, PHYLIP, GDE, NEXUS, and FASTA)
       [line 189]  methods: dynamic programming (slow but accurate)
       [line 214]  only exactly matching fragments (k-tuples)
       [line 219]  for speed (max= 2 for proteins; 4 for DNA)
       [line 220]  longer sequences (e.g. >1000 residues)
       [line 225]  matches on each diagonal (in an imaginary\n"
"dot-matrix plot)
       [line 226]   Only the best ones (with most matches)
       [line 261]  The TRANSITION WEIGHT gives transitions (A <--> G or C <--> T \n"
"i.e. purine-purine or pyrimidine-pyrimidine substitutions)
       [line 276]  DNA WEIGHT MATRIX leads to a new menu where a single matrix (not a series)
       [line 312]  avoiding gaps that are too close (set by GAP SEPARATION DISTANCE above)
       [line 322]  You can choose any (or all 6 if you wish)
       [line 331]  format files (multiple sequence file)
       [line 335]  form of phylogenetic analysis (MUCH more than the the modest intro-\n"
"duction offered by this program)
       [line 356]  were aligned (from the guide tree-dendrogram)
       [line 372]  of one or more sequences (e.g. an alignment output file from CLUSTAL\n"
"W)
       [line 378]  to specify gaps (except for MSF-RSF where \".\" is used)
       [line 405]  at that position (raised by multiplying the basic gap opening penalty\n"
"by the number)
       [line 421]  in specified regions (typically secondary structure elements)
       [line 422]  are preferentially opened in the less well conserved regions (typically \n"
"surface loops)
       [line 432]  and Beta Strand (B)
       [line 470]  to the residue(s)
       [line 502]  methods used are NJ (Neighbour Joining)
       [line 503]  calculate distances (percent divergence)
       [line 510]  around gaps (usually)
       [line 511]  of the data if there are many gaps (which is why it is difficult for us to\n"
"make it the default)
       [line 516]  For small divergence (say <10%)
       [line 522]  The corrections used here (for DNA or\n"
"proteins)
       [line 533]  an outgroup (a sequence that you are certain branches at the outside\n"
"of the tree .... certain on biological grounds)
       [line 536]  the tree (roughly equidistant from all tips)
       [line 541]  but some display packages (e.g. TreeTool, TreeView\n"
"and Phylowin)
       [line 564]  spanning the full range of amino acid distance (from almost\n"
"identical sequences to highly divergent ones)
       [line 572]  out database similarity (homology searches)
       [line 587]  you can read in your own (just one matrix, not a series)
       [line 597]  a single matrix (not a series)
       [line 614]  row and column of the matrix (corresponding to the * character)
       [line 635]  a NJ tree (n= number of bootstraps; def. = 1000)
       [line 649]  or UPPER (for GDE output only)
       [line 650]  or ON (for Clustal output only)
       [line 651]  or ON (NEW: for all output formats)
       [line 757]  this format with NJplot (Manolo Gouy)
       [line 758]  that can read and display New Hampshire format are TreeView (Mac/PC)
       [line 809] 
    string s(1, marker)
       [line 810] 
    return GetSection(s)
       [line 825] 
    string s(1, marker)
       [line 826] 
    return GetSectionTitle(s)
  |- FastPairwiseAlign.o
  |- RootedClusterTree.o
  |- clustalw_version.h
  |- Node.o
  |- LowScoreSegProfile.o
  |- UnRootedClusterTree.o
  |- InFileStream.o
  |- ProfileWithSub.o
  |- UPGMAAlgorithm.o
  |- ClustalFileParser.o
  |- main.o
  |- .dirstamp
  |- TreeInterface.o
  |- RootedTreeOutput.o
  |- AlignmentOutput.o
  |- FileParser.o
  |- ProfileBase.o
  |- RandomGenerator.o
  |- PearsonFileParser.o
  |- Makefile.in
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 358: 'NVCCFLAGS'
         [ 355] NVCC = @NVCC@
         [ 356] 
         [ 357] # Caso queira remover OpenMP, remova/ajuste estas duas linhas:
         [ 358] NVCCFLAGS = -Xcompiler -fopenmp
         [ 359] OBJEXT = @OBJEXT@
         [ 360] PACKAGE = @PACKAGE@
         [ 361] PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
       [CUDA Arch / Flags] line 443: 'NVCCFLAGS'
         [ 440] 
         [ 441] # Ajuste final de link. Observação:
         [ 442] # - Não coloque $(CXXFLAGS) aqui para não injetar -fopenmp "puro" no nvcc
         [ 443] clustalw2_LINK = $(NVCC) $(NVCCFLAGS) $(LDFLAGS) -o $@
         [ 444] 
         [ 445] # Fontes
         [ 446] clustalw2_SOURCES = \
       [CUDA Arch / Flags] line 1350: 'NVCCFLAGS'
         [1347] 
         [1348] # Compilando .cu e .o via nvcc
         [1349] .cu.o:
         [1350] 	$(NVCC) -DHAVE_CONFIG_H -I. -I.. -o $@ -c $< $(NVCCFLAGS)
         [1351] 
         [1352] .o:
         [1353] 	$(NVCC) -DHAVE_CONFIG_H -I. -I.. -o $@ -c $< $(NVCCFLAGS)
       [CUDA Arch / Flags] line 1353: 'NVCCFLAGS'
         [1350] 	$(NVCC) -DHAVE_CONFIG_H -I. -I.. -o $@ -c $< $(NVCCFLAGS)
         [1351] 
         [1352] .o:
         [1353] 	$(NVCC) -DHAVE_CONFIG_H -I. -I.. -o $@ -c $< $(NVCCFLAGS)
         [1354] 
         [1355] # Tell versions [3.59,3.63) of GNU make to not export all variables.
         [1356] # Otherwise a system limit (for SysV at least) may be exceeded.
  |- RootedGuideTree.o
  |- Sequence.o
  |- InvalidCombination.o
  |- Iteration.o
  |- PIRFileParser.o
  |- Makefile
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 358: 'NVCCFLAGS'
         [ 355] NVCC = nvcc
         [ 356] 
         [ 357] # Caso queira remover OpenMP, remova/ajuste estas duas linhas:
         [ 358] NVCCFLAGS = -Xcompiler -fopenmp
         [ 359] OBJEXT = o
         [ 360] PACKAGE = clustalw
         [ 361] PACKAGE_BUGREPORT = clustalw@ucd.ie
       [CUDA Arch / Flags] line 443: 'NVCCFLAGS'
         [ 440] 
         [ 441] # Ajuste final de link. Observação:
         [ 442] # - Não coloque $(CXXFLAGS) aqui para não injetar -fopenmp "puro" no nvcc
         [ 443] clustalw2_LINK = $(NVCC) $(NVCCFLAGS) $(LDFLAGS) -o $@
         [ 444] 
         [ 445] # Fontes
         [ 446] clustalw2_SOURCES = \
       [CUDA Arch / Flags] line 1350: 'NVCCFLAGS'
         [1347] 
         [1348] # Compilando .cu e .o via nvcc
         [1349] .cu.o:
         [1350] 	$(NVCC) -DHAVE_CONFIG_H -I. -I.. -o $@ -c $< $(NVCCFLAGS)
         [1351] 
         [1352] .o:
         [1353] 	$(NVCC) -DHAVE_CONFIG_H -I. -I.. -o $@ -c $< $(NVCCFLAGS)
       [CUDA Arch / Flags] line 1353: 'NVCCFLAGS'
         [1350] 	$(NVCC) -DHAVE_CONFIG_H -I. -I.. -o $@ -c $< $(NVCCFLAGS)
         [1351] 
         [1352] .o:
         [1353] 	$(NVCC) -DHAVE_CONFIG_H -I. -I.. -o $@ -c $< $(NVCCFLAGS)
         [1354] 
         [1355] # Tell versions [3.59,3.63) of GNU make to not export all variables.
         [1356] # Otherwise a system limit (for SysV at least) may be exceeded.
  |- ClustalWResources.o
  |- config.h.in
  |- CommandLineParser.o
  |- main.cpp
    -> Found 9 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 32] 

int main(int argc, char **argv)
       [line 36]  new UserParameters(false)
       [line 37]  new Utility()
       [line 38]  new SubMatrix()
       [line 39]  new Stats()
       [line 45]  DEBUGFULL    
        if(DEBUGLOG)
       [line 49]  new DebugLog("logfile.txt")
       [line 64] 
        CommandLineParser cmdLineParser(&args, false)
    -> Referências importantes (com snippet):
       [Marcador de problema] line 76: 'FIXME'
         [  73]     }
         [  74]     if (argc<=1 || userParameters->getInteractive())
         [  75]     {
         [  76]         // FIXME: additional parameters like infile are ignored!
         [  77]         InteractiveMenu menu;
         [  78]         userParameters->setMenuFlag(true);
         [  79]         userParameters->setInteractive(true);
  |- SubMatrix.o
  |- UserParameters.o
  |- Help.h
    -> Found 6 function(s):
       [line 2]  Author: Andreas Wilm
 *
 * Copyright (c)
       [line 30] 
    string GetSection(string marker)
       [line 31] 
    string GetSection(char marker)
       [line 32] 
    string GetSectionTitle(string marker)
       [line 33] 
    string GetSectionTitle(char marker)
       [line 34] 
    vector<string> ListSectionMarkers()
  |- Stats.o
  |- DebugLog.o
  |- Clustal.h
    -> Found 27 function(s):
       [line 2]  Author: Mark Larkin
 *
 * Copyright (c)
       [line 31] 
        void align(string* phylipName, bool createOutput = true)
       [line 32] 
        void sequencesAlignToProfile(string* phylipName)
       [line 33] 
        void profileAlign(string* p1TreeName, string* p2TreeName)
       [line 34] 
        void doGuideTreeOnly(string* phylipName)
       [line 35] 
        void doAlignUseOldTree(string* phylipName)
       [line 36]         
        void getHelp(string helpPointer, bool printTitle = false)
       [line 37] 
        void getHelp(char helpPointer, bool printTitle = false)
       [line 38] 
        void getFullHelp()
       [line 39] 
        int sequenceInput(bool append)
       [line 40] 
        int profile1Input(string profile1Name = "")
       [line 41] 
        int profile2Input(string profile2Name = "")
       [line 42] 
        int commandLineReadSeq(int firstSeq)
       [line 43] 
        void outputNow()
       [line 44] 
        void phylogeneticTree(string* phylip_name, string* clustal_name, string* dist_name,
                              string* nexus_name, string pimName)
       [line 46] 
        void bootstrapTree(string* phylip_name, string* clustal_name, string* nexus_name)
       [line 47] 
        Alignment* getAlignmentPtr()
       [line 48]  
        void QTcalcLowScoreSegments(LowScoreSegParams* params)
       [line 49] 
        void QTcalcWeightsForLowScoreSeg(LowScoreSegParams* params)
       [line 50] 
        void QTremoveShortSegments(LowScoreSegParams* params)
       [line 51] 
        void QTSetFileNamesForOutput(AlignmentFileNames fileNames)
       [line 52] 
        bool QTRealignSelectedRange(AlignmentFileNames fileNames, int beginPos, int endPos,
        bool realignEndGapPen)
       [line 54] 
        void test()
       [line 59] 
        void initInterface()
       [line 60] 
        void calcGapPenaltyMask(int prfLength, vector<char>* mask, vector<char>* gapMask)
       [line 61] 
        bool useExistingGuideTree(int type, string* phylipName, const string& path)
       [line 62] 
        void promptForNewGuideTreeName(int type, string* treeName, const string& path)
  |- ClusterTreeOutput.o
  |- ClusterTree.o
  |- SymMatrix.o
  |- config.h
    -> Found 1 function(s):
       [line 80]  Define to 1 if all of the C90 standard headers exist (not just the ones
   required in a freestanding environment)
  |- FileReader.o
  |- stamp-h1
  |- Makefile.am
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 15: 'NVCCFLAGS'
         [  12] AM_CPPFLAGS = -I@top_srcdir@/
         [  13] 
         [  14] # Caso queira remover OpenMP, remova/ajuste estas duas linhas:
         [  15] NVCCFLAGS = -Xcompiler -fopenmp
         [  16] OPENMP_LIBS = -lgomp
         [  17] 
         [  18] # Aqui vão as bibliotecas extras de link
       [CUDA Arch / Flags] line 24: 'NVCCFLAGS'
         [  21] 
         [  22] # Ajuste final de link. Observação:
         [  23] # - Não coloque $(CXXFLAGS) aqui para não injetar -fopenmp "puro" no nvcc
         [  24] clustalw2_LINK = $(NVCC) $(NVCCFLAGS) $(LDFLAGS) -o $@
         [  25] 
         [  26] bin_PROGRAMS = clustalw2
         [  27] 
       [CUDA Arch / Flags] line 30: 'NVCCFLAGS'
         [  27] 
         [  28] # Compilando .cu e .o via nvcc
         [  29] .cu.o:
         [  30] 	$(NVCC) -DHAVE_CONFIG_H -I. -I.. -o $@ -c $< $(NVCCFLAGS)
         [  31] 
         [  32] .o:
         [  33] 	$(NVCC) -DHAVE_CONFIG_H -I. -I.. -o $@ -c $< $(NVCCFLAGS)
       [CUDA Arch / Flags] line 33: 'NVCCFLAGS'
         [  30] 	$(NVCC) -DHAVE_CONFIG_H -I. -I.. -o $@ -c $< $(NVCCFLAGS)
         [  31] 
         [  32] .o:
         [  33] 	$(NVCC) -DHAVE_CONFIG_H -I. -I.. -o $@ -c $< $(NVCCFLAGS)
         [  34] 
         [  35] # Fontes
         [  36] clustalw2_SOURCES = \
  |- Alignment.o
  |- MSFFileParser.o
  |- Help.o
  |- RSFFileParser.o
  |- Utility.o
  |- FullPairwiseAlign.o
  |- InteractiveMenu.o
  |- EMBLFileParser.o
  |- VectorOutOfRange.o
  |- OutputFile.o
  |- ObjectiveScore.o
  |- AlignmentSteps.o

[DIRECTORY] src/tree
  |- NJTree.cpp
    -> Found 14 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 16]  Improvement ideas in fast_nj_tree()
       [line 84]  zero
     *
     *    And we use (sum_rows[i] + sum_cols[i])
       [line 93]  flag array (set to 1 when killed)
       [line 138]  total is
     * divided by (2.0*fnseqs2)
       [line 140]  that division happen (N*(N-1)
       [line 143]  is equal to the comparison relation between (tmin*2.0*fnseqs2)
       [line 144]  Calculation of (tmin*2.0*fnseqs2)
       [line 144]  so we stop dividing
     * a total value and multiply tmin and (tmin*2.0*fnseqs2)
       [line 148]  some transformation of the equation (to cut operations)
       [line 562] 
            else if (j > minj)
       [line 578] 
            else if (j > mini)
       [line 594]  Set the score values (stored in join[])
       [line 606] 
            else if (j > mini)
  |- TreeInterface.h
    -> Found 22 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 37] 
        auto_ptr<AlignmentSteps> getWeightsAndStepsFromDistMat(vector<int>* seqWeights, 
                                                          DistMatrix* distMat, 
                                                          Alignment *alignPtr, 
                                                          int seq1, int nSeqs, 
                                                          string* phylipName, bool* success)
       [line 45]         
        void getWeightsFromDistMat(vector<int>* seqWeights, DistMatrix* distMat, 
                                   Alignment *alignPtr, int seq1, int nSeqs, 
                                   string* phylipName, bool* success)
       [line 48] 
                                   
        void getWeightsForQtLowScore(vector<int>* seqWeights, DistMatrix* distMat, 
                                   Alignment *alignPtr, int seq1, int nSeqs, 
                                   string* phylipName, bool* success)
       [line 56]                                                   
        auto_ptr<AlignmentSteps> getWeightsAndStepsFromTree(Alignment* alignPtr, 
                                                DistMatrix* distMat, string* treeName,
                                                vector<int>* seqWeights, int fSeq, 
                                                int numSeqs, bool* success)
       [line 65]                                                      
        int getWeightsFromGuideTree(Alignment* alignPtr, DistMatrix* distMat,
                                    string* treeName, vector<int>* seqWeights, int fSeq,
                                    int nSeqs, bool* success)
       [line 73] 
        void getWeightsForProfileAlign(Alignment* alignPtr, DistMatrix* distMat, 
                             string* p1TreeName, vector<int>* p1Weights, string* p2TreeName, 
                    vector<int>* p2Weights, int numSeqs, int profile1NumSeqs, bool useTree1, 
                    bool useTree2, bool* success)
       [line 82] 
        void generateTreeFromDistMat(DistMatrix* distMat, Alignment *alignPtr, 
                                                          int seq1, int nSeqs, 
                                                          string* phylipName, bool* success)
       [line 91]                                                   
        void treeFromAlignment(TreeNames* treeNames, Alignment *alignPtr)
       [line 98] 
        void bootstrapTree(TreeNames* treeNames, Alignment *alignPtr)
       [line 99] 
         
    private:
        auto_ptr<AlignmentSteps> getWeightsAndStepsFromDistMatNJ(vector<int>* seqWeights, 
                                                          DistMatrix* distMat, 
                                                          Alignment *alignPtr, 
                                                          int seq1, int nSeqs, 
                                                          string* phylipName, bool* success)
       [line 106] 
        
        auto_ptr<AlignmentSteps> getWeightsAndStepsUseOldGuideTreeNJ(DistMatrix* distMat, 
                                                   Alignment *alignPtr,  string* treeName,
                                                   vector<int>* seqWeights, 
                                                   int fSeq, int nSeqs, bool* success)
       [line 111] 
                                                             
        int readTreeAndCalcWeightsNJ(Tree* groupTree, Alignment* alignPtr, 
                            DistMatrix* distMat, string* treeName, vector<int>* seqWeights,
                            int fSeq, int nSeqs)
       [line 115] 
        
        int getWeightsFromGuideTreeNJ(Alignment* alignPtr, DistMatrix* distMat,
                                      string* treeName, vector<int>* seqWeights, int fSeq,
                                      int nSeqs, bool* success)
       [line 119] 
        
        void getWeightsFromDistMatNJ(vector<int>* seqWeights, DistMatrix* distMat, 
                                   Alignment *alignPtr, int seq1, int nSeqs, 
                                   string* phylipName, bool* success)
       [line 123]  
        
        void getWeightsForProfileAlignNJ(Alignment* alignPtr, DistMatrix* distMat, 
                             string* p1TreeName, vector<int>* p1Weights, string* p2TreeName, 
                    vector<int>* p2Weights, int numSeqs, int profile1NumSeqs, bool useTree1, 
                    bool useTree2, bool* success)
       [line 128] 
                    
        void generateTreeFromDistMatNJ(DistMatrix* distMat, Alignment *alignPtr, 
                                 int seq1, int nSeqs, string* phylipName, bool* success)
       [line 131] 
        
        auto_ptr<AlignmentSteps> getWeightsAndStepsFromTreeNJ(Alignment* alignPtr, 
                               DistMatrix* distMat, string* treeName,
                               vector<int>* seqWeights, int fSeq, int numSeqs, bool* success)
       [line 137] 
        auto_ptr<AlignmentSteps> getWeightsAndStepsFromDistMatUPGMA(vector<int>* seqWeights, 
                                 DistMatrix* distMat, Alignment *alignPtr, 
                                 int seq1, int nSeqs, string* phylipName, bool* success)
       [line 140] 
                                 
        auto_ptr<AlignmentSteps> generateTreeFromDistMatUPGMA(RootedGuideTree* guideTree,
                             DistMatrix* distMat, Alignment *alignPtr, int seq1, int nSeqs, 
                                            string* phylipName, bool* success)
       [line 144] 
                                 
        void getWeightsFromDistMatUPGMA(vector<int>* seqWeights, DistMatrix* distMat, 
                                   Alignment *alignPtr, int seq1, int nSeqs, 
                                   string* phylipName, bool* success)
       [line 148]  
                                   
        void getWeightsForProfileAlignUPGMA(Alignment* alignPtr, DistMatrix* distMat, 
                             string* p1TreeName, vector<int>* p1Weights, string* p2TreeName, 
                    vector<int>* p2Weights, int numSeqs, int profile1NumSeqs, bool useTree1, 
                    bool useTree2, bool* success)
  |- NJTree.o
  |- UnRootedClusterTree.h
    -> Found 5 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 14] 
    public:    
        UnRootedClusterTree()
       [line 16] 
        void treeFromAlignment(TreeNames* treeNames, Alignment *alignPtr)
       [line 17] 
        void treeFromDistMatrix(DistMatrix* distMat, Alignment *alignPtr, int seq1, 
                                int nSeqs, string& phylipName)
       [line 19] 
        void bootstrapTree(TreeNames* treeNames, Alignment *alignPtr)
  |- Tree.o
  |- RandomGenerator.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- ClusterTreeOutput.h
    -> Found 9 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18] 
    public:
        ClusterTreeOutput(clustalw::SeqInfo* seqInfo, int boot)
       [line 20] 
        void printNexusTree(clustalw::PhyloTree* phyloTree, ofstream* tree,
                   clustalw::Alignment *alignPtr, clustalw::DistMatrix* distMat, vector<int>* bootTotals)
       [line 22] 
        void printTree(clustalw::PhyloTree* phyloTree, ofstream* tree, vector<int>* totals)
       [line 23] 
        void printPhylipTree(clustalw::PhyloTree* phyloTree, ofstream* tree,
                   clustalw::Alignment *alignPtr, clustalw::DistMatrix* distMat, vector<int>* bootTotals)
       [line 25] 
        void printTreeDesc(clustalw::PhyloTree* phyloTree)
       [line 26] 
          
    private:
        ClusterTreeOutput()
       [line 29] 
        int twoWaySplit(clustalw::PhyloTree* phyloTree, ofstream* tree, int startRow, 
                    int flag, clustalw::Alignment *alignPtr, vector<int>* bootTotals)
       [line 31] 
        int twoWaySplitNexus(clustalw::PhyloTree* phyloTree, ofstream* tree, int startRow,
                    int flag, clustalw::Alignment *alignPtr, vector<int>* bootTotals)
  |- UnRootedClusterTree.o
  |- dayhoff.h
    -> Found 4 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 9] 
   
   Table of estimated PAMS (actual no. of substitutions per 100 residues)
       [line 17]  an arbitrary value of 1000 PAMS (1000% substitution)
       [line 17]   

   These values are derived from a Dayhoff model (1978)
  |- AlignmentSteps.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- NJTree.h
    -> Found 4 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18] 
    public:
        NJTree()
       [line 20] 
        virtual void generateTree(clustalw::PhyloTree* phyTree, clustalw::DistMatrix* distMat, clustalw::SeqInfo* seqInfo,
                                  ofstream* tree = 0)
       [line 22] 
        virtual void setVerbose(bool choice)
  |- .dirstamp
  |- TreeInterface.o
  |- RandomGenerator.o
  |- AlignmentSteps.h
    -> Found 9 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 31]  Empty vector 
        void saveSet(int n, int *groups)
       [line 32] 
        void saveSet(vector<int>* groups)
       [line 33] 
        int getNumSteps()
       [line 34] 
        string getNextStep()
       [line 35] 
        void printAlignSteps()
       [line 36] 
        const vector<vector<int> >* getSteps()
       [line 37] 
        vector<int>* getStep(int i)
       [line 38] 
        void clear()
  |- Tree.cpp
    -> Found 7 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 203]  assign the sequence nodes (in the same order as in the alignment file)
       [line 213]  is too long for PHYLIP tree format (max " 
                   << clustalw::MAXNAMES << " chars)
       [line 302] 
                else if (j == i + 1)
       [line 680]  same design as TreeNode
        if (p->parent == NULL)
       [line 716]  must be chosen as rootNode
               (non-optimized executables (-O0)
       [line 1216] 
        else if (groups[i] != 0)
  |- UnRootedClusterTree.cpp
    -> Found 15 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 63]  new ClusterTreeOutput(&info, 0)
       [line 65] 
    
        TreeGroups saveTree(numSeqs + 1, vector<int>(numSeqs + 1)
       [line 71]  new NJTree()
       [line 101]  check if any distances overflowed the distance corrections 
        if (overspill > 0)
       [line 112]  Turn on file output 
    

        if (userParameters->getOutputTreeClustal()
       [line 179]  Test to see if the inputs are valid
        if(seq1 < 1 || nSeqs < 1)
       [line 223]  new NJTree()
       [line 224]  new ClusterTreeOutput(&info, 0)
       [line 297]  new NJTree()
       [line 343]  check if any distances overflowed the distance corrections
        if (overspill > 0)
       [line 359]  compute the standard tree 

        if (userParameters->getOutputTreeClustal()
       [line 371] 

        RandomGenerator randGenerator(userParameters->getBootRanSeed()
       [line 443]  check if any distances overflowed the distance corrections 
        if (nfails > 0)
       [line 452]  new ClusterTreeOutput(&info, userParameters->getBootstrapFormat()
  |- ClusterTreeAlgorithm.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18] 
    public:
        virtual void generateTree(clustalw::PhyloTree* phyTree, clustalw::DistMatrix* distMat, clustalw::SeqInfo* seqInfo,
                                  ofstream* tree = 0)
       [line 21] 
        virtual void setVerbose(bool choice)
  |- TreeInterface.cpp
    -> Found 10 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 36]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 43] 
        return getWeightsAndStepsFromDistMatUPGMA(seqWeights, distMat, alignPtr, 
                                                seq1, nSeqs, phylipName, success)
       [line 48] 
        return getWeightsAndStepsFromDistMatNJ(seqWeights, distMat, alignPtr, 
                                                seq1, nSeqs, phylipName, success)
       [line 111] 
    return getWeightsAndStepsFromTreeNJ(alignPtr, distMat, treeName, seqWeights, 
                                        fSeq, numSeqs, success)
       [line 126]     
    return getWeightsFromGuideTreeNJ(alignPtr, distMat, treeName, seqWeights, fSeq, nSeqs, 
                                      success)
       [line 238]  clear the memory used for the phylogenetic tree

    if (nSeqs >= 2)
       [line 352]  new MSA()
       [line 466]  clear the memory used for the phylogenetic tree

    if (numSeqs >= 2)
       [line 614]  new MSA()
    -> Referências importantes (com snippet):
       [Marcador de problema] line 431: 'AW:'
         [ 428]         clusterTree->treeFromDistMatrix(distMat, alignPtr, seq1, nSeqs, copyOfPhylipName);
         [ 429] 
         [ 430]         *phylipName = copyOfPhylipName;
         [ 431]         // AW: message outputted by OutputFile function
         [ 432]         // utilityObject->info("Guide tree        file created:   [%s]",
         [ 433]         //                              phylipName->c_str());
         [ 434]         delete clusterTree;
       [Marcador de problema] line 516: 'AW:'
         [ 513]                                                    nSeqs, copyOfPhylipName);
         [ 514] 
         [ 515]         *phylipName = copyOfPhylipName;
         [ 516]         // AW: message outputted by OutputFile function
         [ 517]         // utilityObject->info("Guide tree        file created:   [%s]",
         [ 518]         //                              phylipName->c_str());
         [ 519]     }
  |- Tree.h
    -> Found 23 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 22] 
        void calcSeqWeights(int firstSeq, int lastSeq, vector<int>* sweight)
       [line 23] 
        int readTree(Alignment* alignPtr, const string& treeFileName, int firstSeq, 
                     int lastSeq)
       [line 25] 
        auto_ptr<AlignmentSteps> createSets(int firstSeq, int lastSeq)
       [line 26] 
        int calcSimilarities(Alignment* alignPtr, DistMatrix* distMat)
       [line 27] 
        void clearTree(TreeNode* p)
       [line 32] 
        void createTree(TreeNode* ptree, TreeNode* parent, ifstream* file)
       [line 33] 
        void createNode(TreeNode* pptr, TreeNode* parent)
       [line 34] 
        TreeNode* insertNode(TreeNode* pptr)
       [line 35] 
        void clearTreeNodes(TreeNode* p)
       [line 36] 
        TreeNode* reRoot(TreeNode* ptree, int nseqs)
       [line 37] 
        TreeNode* insertRoot(TreeNode* p, float diff)
       [line 38] 
        float calcRootMean(TreeNode* root, float *maxDist)
       [line 39] 
        float calcMean(TreeNode* nptr, float *maxDist, int nSeqs)
       [line 40] 
        void orderNodes()
       [line 41] 
        int calcWeight(int leaf)
       [line 42] 
        void skipSpace(ifstream* file)
       [line 43] 
        void groupSeqs(TreeNode* p, int *nextGroups, int nSeqs, AlignmentSteps* stepsPtr)
       [line 44] 
        void markGroup1(TreeNode* p, int *groups, int n)
       [line 45] 
        void markGroup2(TreeNode* p, int *groups, int n)
       [line 46] 
        TreeNode* avail()
       [line 47] 
        void setInfo(TreeNode* p, TreeNode* parent, int pleaf, string pname, float
                     pdist)
       [line 49] 
        void debugReportAllNodes(int nseqs)
  |- ClusterTreeOutput.o
  |- ClusterTree.o
  |- ClusterTree.cpp
    -> Found 32 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 55]  left << setw(_maxNames)
       [line 134]  flag positions with gaps (tree_gaps[i] = 1 )
       [line 139]  percentage divergence (/100)
       [line 140]  rate of transition (A <-> G; C <-> T)
       [line 146]  All sites with gaps (in any sequence)
       [line 168]  for every pair of sequence 
    for (m = 1; m < lastSeq - firstSeq + 1; ++m)
       [line 235]  gap in a seq
                if (!clustalw::userParameters->getUseAmbiguities()
       [line 260]  parameter correction for multiple substitutions

            if (!clustalw::userParameters->getKimura()
       [line 297]  fixed << setprecision(4)
       [line 298]  fixed << setprecision(4)
       [line 299]  fixed << setprecision(4)
       [line 300]  fixed << setprecision(0)
       [line 366]  fixed << setprecision(4)
       [line 367]  fixed <<  setprecision(4)
       [line 368]  fixed << setprecision(4)
       [line 369]  fixed << setprecision(0)
       [line 386]  flag positions with gaps (tree_gaps[i] = 1 )
       [line 391]  percentage divergence (/100)
       [line 396]  All sites with gaps (in any sequence)
       [line 416]  for every pair of sequence 
    for (m = 1; m < _numSeqs; ++m)
       [line 502]  formula
                    if (k > 0.0)
       [line 529]  fixed << setprecision(4)
       [line 650]  right << setw(5)
       [line 651]  left << setw(_maxNameSize)
       [line 655]  right << fixed << setprecision(0)
       [line 717] 
    else if (clustalw::userParameters->getMenuFlag()
       [line 742]  G 
    if (((base1 == 17)
       [line 854]  Turn off file output
        if (_DNAFlag)
       [line 868]  Turn off file output
        if (_DNAFlag)
       [line 912]  Turn off file output 
        if (_DNAFlag)
       [line 925]  Turn off file output 
        if (_DNAFlag)
  |- ClusterTree.h
    -> Found 21 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 8]  Generate a tree from alignment (treeFromAlignment)
       [line 9]  Generate a tree from a distance matrix (treeFromDistMatrix)
       [line 10]  Bootstrap a tree (bootstrapTree)
       [line 39] 
        void overspillMessage(int overspill,int total_dists)
       [line 40] 
        void treeGapDelete(clustalw::Alignment *alignPtr)
       [line 41]    
        int dnaDistanceMatrix(ofstream* treeFile, clustalw::Alignment *alignPtr)
       [line 42] 
        int protDistanceMatrix(ofstream* treeFile, clustalw::Alignment *alignPtr)
       [line 43] 
        bool isAmbiguity(int c)
       [line 44] 
        void calcPercIdentity(ofstream* pfile, clustalw::Alignment *alignPtr)
       [line 45] 
        void compareTree(clustalw::PhyloTree* tree1, clustalw::PhyloTree* tree2, vector<int>* hits, int n)
       [line 48] 
        bool transition(int base1, int base2)
       [line 49] 
        void distanceMatrixOutput(ofstream* outFile, clustalw::DistMatrix* matToPrint,
                                  clustalw::Alignment *alignPtr)
       [line 51] 
        bool openFilesForBootstrap(clustalw::OutputFile* clustalFile, clustalw::OutputFile* phylipFile,
                         clustalw::OutputFile* nexusFile, clustalw::TreeNames* treeNames, string* path)
       [line 53] 
        bool openFilesForTreeFromAlignment(clustalw::OutputFile* clustalFile, clustalw::OutputFile* phylipFile,
                            clustalw::OutputFile* distFile, clustalw::OutputFile* nexusFile, clustalw::OutputFile* pimFile, 
                            clustalw::TreeNames* treeNames, string* path)
       [line 56] 
        int calcQuickDistMatForAll(ofstream* clustalFile, ofstream* phylipFile, 
                                   ofstream* nexusFile, ofstream* pimFile, 
                                   ofstream* distFile, clustalw::Alignment* alignPtr)
       [line 59] 
                                   
        int calcQuickDistMatForSubSet(ofstream* clustalFile, ofstream* phylipFile, 
                                      ofstream* nexusFile, clustalw::Alignment* alignPtr, 
                                      bool inBootLoop = false)
       [line 63] 
        void printBootstrapHeaderToClustalFile(ofstream* clustalFile)
       [line 64] 
        void promptForBoolSeedAndNumTrials()
       [line 65] 
        void printErrorMessageForBootstrap(int totalOverspill, int totalDists, int nfails)
       [line 66] 
        bool checkIfConditionsMet(int numSeqs, int min)
  |- ClusterTreeOutput.cpp
    -> Found 18 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 53]  fixed << setprecision(5)
       [line 62]  fixed << setprecision(5)
       [line 75]  fixed << setprecision(5)
       [line 88]  fixed << setprecision(5)
       [line 143]  fixed << setprecision(5)
       [line 163]  fixed << setprecision(5)
       [line 195]  fixed << setprecision(5)
       [line 209]  fixed << setprecision(5)
       [line 248]  fixed << setprecision(5)
       [line 250]  fixed << setprecision(5)
       [line 260]  fixed << setprecision(5)
       [line 272]  fixed << setprecision(5)
       [line 285]  fixed << setprecision(5)
       [line 342]  fixed << setprecision(5)
       [line 361]  fixed << setprecision(5)
       [line 392]  fixed << setprecision(5)
       [line 406]  fixed << setprecision(5)
  |- RandomGenerator.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 26] 
        unsigned long addRand(unsigned long r)
       [line 32] 
        unsigned long mult(unsigned long p, unsigned long q)
  |- AlignmentSteps.o

[DIRECTORY] src/tree/UPGMA
  |- Node.cpp
    -> Found 2 function(s):
       [line 39]  new Node(*this)
       [line 68]  We search from the end of our area of the array       
    for(int i = numDists; --i; distIterator++)
  |- RootedClusterTree.o
  |- Node.o
  |- RootedGuideTree.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- RootedClusterTree.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 20]  
        void treeFromAlignment(TreeNames* treeNames, Alignment *alignPtr)
       [line 21] 
        auto_ptr<AlignmentSteps> treeFromDistMatrix(RootedGuideTree* phyloTree, 
                                        DistMatrix* distMat, Alignment *alignPtr, int seq1, 
                                        int nSeqs, string& phylipName)
  |- UPGMAAlgorithm.o
  |- .dirstamp
  |- RootedTreeOutput.o
  |- UPGMAAlgorithm.h
    -> Found 11 function(s):
       [line 22] 
        auto_ptr<AlignmentSteps> generateTree(RootedGuideTree* phyTree, 
                                    DistMatrix* distMat, SeqInfo* seqInfo,
                                    bool overwrite, ofstream* tree = 0)
       [line 25] 
        void setVerbose(bool _verbose)
       [line 30] 
        void printAllNodes(Node** nodes)
       [line 31] 
        void addAlignmentStep(vector<int>* group1, vector<int>* group2)
       [line 32] 
        Node** getNodeWithMinDist(Node** clusters)
       [line 33] 
        void recomputeNodeToJoin1DistMatRow(Node* nodeToJoin1, double** nodeToJoin2DistIter)
       [line 34] 
        void computeAllOtherDistsToNewNode(Node* nodeToJoin1, Node* nodeToJoin2,
                                                   double** nodeToJoin2DistIter)
       [line 36] 
        void computeDistsUpToNodeToJoin2(Node* nToJoin1, Node* nToJoin2, 
                                         double** nodeToJoin2DistIter)
       [line 38] 
        void computeDistsForNodesAfterNode2(Node* nToJoin2)
       [line 39] 
        void movePtrPastUnusedDistances(double** ptrToDist)
       [line 46] 
        double calcNewDist(double dist1, double dist2)
  |- UPGMAAlgorithm.cpp
    -> Found 9 function(s):
       [line 54] 
                      sizeDistMat * sizeof(double)
       [line 81]  new Node(firstSeq, 0, 0)
       [line 89]  new Node(elementIndex + firstSeq, 
                                    distanceMatrix, elementIndex)
       [line 208]  type2 
                    << setw(4)
       [line 268]  For each of the distances in nodeToJoin1           
    while(numDistToUpdate > 0)
       [line 329]  For each node until we get to the second node we are joining           
    for(nodeIter = nodeToJoin1->next; nodeIter != nodeToJoin2; nodeIter = nodeIter->next)
       [line 332]  Skip the distance to the node we are joining with
        movePtrPastUnusedDistances(nodeToJoin2DistIter)
       [line 345] 
        else if ((newDistToNode > nodeIter->minDist)
       [line 393] 
        else if ((distUpdate > nodeIter->minDist)
  |- RootedTreeOutput.h
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 22] 
    public:
        RootedTreeOutput(SeqInfo* seqInfo)
       [line 24] 
        void printPhylipTree(RootedGuideTree* tree, ofstream* ptrToFile, Alignment *alignPtr,
                             DistMatrix* distMat)
       [line 26] 
        void printNexusTree(RootedGuideTree* tree, ofstream* ptrToFile, Alignment *alignPtr, 
                            DistMatrix* distMat)
       [line 28]                    
                
    private:
        void phylipTraverse(ofstream* ptrToFile, Alignment *alignPtr, Node* tree)
       [line 31] 
        void nexusTraverse(ofstream* ptrToFile, Alignment *alignPtr, Node* tree)
  |- RootedGuideTree.o
  |- Node.h
    -> Found 33 function(s):
       [line 13] 
    public:
    
        Node(int seqNum, double *aptrToDistMatRow, int numDists)
       [line 16] 
        double getDist(int index)
       [line 17] 
        void setDist(int index, double dist)
       [line 18] 
        double* getPtrToDistMatRow()
       [line 19] 
        void setDistMatRowToNull()
       [line 20] 
        int getNumDists()
       [line 21] 
        double getMinDist()
       [line 22] 
        int getIndexToMinDist()
       [line 23] 
        void setMinDist(int index, double d)
       [line 24] 
        int getOrder()
       [line 25] 
        void setOrder(int o)
       [line 26] 
        int getSeqNum()
       [line 27] 
        void setSeqNum(int sNum)
       [line 28] 
        void printNodeInfo()
       [line 29] 
        void printDistMatRow()
       [line 30] 
        void printMinDist()
       [line 31] 
        string elementsToString()
       [line 32]         
        Node* getLeft()
       [line 33] 
        Node* getRight()
       [line 34] 
        void setLeft(Node* l)
       [line 35] 
        void setRight(Node* r)
       [line 36] 
        double getHeight()
       [line 37] 
        void setHeight(double h)
       [line 38] 
        vector<int>* getPtrToElements()
       [line 39] 
        int getFirstElement()
       [line 40] 
        void clearElements()
       [line 41] 
        int getFirstElem()
       [line 42] 
        bool isLeafNode()
       [line 53] 
        
        void merge(Node **rightNode, double _height)
       [line 55] 
        void findMinDist()
       [line 56] 
        void printElements()
       [line 57]       
        void makeEmpty()
       [line 58] 
        void makeEmpty(Node* t)
  |- upgmadata.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- RootedClusterTree.cpp
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 24]  Test to see if the inputs are valid
        if(seq1 < 1 || nSeqs < 1)
       [line 62] 
                
        RootedTreeOutput outputTree(&info)
       [line 140] 
    
        RootedTreeOutput outputTree(&info)
       [line 173]  check if any distances overflowed the distance corrections 
        if (overspill > 0)
       [line 184]  Turn on file output 
    

        if (userParameters->getOutputTreeClustal()
  |- RootedGuideTree.h
    -> Found 12 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 7]  Changes:
 * mark May 8th 2007: removed makeEmpty(Node* t function)
       [line 8]  changed makeEmpty()
       [line 25] 
    public:
        RootedGuideTree()
       [line 29] 
        void setRoot(Node* r)
       [line 30] 
        void makeEmpty()
       [line 31] 
        void calcSeqWeights(int firstSeq, int lastSeq, vector<int>* seqWeights)
       [line 32] 
        Node* getRoot()
       [line 33] 
    private:
        void orderNodes()
       [line 35] 
        int calcOrderNode(Node* node)
       [line 36] 
        void calcWeights(vector<int>* seqWeights)
       [line 37] 
        void doWeightCalc(float weightSoFar, vector<float>* seqWeights, Node* t)
  |- RootedTreeOutput.cpp
    -> Found 7 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 29]  use the distances in the distMat
    if (lastSeq - firstSeq + 1 == 2)
       [line 32]  fixed << setprecision(5)
       [line 34]  fixed << setprecision(5)
       [line 65]  IF we have only 2 seqs
    if (lastSeq - firstSeq + 1 == 2)
       [line 68]  fixed << setprecision(5)
       [line 70]  fixed << setprecision(5)

[DIRECTORY] src/tree/UPGMA/.deps
  |- RootedClusterTree.Po
  |- .dirstamp
  |- UPGMAAlgorithm.Po
  |- RootedTreeOutput.Po
  |- Node.Po
  |- RootedGuideTree.Po

[DIRECTORY] src/tree/.deps
  |- AlignmentSteps.Po
  |- NJTree.Po
  |- TreeInterface.Po
  |- .dirstamp
  |- UnRootedClusterTree.Po
  |- Tree.Po
  |- ClusterTreeOutput.Po
  |- RandomGenerator.Po
  |- ClusterTree.Po

[DIRECTORY] src/cuda
  |- cudaMultiSeqAlign.h
    -> Found 1 function(s):
       [line 10]  SPThread 0

int cudaMultiSeqAlign(Alignment* alignPtr, DistMatrix* distMat, vector<int>* seqWeight, AlignmentSteps* progSteps, int iStart)
  |- cudaMultiSeqAlign.o
  |- pairwiseAlignInfo.h
    -> Found 3 function(s):
       [line 44] 

    void print_pair()
       [line 69]  constructor
    pairwiseAlignInfo()
       [line 86]  constructor
    pairwiseAlignInfo(pairwiseAlignInfoStruct* CPUInfo, int GPUORNOT)
  |- MSAInfo.h
    -> Found 4 function(s):
       [line 29] 
    string :q


    MSAInfoStruct()
       [line 60] 

    void print_pair()
       [line 94]  constructor
    MSAInfo()
       [line 111]  constructor
    MSAInfo(MSAInfoStruct* CPUInfo, int GPUORNOT)
  |- .dirstamp
  |- cudaMultiSeqAlign.cu
    -> Found 16 function(s):
       [line 25] 

void Random(vector<int>* v)
       [line 39] 

vector<int> Sort_Sets(vector< vector<int> > * ptrToSets)
       [line 119] 
vector<int> Sort_Sets(vector< vector<int> > * ptrToSets)
       [line 151]  check inner
                    for(int inner = 0 ; inner < index.size()
       [line 195] 

int cudaMultiSeqAlign(Alignment* alnPtr, DistMatrix* distMat, vector<int>* seqWeight, AlignmentSteps* progSteps, int iStart)
       [line 209] 
    vector<int> newOutputIndex(numSeqs)
       [line 214]  find the most closely related sequence

    for (int i = 1; i <= numSeqs; i++)
       [line 225]  group the sequences according to their relative divergence

    if (iStart == 0)
       [line 272]  new MyersMillerProfileAlign()
       [line 275]  omp parallel num_threads(numProc)
       [line 280]  omp for schedule(dynamic, 1)
       [line 292]  DEBUGFULL
                            if(logObject && DEBUGLOG)
       [line 298]  new MyersMillerProfileAlign()
       [line 349]  two most closely related sequences now
    if (ix == 0)
       [line 398]  multiply sequence weights from tree by percent identity with new sequence 
        if (userParameters->getNoWeights()
       [line 438] 
            else if (iseq == j)
  |- cudaFullPairwiseAlign.o
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 1760: 'sm_86'
  |- cudaFullPairwiseAlign.cu
    -> Found 43 function(s):
       [line 30] 
__global__ void setGlobalMatrixPointer(int* ptr)
       [line 33] 

int findMaxLength(vector<vector <int> >& vec )
       [line 42] 

void Set_Element(int2* element, int element_size, int numSeqs)
       [line 52] 

__device__ int mmLength(unsigned char* Sequence,int length,  int gapPos1, int gapPos2)
       [line 62] 

__device__ int2 getGapOpenGapExtend(int DNAFlag, int matAvgScore, PairScaleValues scaleValues,
                                    float pwGapOpen, float pwGapExtend, int m, int n)
       [line 70] 
        return make_int2( static_cast<int>(2 * pwGapOpen * intScale * gapOpenScale)
       [line 79] 

        return make_int2(gapOpenVal, static_cast<int>(pwGapExtend * intScale)
       [line 83] 

__device__ int calcScore(unsigned char* sequence1, unsigned char* sequence2, int i, int j)
       [line 85] 
    return Matrix(sequence1[i] * 32 + sequence2[j])
       [line 87] 

__device__ int cudaCalcScore(unsigned char* sequence1, unsigned char* sequence2, int iat, int jat, int v1, int v2)
       [line 89] 
    return calcScore(sequence1, sequence2, v1 + iat, v2 + jat)
       [line 91] 

__device__ void cudaAdd(int& lastPrint, int& printPtr, int* displ, int v)
       [line 102] 

__device__ void cudaDel(int& lastPrint, int& printPtr, int* displ, int k)
       [line 112] 

__device__ int Gap(int k, int constant , int gapExtend)
       [line 117] 

__device__ int cudaGap(int k, int gapOpen, int gapExtend)
       [line 119] 
    return Gap(k, gapOpen, gapExtend)
       [line 121] 

__device__ int cudaTbGap(int k, int tb, int gapExtend)
       [line 123] 
    return Gap(k, tb, gapExtend)
       [line 125] 

__device__ int cudaTeGap(int k, int te, int gapExtend)
       [line 127] 
    return Gap(k, te, gapExtend)
       [line 129] 

__device__ float cudaTracePath(unsigned char* sequence1, unsigned char* sequence2,
                               int sb1, int sb2, int printPtr, int* displ,
                               int gapPos1, int gapPos2)
       [line 155] 

__device__  void setSequence(unsigned char* Sequence, int* array2D, int length)
       [line 163] 

__device__ void cudaInitHDOrRS(int* HR, int* DS, int gapOpen, int gapExtend,
                               int tbte, int iStart, int iEnd, bool isInc)
       [line 179] 

__device__ void cudaSetHD(int* HH, int* DD, unsigned char* sequence1, unsigned char* sequence2,
                          int gapOpen, int gapExtend, int tb, int A, int B,
                          int iStart, int iEnd, int jStart, int jEnd)
       [line 213] 
            else if(count > 0 && i<= iEnd)
       [line 258] 

__device__ void cudaSetRS(int* RR, int* SS, unsigned char* sequence1, unsigned char* sequence2,
                          int gapOpen, int gapExtend, int te, int A, int B,
                          int iStart, int iEnd, int jStart, int jEnd)
       [line 292] 
            else if(count > 0 && i>= iEnd)
       [line 337] 

__device__ int3 cudaForwardPath(unsigned char* sequence1, unsigned char* sequence2,
                                int n, int m, int gapOpen, int gapExtend,
                                int* HH, int* DD)
       [line 376]      
            else if(i<= n && count > 0)
       [line 421] 

__device__ int3 cudaReversePath(unsigned char* sequence1, unsigned char* sequence2,
                                int n, int m, int gapOpen, int gapExtend,
                                int* HH, int* DD, int3 ScoreAndPosSe)
       [line 463] 
            else if(count > 0 && i >= 1)
       [line 508] 

__device__ int cudaDiff(unsigned char* sequence1, unsigned char* sequence2,
                        int* HH, int* DD, int* RR, int* SS, int* displ,
                        int gapOpen, int gapExtend, int3 ScoreAndPosSe, int3 ScoreAndPosSb)
       [line 555] 
             else if(M <= 1)
       [line 640] 

__global__ void cudaFullPairwiseAlignKernel( DyArray2DStruct<int>* sequence,
                                             float* distMatrix,
                                             DyArray2DStruct<int>* HH, 
                                             DyArray2DStruct<int>* DD, 
                                             DyArray2DStruct<int>* RR, 
                                             DyArray2DStruct<int>* SS, 
                                             DyArray2DStruct<int>* displ, 
                                             int2* element)
       [line 707] 

void cudaFullPairwiseAlign(Alignment* alignPtr, DistMatrix* distMat,
                           int iStart , int iEnd, int jStart, int jEnd)
       [line 765]  NUMRES * NUMRES * sizeof(int)
       [line 766]  NUMRES * NUMRES * sizeof(int)
       [line 769] 
        pairwiseAlignInfoStruct pair(alignPtr->getNumSeqs()
       [line 779] 
        DyArray2DStruct<int> sequenceConvertToArray(&ptrToSequence, findMaxLength(ptrToSequence)
       [line 780] 
        DyArray2DStruct<int> sequence(sequenceConvertToArray , 1)
       [line 781]  
        DyArray2D<int> gSequence(&sequence, 1)
       [line 821]  omp for
        for(int i = 0; i<element_size ; i+= numberOfStreamBlocks)
       [line 899] 
        cout << cudaGetErrorString(cudaGetLastError()
  |- Stack.o
    -> Referências importantes (com snippet):
       [CUDA Arch / Flags] line 11: 'sm_86'
         [   8] 
         [   9]    CbF                            GCC: (Ubuntu 12.3.0-17ubuntu1) 12.3.0           GNU                    zR x                EC
         [  10] Q      <           EC
         [  11] P      \       )    EC
         [  12] `      |           EC
         [  13] U             *    EC
         [  14] a             ^    EC
  |- DyArray1D.h
    -> Found 22 function(s):
       [line 17]  constructor 
    DyArray1DStruct()
       [line 46]  constructor
    DyArray1DStruct(int alloclength, int GPUORNOT)
       [line 52]             cout << cudaGetErrorString(error)
       [line 65]             cout << cudaGetErrorString(error)
       [line 78]             cout << cudaGetErrorString(error)
       [line 100] 

    void allocateCPU(int alloclength)
       [line 107] 


    void allocateGPU(int alloclength, int GPUORNOT)
       [line 115]           cout << cudaGetErrorString(error)
       [line 121]  TO CPU
    void copy(T* dest, int count)
       [line 129]  TO CPU 
    void copy(T* dest, int count, int GPUORNOT)
       [line 140]  TO GPU
    void copyToGPU(T* dest, int count)
       [line 147]  TO GPU
    void copyToGPU(T* dest, int count, int GPUORNOT)
       [line 152] 
    
    void print()
       [line 169]  constructor
    DyArray1D()
       [line 179]  constructor
    DyArray1D(DyArray1DStruct<T>* copy, int GPUORNOT)
       [line 184]             cout << cudaGetErrorString(error)
       [line 192] 


    void allocateGPU(DyArray1DStruct<T>* copy, int GPUORNOT)
       [line 199]             cout << cudaGetErrorString(error)
       [line 207]  TO CPU
    void copy(T* dest, int count)
       [line 212]  TO CPU
    void copy(T* dest, int count, int GPUORNOT)
       [line 218]  TO GPU
    void copyToGPU(T* dest, int count)
       [line 223]  TO GPU
    void copyToGPU(T* dest, int count, int GPUORNOT)
  |- cudaFullPairwiseAlign.h
    -> Found 1 function(s):
       [line 18] 

void cudaFullPairwiseAlign(Alignment* alignPtr, DistMatrix* distMat, int iStart , int iEnd, int jStart, int jEnd)
  |- cudaMultiSeqAlign.cpp
    -> Found 16 function(s):
       [line 16] 

void Random(vector<int>* v)
       [line 30] 

vector<int> Sort_Sets(vector< vector<int> > * ptrToSets)
       [line 110] 
vector<int> Sort_Sets(vector< vector<int> > * ptrToSets)
       [line 142]  check inner
                    for(int inner = 0 ; inner < index.size()
       [line 186] 

int cudaMultiSeqAlign(Alignment* alnPtr, DistMatrix* distMat, vector<int>* seqWeight, AlignmentSteps* progSteps, int iStart)
       [line 200] 
    vector<int> newOutputIndex(numSeqs)
       [line 204]  find the most closely related sequence

    for (int i = 1; i <= numSeqs; i++)
       [line 215]  group the sequences according to their relative divergence

    if (iStart == 0)
       [line 262]  new MyersMillerProfileAlign()
       [line 264]  omp parallel num_threads(numProc)
       [line 269]  omp for schedule(dynamic, 1)
       [line 280]  DEBUGFULL
                            if(logObject && DEBUGLOG)
       [line 285]  new MyersMillerProfileAlign()
       [line 334]  two most closely related sequences now
    if (ix == 0)
       [line 383]  multiply sequence weights from tree by percent identity with new sequence 
        if (userParameters->getNoWeights()
       [line 423] 
            else if (iseq == j)
  |- DyArray2D.h
    -> Found 23 function(s):
       [line 20]  CPU constructor
    DyArray2DStruct()
       [line 88]  allocate with GPU and copy data from CPU
    DyArray2DStruct(const DyArray2DStruct& CPUArray, int GPUORNOT)
       [line 101]  cout << cudaGetErrorString(error)
       [line 115]             cout << cudaGetErrorString(error)
       [line 119]             cout << cudaGetErrorString(error)
       [line 136]           cout << cudaGetErrorString(error)
       [line 140]           cout << cudaGetErrorString(error)
       [line 142]            cout << cudaGetErrorString(error)
       [line 146] 

    void initgpu(int CPUwidth, int CPUheigth, int GPUORNOT)
       [line 156]           cout << cudaGetErrorString(error)
       [line 160]           cout << cudaGetErrorString(error)
       [line 162]             cout << cudaGetErrorString(error)
       [line 192] 

    void copy(T** dest)
       [line 203] 

    void copy(T** dest, int destwidth, int destheigth, int GPUORNOT)
       [line 235] 

    void print()
       [line 260]  constructor
    DyArray2D()
       [line 270]  destructor
    DyArray2D(DyArray2DStruct<T>* copy, int GPUORNOT)
       [line 275]             cout << cudaGetErrorString(error)
       [line 282] 
    void initgpu(DyArray2DStruct<T>* copy, int GPUORNOT)
       [line 313]  TO CPU
    void copy(T** dest)
       [line 318]  TO CPU
    void copy(T** dest, int GPUORNOT)
       [line 323]  TO GPU
    void copyToGPU(T** dest, int width, int heigth)
       [line 328]  TO GPU
    void copyToGPU(T** dest, int width, int heigth, int GPUORNOT)
  |- Stack.cu
    -> Found 4 function(s):
       [line 14] 


template<class T>
__host__ __device__ void StackInit(Stack<T>* s)
       [line 20]  

template<class T>
__host__ __device__ void StackPush(Stack<T>* s, T element)
       [line 26] 

template<class T>
__host__ __device__ T StackPop(Stack<T>* s)
       [line 33] 

template<class T>
__host__ __device__ void StackFree(Stack<T>* s)

[DIRECTORY] src/cuda/.deps
  |- .dirstamp
  |- cudaMultiSeqAlign.Po

[DIRECTORY] src/general
  |- clustalw.h
    -> Found 2 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 21]  or DEFINE(clustalx)
  |- Stats.cpp
    -> Found 9 function(s):
       [line 2]  Author: Andreas Wilm
 *
 * Copyright (c)
       [line 41]  Function: PairwiseIdentity()
       [line 58]  float
PairwiseIdentity(char @s1, char @s2)
       [line 96]  but be paranoid
    for (x = 1; x<=alnObj->getSeqLength(s1)
       [line 176]  continue if gap
        if((val < 0)
       [line 218]  i < mhash_get_block_size(MHASH_MD5)
       [line 280] 
    else
        fprintf(fp, "type: protein\n")
       [line 336]  alignment length is the length of any sequence
    fprintf(fp, "aln len: %d\n", alnObj->getSeqLength(1)
       [line 344]  create vector of pairwise identities
    for(int s1 = 1; s1 <= alnObj->getNumSeqs()
  |- SymMatrix.h
    -> Found 22 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 29] 
    public:
        SymMatrix()
       [line 66] 
        
        inline void SetAt(int nRow, int nCol, const double& value)
       [line 72] 
        
        inline double GetAt(int nRow, int nCol)
       [line 78] 
   
        inline void ResizeRect(int size, double val = 0.0)
       [line 99] 
        
        inline void setAllArrayToVal(double* array, int size, double val)
       [line 107]  
        
        inline int getSize()
       [line 112] 

        inline void clearArray()
       [line 132] 
         
        void printArray()
       [line 137] 
        
        void printSubArray()
       [line 142] 
        
        void printArray(double* array, int size)
       [line 165] 
        
        inline int getIndex(const int &i, const int &j, const int &nSeqs)
       [line 178] 
                    throw out_of_range("index out of range\n")
       [line 187] 
                    throw out_of_range("index out of range\n")
       [line 194] 
                throw out_of_range("index out of range\n")
       [line 200] inline
        inline double operator()
       [line 209] 
        
        inline double* getElements()
       [line 214] 
        
        inline int getSizeElements()
       [line 218] 

        inline double* getDistMatrix(int fSeq, int nSeqsInSub)
       [line 243]  Need to fix

                    for(int i = fSeq; i <= lSeq; i++)
       [line 262] 
        
        void clearSubArray()
       [line 273] 
        
        void makeSimilarityMatrix()
  |- debuglogObject.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- VectorUtility.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 16] 
template<class T>
void mergeVectors(std::vector<T>* vecToAddTo, std::vector<T>* vector1, std::vector<T>* vector2)
       [line 37] 
template<class T>
void mergeVectors(std::vector<T>* vecToAddTo, std::vector<T>* vector1)
  |- userparams.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- utils.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- statsObject.h
    -> Found 1 function(s):
       [line 2]  Author: Andreas Wilm
 * 
 * Copyright (c)
  |- OutputFile.cpp
    -> Found 2 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 88] 
    else if (userParameters->getMenuFlag()
  |- UserParameters.cpp
    -> Found 10 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 290]  FIXME: AW: Some parameters are missing here (e.g. the new ones like
 * clustering, etc)
       [line 363]  fixed << setprecision(2)
       [line 369]  fixed << setprecision(2)
       [line 377]  fixed << setprecision(2)
       [line 382]  fixed << setprecision(2)
       [line 421] 
    else if (outputGde)
       [line 425] 
    else if (outputNbrf)
       [line 429] 
    else if (outputPhylip)
       [line 433] 
    else if (outputNexus)
    -> Referências importantes (com snippet):
       [Marcador de problema] line 35: 'FIXME'
         [  32] 
         [  33] UserParameters::UserParameters(bool log)
         [  34] {
         [  35]    // FIXME: huge parts should be merged/replaced with
         [  36]    // setParamsToDefault (which is not used at all)
         [  37] 
         [  38]     gapPos1 = NUMRES - 2; /* code for gaps inserted by clustalw */
       [Marcador de problema] line 177: 'FIXME'
         [ 174] 
         [ 175] }
         [ 176] 
         [ 177] // FIXME:never used
         [ 178] void UserParameters::setParamsToDefault()
         [ 179] {
         [ 180]     DNAGapOpen = 15.0;
       [Marcador de problema] line 290: 'FIXME'
         [ 287]  * a file. It is used for testing and for saving parameters.
         [ 288]  *
         [ 289]  *
         [ 290]  * FIXME: AW: Some parameters are missing here (e.g. the new ones like
         [ 291]  * clustering, etc)
         [ 292]  *
         [ 293]  */
       [Marcador de problema] line 290: 'AW:'
         [ 287]  * a file. It is used for testing and for saving parameters.
         [ 288]  *
         [ 289]  *
         [ 290]  * FIXME: AW: Some parameters are missing here (e.g. the new ones like
         [ 291]  * clustering, etc)
         [ 292]  *
         [ 293]  */
  |- Stats.h
    -> Found 12 function(s):
       [line 2]  Author: Andreas Wilm
 *
 * Copyright (c)
       [line 26] 

    void setStatsFile(string f)
       [line 28] 
    string getStatsFile()
       [line 29] 

    void setEnabled(bool b)
       [line 31] 
    bool isEnabled()
       [line 32] 

    void logCmdLine(int argc, char **argv)
       [line 34] 

    void logInputSeqStats(Alignment *alnObj)
       [line 37] 
    void logAlignedSeqStats(Alignment *alnObj)
       [line 44]  HAVE_MHASH_H
    char * Md5Hash(const char *thread)
       [line 45] 
    string Md5ForSeq(Alignment *alnObj, int s)
       [line 46] 
    string ConcatInputHash(Alignment *alnObj)
       [line 49] 
    float pairwiseIdentity(Alignment *alnObj, int s1, int s2)
  |- .dirstamp
  |- OutputFile.h
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 14] 
    public:
        OutputFile()
       [line 17] 
        bool openFile(std::string* fileName, const std::string msg, const std::string* path, 
                      const std::string ext, const std::string fileType)
       [line 19] 
        bool isOpen()
       [line 21] 
        std::ofstream* getPtrToFile()
       [line 22] 
    private:
        std::string getOutputFileName(const std::string prompt, std::string path, 
                                      const std::string fileExtension)
  |- VectorOutOfRange.h
    -> Found 7 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 12] 
    public:
        VectorOutOfRange(std::string vectorName, int index, int max)
       [line 17] 
        int index()
       [line 18] 
        int max()
       [line 19] 
        const char* what()
       [line 20]  const throw()
       [line 20] 
        const char* what()
  |- SymMatrix.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- InvalidCombination.cpp
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 20] 
        public:
            InvalidCombination(int alignResidueType, int alignType)
       [line 24] 
            void whatHappened(std::ostream &os = std::cerr)
  |- InvalidCombination.o
  |- SequenceNotFoundException.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 15] 
  virtual const char* what()
       [line 16]  const throw ()
  |- ClustalWResources.o
  |- DebugLog.h
    -> Found 5 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 27] 
    public:
        DebugLog(std::string)
       [line 30] 
        void logMsg(std::string)
       [line 31] 
        void logScore(float x)
       [line 32] 
        void printScoreInfo()
  |- UserParameters.h
    -> Found 285 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 33] 
        void setParamsToDefault()
       [line 34] 
        void createParameterOutput()
       [line 35] 
        int resIndex(string t,char c)
       [line 36] 
        void setDNAMultiGap()
       [line 37] 
        void setProtMultiGap()
       [line 38] 
        void setDNAParams()
       [line 39] 
        void setProtParams()
       [line 40] 
        void setPWProteinParam()
       [line 41] 
        void setPWDNAParam()
       [line 42] 
        void setPWParamToProtein()
       [line 43] 
        void setPWParamToDNA()
       [line 44] 
        string getRevisionLevel()
       [line 45] 
        void setRevisionLevel(string value)
       [line 46] 
        bool getInteractive()
       [line 47] 
        void setInteractive(bool value)
       [line 48] 
        float getGapOpen()
       [line 49] 
        void setGapOpen(float value)
       [line 50] 
        float getGapExtend()
       [line 51] 
        void setGapExtend(float value)
       [line 52] 
        float getPWGapOpen()
       [line 53] 
        void setPWGapOpen(float value)
       [line 54] 
        float getPWGapExtend()
       [line 55] 
        void setPWGapExtend(float value)
       [line 56] 
        float getAAGapOpen()
       [line 57] 
        void setAAGapOpen(float gap)
       [line 58] 
        float getAAGapExtend()
       [line 59] 
        void setAAGapExtend(float gap)
       [line 60] 
        float getAAPWGapOpen()
       [line 61] 
        void setAAPWGapOpen(float gap)
       [line 62] 
        float getAAPWGapExtend()
       [line 63] 
        void setAAPWGapExtend(float gap)
       [line 64] 
        int getMaxAA()
       [line 65] 
        void setMaxAA(int value)
       [line 66] 
        int getGapPos1()
       [line 67] 
        void setGapPos1(int value)
       [line 68] 
        int getGapPos2()
       [line 69] 
        void setGapPos2(int value)
       [line 70] 
        int getProfileNum()
       [line 71] 
        void setProfileNum(int value)
       [line 72] 
        bool getMenuFlag()
       [line 73] 
        void setMenuFlag(bool value)
       [line 74] 
        bool getDNAFlag()
       [line 75] 
        void setDNAFlag(bool value)
       [line 76] 
        bool getDistanceTree()
       [line 77] 
        void setDistanceTree(bool value)
       [line 78] 
        string getSeqName()
       [line 79] 
        void setSeqName(string value)
       [line 80] 
        float getDNAGapOpen()
       [line 81] 
        void setDNAGapOpen(float value)
       [line 82] 
        float getDNAGapExtend()
       [line 83] 
        void setDNAGapExtend(float value)
       [line 84] 
        float getProteinGapOpen()
       [line 85] 
        void setProteinGapOpen(float value)
       [line 86] 
        float getProteinGapExtend()
       [line 87] 
        void setProteinGapExtend(float value)
       [line 88] 
        int getGapDist()
       [line 89] 
        void setGapDist(int value)
       [line 90] 
        int getOutputOrder()
       [line 91] 
        void setOutputOrder(int value)
       [line 92] 
        void toggleOutputOrder()
       [line 93] 
        int getDivergenceCutoff()
       [line 94] 
        void setDivergenceCutoff(int value)
       [line 95] 


        string getHydResidues()
       [line 98] 
        void setHydResidues(string value)
       [line 99] 
        bool getNoWeights()
       [line 100] 
        void setNoWeights(bool value)
       [line 101] 
        bool getUseNegMatrix()
       [line 102] 
        void setUseNegMatrix(bool value)
       [line 103] 
        void toggleUseNegMatrix()
       [line 104] 
        bool getNoHydPenalties()
       [line 105] 
        void setNoHydPenalties(bool value)
       [line 106] 
        void toggleNoHydPenalties()
       [line 107] 
        bool getNoVarPenalties()
       [line 108] 
        void setNoVarPenalties(bool value)
       [line 109] 
        bool getNoPrefPenalties()
       [line 110] 
        void setNoPrefPenalties(bool value)
       [line 111] 
        void toggleNoPrefPenalties()
       [line 112] 
        bool getUseEndGaps()
       [line 113] 
        void setUseEndGaps(bool value)
       [line 114] 
        void toggleUseEndGaps()
       [line 115] 
        bool getEndGapPenalties()
       [line 116] 
        void setEndGapPenalties(bool value)
       [line 117] 
        bool getResetAlignmentsNew()
       [line 118] 
        void setResetAlignmentsNew(bool value)
       [line 119] 
        bool getResetAlignmentsAll()
       [line 120] 
        void toggleResetAlignmentsNew()
       [line 121] 
        void setResetAlignmentsAll(bool value)
       [line 122] 
        int getOutputStructPenalties()
       [line 123] 
        void setOutputStructPenalties(int value)
       [line 124] 
        int getStructPenalties1()
       [line 125] 
        void setStructPenalties1(int value)
       [line 126] 
        int getStructPenalties2()
       [line 127] 
        void setStructPenalties2(int value)
       [line 128] 
        bool getUseSS1()
       [line 129] 
        void setUseSS1(bool value)
       [line 130] 
        void toggleUseSS1()
       [line 131] 
        bool getUseSS2()
       [line 132] 
        void setUseSS2(bool value)
       [line 133] 
        void toggleUseSS2()
       [line 134] 
        int getHelixPenalty()
       [line 135] 
        void setHelixPenalty(int value)
       [line 136] 
        int getStrandPenalty()
       [line 137] 
        void setStrandPenalty(int value)
       [line 138] 
        int getLoopPenalty()
       [line 139] 
        void setLoopPenalty(int value)
       [line 140] 
        int getHelixEndMinus()
       [line 141] 
        void setHelixEndMinus(int value)
       [line 142] 
        int getHelixEndPlus()
       [line 143] 
        void setHelixEndPlus(int value)
       [line 144] 
        int getStrandEndMinus()
       [line 145] 
        void setStrandEndMinus(int value)
       [line 146] 
        int getStrandEndPlus()
       [line 147] 
        void setStrandEndPlus(int value)
       [line 148] 
        int getHelixEndPenalty()
       [line 149] 
        void setHelixEndPenalty(int value)
       [line 150] 
        int getStrandEndPenalty()
       [line 151] 
        void setStrandEndPenalty(int value)
       [line 152] 
        bool getUseAmbiguities()
       [line 153] 
        void setUseAmbiguities(bool value)
       [line 154] 
        float getDNAPWGapOpenPenalty()
       [line 155] 
        void setDNAPWGapOpenPenalty(float value)
       [line 156] 
        float getDNAPWGapExtendPenalty()
       [line 157] 
        void setDNAPWGapExtendPenalty(float value)
       [line 158] 
        float getProteinPWGapOpenPenalty()
       [line 159] 
        void setProteinPWGapOpenPenalty(float value)
       [line 160] 
        float getProteinPWGapExtendPenalty()
       [line 161] 
        void setProteinPWGapExtendPenalty(float value)
       [line 162] 

        bool getQuickPairAlign()
       [line 164] 
        void setQuickPairAlign(bool value)
       [line 165] 
        void toggleQuickPairAlign()
       [line 166] 
        float getTransitionWeight()
       [line 167] 
        void setTransitionWeight(float value)
       [line 168] 
        int getDNAKtup()
       [line 169] 
        void setDNAKtup(int value)
       [line 170] 
        int getDNAWindowGap()
       [line 171] 
        void setDNAWindowGap(int value)
       [line 172] 
        int getDNASignif()
       [line 173] 
        void setDNASignif(int value)
       [line 174] 
        int getDNAWindow()
       [line 175] 
        void setDNAWindow(int value)
       [line 176] 
        int getAAKtup()
       [line 177] 
        void setAAKtup(int value)
       [line 178] 
        int getAAWindowGap()
       [line 179] 
        void setAAWindowGap(int value)
       [line 180] 
        int getAASignif()
       [line 181] 
        void setAASignif(int value)
       [line 182] 
        int getAAWindow()
       [line 183] 
        void setAAWindow(int value)
       [line 184] 
        bool getPercent()
       [line 185] 
        void setPercent(bool value)
       [line 186] 
        bool getTossGaps()
       [line 187] 
        void setTossGaps(bool value)
       [line 188] 
        void toggleTossGaps()
       [line 189] 
        bool getKimura()
       [line 190] 
        void setKimura(bool value)
       [line 191] 
        void toggleKimura()
       [line 192] 
        int getBootNumTrials()
       [line 193] 
        void setBootNumTrials(int value)
       [line 194] 
        unsigned int getBootRanSeed()
       [line 195] 
        void setBootRanSeed(unsigned int value)
       [line 196] 
        int getDebug()
       [line 197] 
        void setDebug(int value)
       [line 198] 
        bool getExplicitDNAFlag()
       [line 199] 
        void setExplicitDNAFlag(bool value)
       [line 200] 
        bool getLowercase()
       [line 201] 
        void setLowercase(bool value)
       [line 202] 
        void toggleLowercase()
       [line 203] 
        bool getClSeqNumbers()
       [line 204] 
        void setClSeqNumbers(bool value)
       [line 205] 
        void toggleClSeqNumbers()
       [line 206] 
        bool getSeqRange()
       [line 207] 
        void setSeqRange(bool value)
       [line 208] 
        void toggleSeqRange()
       [line 209] 
        bool getOutputClustal()
       [line 210] 
        void setOutputClustal(bool value)
       [line 211] 
        void toggleOutputClustal()
       [line 212]  
        bool getOutputGCG()
       [line 213] 
        void setOutputGCG(bool value)
       [line 214] 
        void toggleOutputGCG()
       [line 215]  
        bool getOutputPhylip()
       [line 216] 
        void setOutputPhylip(bool value)
       [line 217] 
        void toggleOutputPhylip()
       [line 218]  
        bool getOutputNbrf()
       [line 219] 
        void setOutputNbrf(bool value)
       [line 220] 
        void toggleOutputNbrf()
       [line 221]  
        bool getOutputGde()
       [line 222] 
        void setOutputGde(bool value)
       [line 223] 
        void toggleOutputGde()
       [line 224]  
        bool getOutputNexus()
       [line 225] 
        void setOutputNexus(bool value)
       [line 226] 
        void toggleOutputNexus()
       [line 227]  
        bool getOutputFasta()
       [line 228] 
        void setOutputFasta(bool value)
       [line 229] 
        void toggleOutputFasta()
       [line 230]  
        bool getShowAlign()
       [line 231] 
        void setShowAlign(bool value)
       [line 232] 
        void toggleShowAlign()
       [line 233] 
        bool getSaveParameters()
       [line 234] 
        void setSaveParameters(bool value)
       [line 235] 
        void toggleSaveParameters()
       [line 236] 
        bool getOutputTreeClustal()
       [line 237] 
        void setOutputTreeClustal(bool value)
       [line 238] 
        void toggleOutputTreeClustal()
       [line 239] 
        bool getOutputTreePhylip()
       [line 240] 
        void setOutputTreePhylip(bool value)
       [line 241] 
        void toggleOutputTreePhylip()
       [line 242] 
        bool getOutputTreeDistances()
       [line 243] 
        void setOutputTreeDistances(bool value)
       [line 244] 
        void toggleOutputTreeDistances()
       [line 245] 
        bool getOutputTreeNexus()
       [line 246] 
        void setOutputTreeNexus(bool value)
       [line 247] 
        void toggleOutputTreeNexus()
       [line 248] 
        bool getOutputPim()
       [line 249] 
        void setOutputPim(bool value)
       [line 250] 
        int getBootstrapFormat()
       [line 251] 
        void setBootstrapFormat(int value)
       [line 252] 
        void toggleBootstrapFormat()
       [line 253] 
        string getProfile1Name()
       [line 254] 
        void setProfile1Name(string value)
       [line 255] 
        string getProfile2Name()
       [line 256] 
        void setProfile2Name(string value)
       [line 257] 
        bool getEmpty()
       [line 258] 
        void setEmpty(bool value)
       [line 259] 
        bool getProfile1Empty()
       [line 260] 
        void setProfile1Empty(bool value)
       [line 261] 
        bool getProfile2Empty()
       [line 262] 
        void setProfile2Empty(bool value)
       [line 263] 
        string getOutfileName()
       [line 264] 
        void setOutfileName(string value)
       [line 265] 
        bool getUseTreeFile()
       [line 266] 
        void setUseTreeFile(bool value)
       [line 267] 
        bool getNewTreeFile()
       [line 268] 
        void setNewTreeFile(bool value)
       [line 269] 
        bool getUseTree1File()
       [line 270] 
        void setUseTree1File(bool value)
       [line 271] 
        bool getUseTree2File()
       [line 272] 
        void setUseTree2File(bool value)
       [line 273] 
        bool getNewTree1File()
       [line 274] 
        void setNewTree1File(bool value)
       [line 275] 
        bool getNewTree2File()
       [line 276] 
        void setNewTree2File(bool value)
       [line 277] 
        string getAminoAcidCodes()
       [line 278] 
        char getAminoAcidCode(int i)
       [line 279] 
        void setAminoAcidCodes(string value)
       [line 280] 
        int getKtup()
       [line 281] 
        void setKtup(int value)
       [line 282] 
        int getWindow()
       [line 283] 
        void setWindow(int value)
       [line 284] 
        int getWindowGap()
       [line 285] 
        void setWindowGap(int value)
       [line 286] 
        int getSignif()
       [line 287] 
        void setSignif(int value)
       [line 288] 
        int getRangeFrom()
       [line 289] 
        int getRangeTo()
       [line 290] 
        void setRangeFrom(int from)
       [line 291] 
        void setRangeTo(int to)
       [line 292] 
        bool getRangeFromToSet()
       [line 293] 
        void setRangeFromToSet(bool set)
       [line 294] 
        int getQTScorePlotScale()
       [line 295] 
        void setQTScorePlotScale(int score)
       [line 296] 
        int getQTResExceptionCutOff()
       [line 297] 
        void setQTResExceptionCutOff(int cutOff)
       [line 298] 
        bool getQTseqWeightCalculated()
       [line 299] 
        void setQTseqWeightCalculated(bool calculated)
       [line 300] 
        int getQTminLenLowScoreSegment()
       [line 301] 
        void setQTminLenLowScoreSegment(int minLen)
       [line 302] 
        int getQTlowScoreDNAMarkingScale()
       [line 303] 
        void setQTlowScoreDNAMarkingScale(int dnaScale)
       [line 307] 
        void setNumIterations(int num)
       [line 308] 
        int getNumIterations()
       [line 309] 
        void setDoRemoveFirstIteration(int doIter)
       [line 310] 
        int getDoRemoveFirstIteration()
       [line 311] 
        bool IterationIsEnabled()
       [line 312] 
            
        void setClusterAlgorithm(int clust)
       [line 314] 
        int getClusterAlgorithm()
       [line 315] 
        
        void setDisplayInfo(bool display)
       [line 317] 
        bool getDisplayInfo()
       [line 318] 
        bool getHelpFlag()
       [line 319] 
        void setHelpFlag(bool b)
       [line 320] 
        bool getFullHelpFlag()
       [line 321] 
        void setFullHelpFlag(bool b)
       [line 322] 
        void setMaxAllowedSeqLength(int num)
       [line 323] 
        int getMaxAllowedSeqLength()
       [line 324] 

        bool ResetGapsIsEnabled()
  |- RandomAccessLList.h
    -> Found 12 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 31] 
    public:
        ListElement()
       [line 50] 
        
        unsigned int getIndex()
       [line 63] 
    public:
        RandomAccessLList(int size)
       [line 86] 
        
        unsigned int getNumElements()
       [line 88] 
        
        void addElementToBack(T* element)
       [line 104] 
                else if(numElements > 0)
       [line 113] 
        
        ListElement<T>* getAt(int index)
       [line 126] 
        
        ListElement<T>* getFirst()
       [line 131]         
        
        void removeItem(ListElement<T>* item)
       [line 146] 
                    else if(item->prev == 0)
       [line 155] 
                    else if(item->next == 0)
  |- general.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- VectorOutOfRange.cpp
    -> Found 2 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 22]  const throw()
  |- Array2D.h
    -> Found 17 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18] 
public:
   Array2D()
       [line 26] 
           vector<T> x(nCol)
       [line 31] 
   
   int getRowSize()
       [line 36] 
   
   int getColSize()
       [line 41] 
   
   void SetAt(int nRow, int nCol, const T& value)
       [line 46] 
   T GetAt(int nRow, int nCol)
       [line 50] 
   void GrowRow(int newSize)
       [line 57] 
           vector<T> x(m_dimRow)
       [line 61] 
   void GrowCol(int newSize)
       [line 69] 
   
   void ResizeRect(int row, int col)
       [line 77] 
   void GrowRow(int newSize, const T& value)
       [line 84] 
           vector<T> x(m_dimRow, value)
       [line 88] 
   void GrowCol(int newSize, const T& value)
       [line 96] 
   
   void ResizeRect(int row, int col, const T& value)
       [line 102]    
      
   void printArray()
       [line 114] 
   
   void clearArray()
  |- ClustalWResources.cpp
    -> Found 6 function(s):
       [line 3]  The single instance is (re)
       [line 80] 
    return findFile(string(file)
       [line 111] 
        return string()
       [line 119] 
    return string()
       [line 123]  Search for a (string)
       [line 124]  return the full path as (string)
  |- ClustalWResources.h
    -> Found 11 function(s):
       [line 3]  The single instance is (re)
       [line 35] 
    void setPathToExecutable(std::string pathToFiles)
       [line 38] 
    std::string getDefaultPath()
       [line 39] 
    std::string getInstallPath()
       [line 40] 
    std::string getExecutablePath()
       [line 41] 
    std::string getHomePath()
       [line 42] 

    std::string findFile(const char *file, const ClustalWResourcePathType where = DefaultPath)
       [line 44] 
    std::string findFile(const std::string file, const ClustalWResourcePathType where = DefaultPath)
       [line 45] 
    std::string searchPathsForFile(const std::string fileName)
       [line 48] 
    void dump()
       [line 55] 
    
    std::string dirname(std::string path)
  |- SquareMat.h
    -> Found 13 function(s):
       [line 3]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 16] 
public:
   SquareMat()
       [line 24] 
           vector<T> x(size)
       [line 29] 
   void SetAt(int nRow, int nCol, const T& value)
       [line 33] 
   T GetAt(int nRow, int nCol)
       [line 37] 
   void GrowRow(int newSize)
       [line 44] 
           vector<T> x(m_dimRow)
       [line 48] 
   void GrowCol(int newSize)
       [line 56] 
   
   void ResizeRect(int size)
       [line 62] 

   int getSize()
       [line 67] 

   void clearArray()
       [line 80] 
         
   void printArray()
       [line 87] 
               cout << setprecision(20)
  |- UserParameters.o
  |- Utility.cpp
    -> Found 4 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 10]  Andreas Wilm (UCD)
       [line 129] 
    else if(choice == '\n')
       [line 503] 
    return sqrt(tmp / v.size()
    -> Referências importantes (com snippet):
       [Marcador de problema] line 250: 'AW:'
         [ 247]  */
         [ 248] bool Utility::lineType(char *line, const char *code)
         [ 249] {
         [ 250]    // AW: introduced sanity check
         [ 251]    int n;
         [ 252]    if (strlen(line)<strlen(code))
         [ 253]      n=strlen(line);
  |- Stats.o
  |- DebugLog.o
  |- SymMatrix.o
  |- DebugLog.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- Utility.h
    -> Found 30 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 22] 
    public:
        Utility()
       [line 24] 
        char* rTrim(char *str)
       [line 25] 
        void rTrim(string *str)
       [line 26] 
        char* blankToUnderscore(char *str)
       [line 27] 
        string blankToUnderscore(string str)
       [line 28] 
        void getStr(string instr, string& outstr)
       [line 29] 
        char getChoice(string instr)
       [line 30] 
        double getReal(char *instr, double minx, double maxx, double def)
       [line 31] 
        int getInt(char *instr,int minx,int maxx, int def)
       [line 32] 
        unsigned long getUniqueSequenceIdentifier()
       [line 33] 
        bool lineType(char *line, const char *code)
       [line 34] 

        bool blankLine(char *line)
       [line 36] 
        
        void getPath(string str, string *path)
       [line 38] 
        
        virtual char promptForYesNo(char *title,char *prompt)
       [line 40] 
        virtual char promptForYesNo(const char *title,char *prompt)
       [line 41] 
        virtual void error( char *msg,...)
       [line 42] 
        virtual void error( const char *msg,...)
       [line 43] 
        virtual void warning( char *msg,...)
       [line 44] 
        virtual void warning( const char *msg,...)
       [line 45] 
        virtual void info( char *msg,...)
       [line 46] 
        virtual void info( const char *msg,...)
       [line 47] 
        template <class T> T MIN(T x, T y)
       [line 48] 
        template <class T> T MAX(T x, T y)
       [line 51] 
        virtual void setInfoLabelPtr(QLabel* ptrToLabelObj)
       [line 52] 
        bool isNumeric(char ch)
       [line 53] 
        double average(std::vector<double>& v)
       [line 54] 
        double stdDev(std::vector<double>& v)
       [line 55] 
        double median(std::vector<double> v)
       [line 57] 
        void beQuiet(bool b)
  |- Utility.o
  |- param.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- VectorOutOfRange.o
  |- OutputFile.o

[DIRECTORY] src/general/.deps
  |- Utility.Po
  |- OutputFile.Po
  |- .dirstamp
  |- VectorOutOfRange.Po
  |- Stats.Po
  |- InvalidCombination.Po
  |- SymMatrix.Po
  |- ClustalWResources.Po
  |- UserParameters.Po
  |- DebugLog.Po

[DIRECTORY] src/interface
  |- CommandLineParser.h
    -> Found 8 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 44] 
        void parseParams(StringArray* args, bool xmenus)
       [line 45] 
        int checkParam(StringArray* args, StringArray* params, StringArray* paramArg)
       [line 46] 
        void setOptionalParam()
       [line 47] 
        int findMatch(string probe, StringArray* list, int n)
       [line 48] 
        CmdLineData getCmdLineDataStruct(const char *str, int *flag, int type, StringArray* arg)
       [line 49] 
        void printCmdLineData(const CmdLineData& temp)
       [line 50] 
        string ConvertStringToLower(string strToConvert)
  |- .dirstamp
  |- CommandLineParser.o
  |- InteractiveMenu.h
    -> Found 16 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 31] 
        void mainMenu()
       [line 37] 
        void doSystem()
       [line 38] 
        void multipleAlignMenu()
       [line 39] 
        void profileAlignMenu()
       [line 40] 
        void ssOptionsMenu()
       [line 41] 
        int secStrOutputOptions()
       [line 42] 
        void phylogeneticTreeMenu()
       [line 43] 
        void treeFormatOptionsMenu()
       [line 44] 
        void formatOptionsMenu()
       [line 45]  
        void pairwiseMenu()
       [line 46] 
        void multiMenu()
       [line 47] 
        void gapPenaltiesMenu()
       [line 48] 
        int readMatrix(int alignResidueType, int alignType, MatMenu menu)
       [line 49] 
        void clusteringAlgorithmMenu()
       [line 50] 
        void iterationMenu()
  |- CommandLineParser.cpp
    -> Found 151 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 108]  new Clustal()
       [line 111]  new StringArray(3)
       [line 112]  new StringArray(3)
       [line 113]  new StringArray(3)
       [line 114]  new StringArray(3)
       [line 115]  new StringArray(3)
       [line 116]  new StringArray(3)
       [line 117]  new StringArray(3)
       [line 118]  new StringArray(7)
       [line 119]  new StringArray(5)
       [line 120]  new StringArray(5)
       [line 121]  new StringArray(6)
       [line 122]  new StringArray(3)
       [line 123]  new StringArray(4)
       [line 308]  FIXME: final ctr index is hardcoded in CommandLineParser
    
    parseParams(args, xmenus)
       [line 316]  NOTE any dynamically allocated memory (new)
       [line 337]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 409]  need to check maxseqlen before reading input file
    if (setMaxSeqLen != -1)
       [line 412]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 455]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 467] 
            else if(temp == 1)
       [line 471] 
            else if(temp == 2)
       [line 485]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 556]  the automatic checking (DNA or Protein)
       [line 571] 
            else if(temp == 1)
       [line 584]  DEBUGFULL 
                if(logObject && DEBUGLOG)
       [line 599]  moved to checkParam()
       [line 619]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 622]  file name (seqName)
       [line 676]  profile file (profile 2)
       [line 833] 
        else if(profileType == SEQUENCE)
       [line 861] 
        else if(profileType == SEQUENCE)
       [line 888] 
        else if(profileType == SEQUENCE)
       [line 916] 
        else if(profileType == SEQUENCE)
       [line 950]  NOTE 
    if(userParameters->getDNAFlag()
       [line 972]  input file(s)
       [line 983]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 986]  doing the requested task(s)
       [line 992]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1000]  DEBUGFULL 
                if(logObject && DEBUGLOG)
       [line 1010]  DEBUGFULL 
                if(logObject && DEBUGLOG)
       [line 1018] 

    else if(doAlign)
       [line 1022]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1029] 

    else if(doConvert)
       [line 1033]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1040] 

    else if (doAlignUseOldTree)
       [line 1044]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1051] 

    else if(doGuideTreeOnly)
       [line 1055]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1062] 

    else if(doTreeFromAlign)
       [line 1066]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1074] 

    else if(doBootstrap)
       [line 1078]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1104]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 1117]  AW: first arg is an input file if it doesnt start with commandsep
    if (VALID_COMMAND_SEP.find((*args)
       [line 1137]  because each option should begin with commandsep
                (*params)
       [line 1147]  extract paramArgs in next step

    
    if (args->size()
       [line 1162]  Andreas Wilm (UCD)
       [line 1168]  UNIX
           if(logObject && DEBUGLOG)
       [line 1198]  Andreas Wilm (UCD)
       [line 1199]  this convert nonarg params to lowercase (-QuIcKtReE etc)
       [line 1240]  Andreas Wilm (UCD)
       [line 1245]  UNIX
                 * else if (cmdLinePara[match[i]].type != FILARG && (*paramArg)
       [line 1250]  else if (cmdLinePara[match[i]].type != FILARG && (*paramArg)
       [line 1253]  lowercase arg if not a filename to support mixed case
                        (*paramArg)
       [line 1359]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 1373]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1408]  DEBUGFULL 
                    if(logObject && DEBUGLOG)
       [line 1414] 
            else if(temp == 1)
       [line 1418]  DEBUGFULL 
                    if(logObject && DEBUGLOG)
       [line 1428]  DEBUGFULL 
                    if(logObject && DEBUGLOG)
       [line 1441]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1466]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1478] 
            else if(temp == 1)
       [line 1492]  GDE or PHYLIP *
    if(setOutput != -1)
       [line 1496]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1542]  or PHYLIP or DIST or NEXUS 
    if(setOutputTree != -1)
       [line 1545]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1578]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1590]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1603]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1647]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1686]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1726]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1765]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1777]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1789]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1801]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1814]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1827] 
            else if (_matrixname.compare("pam")
       [line 1831] 
            else if (_matrixname.compare("gonnet")
       [line 1835] 
            else if (_matrixname.compare("id")
       [line 1850] 
                else 
                    exit(1)
       [line 1861]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1875] 
            else if (_matrixname.compare("pam")
       [line 1879] 
            else if (_matrixname.compare("gonnet")
       [line 1883] 
            else if (_matrixname.compare("id")
       [line 1898] 
                else 
                    exit(1)
       [line 1908]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1922] 
            else if (_matrixname.compare("clustalw")
       [line 1937] 
                else 
                    exit(1)
       [line 1947]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 1961] 
            else if (_matrixname.compare("clustalw")
       [line 1976] 
                else 
                    exit(1)
       [line 1984]  n
    if(setMaxDiv != -1)
       [line 1987]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2008]  n
    if(setGapDist != -1)
       [line 2011]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2031]  n 
    if(setDebug != -1)
       [line 2050]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2065]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2077] 
            else if(temp == 1)
       [line 2092]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2104] 
            else if(temp == 1)
       [line 2119]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2135] 
            else if(temp == 1)
       [line 2151]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2182]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2215]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2249]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2271]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2306]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2342]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2357] 
        else if(temp == 1)
       [line 2372]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2387] 
        else if(temp == 1)
       [line 2401]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2414]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2427]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2440]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2454]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2468]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2481]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2494]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2516]  n
    if(setHelixGap != -1)
       [line 2519]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2541]  n 
    if(setStrandGap != -1)
       [line 2544]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2566]  n 
    if(setLoopGap != -1)
       [line 2569]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2591]  n
    if(setTerminalGap != -1)
       [line 2594]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2616]  n
    if(setHelixEndIn != -1)
       [line 2619]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2641]  n
    if(setHelixEndOut != -1)
       [line 2644]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2666]  n 
    if(setStrandEndIn != -1)
       [line 2669]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 2691]  n 
    if(setStrandEndOut != -1)
       [line 2694]  DEBUGFULL 
            if(logObject && DEBUGLOG)
    -> Referências importantes (com snippet):
       [Marcador de problema] line 218: 'FIXME'
         [ 215]     cmdLineFile[ctr++] = getCmdLineDataStruct("profile1", &setProfile1, FILARG, NULL);
         [ 216]     cmdLineFile[ctr++] = getCmdLineDataStruct("profile2", &setProfile2, FILARG, NULL);
         [ 217]     cmdLineFile[ctr++] = getCmdLineDataStruct("", NULL, -1, NULL);
         [ 218]     // FIXME: final ctr index is hardcoded in CommandLineParser
         [ 219] 
         [ 220]     ctr=0;
         [ 221]     cmdLineVerb[ctr++] = getCmdLineDataStruct("help", &setHelp, NOARG, NULL);
       [Marcador de problema] line 243: 'FIXME'
         [ 240]     cmdLineVerb[ctr++] = getCmdLineDataStruct("iteration", &setDoIteration,
         [ 241]                                            OPTARG, iterationArg);
         [ 242]     cmdLineVerb[ctr++] = getCmdLineDataStruct("", NULL, -1, NULL);
         [ 243]     // FIXME: final ctr index is hardcoded in CommandLineParser.h
         [ 244] 
         [ 245]     // NOTE Start back here!!!!!!!!!!!!
         [ 246]     ctr=0;
       [Marcador de problema] line 308: 'FIXME'
         [ 305]     cmdLinePara[ctr++] = getCmdLineDataStruct("maxseqlen", &setMaxSeqLen, INTARG, NULL);
         [ 306]     cmdLinePara[ctr++] = getCmdLineDataStruct("stats", &setStatsFile, FILARG, NULL);
         [ 307]     cmdLinePara[ctr++] = getCmdLineDataStruct("", NULL, -1, NULL);
         [ 308]     // FIXME: final ctr index is hardcoded in CommandLineParser
         [ 309] 
         [ 310]     parseParams(args, xmenus);
         [ 311] }
       [Marcador de problema] line 1536: 'FIXME'
         [1533]                     userParameters->setOutputFasta(true);
         [1534]                     break;
         [1535]                 default:
         [1536]                     // FIXME AW: 1.83 behaves the same, but shouldnt
         [1537]                     // we exit here?
         [1538]                     cout << "\nUnknown OUTPUT type: " << (*paramArg)[setOutput] << endl;
         [1539]             }
       [Marcador de problema] line 1117: 'AW:'
         [1114]         return 0;
         [1115]     }
         [1116] 
         [1117]     // AW: first arg is an input file if it doesnt start with commandsep
         [1118]     if (VALID_COMMAND_SEP.find((*args)[0][0], 0) == string::npos)
         [1119]     {
         [1120]         name1 = true;
       [Marcador de problema] line 1145: 'AW:'
         [1142]     num = i;
         [1143] 
         [1144] 
         [1145]     // AW:
         [1146]     // params are now setup
         [1147]     // extract paramArgs in next step
         [1148] 
       [Marcador de problema] line 1536: 'AW:'
         [1533]                     userParameters->setOutputFasta(true);
         [1534]                     break;
         [1535]                 default:
         [1536]                     // FIXME AW: 1.83 behaves the same, but shouldnt
         [1537]                     // we exit here?
         [1538]                     cout << "\nUnknown OUTPUT type: " << (*paramArg)[setOutput] << endl;
         [1539]             }
  |- InteractiveMenu.cpp
    -> Found 16 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 33]  new Clustal()
       [line 178] 
        else if(userParameters->getDoRemoveFirstIteration()
       [line 248] 

            default:
                fprintf(stdout, "\n\nUnrecognised Command\n\n")
       [line 718]  Create alignment output file(s)
       [line 803]  fixed << setprecision(2)
       [line 805]  fixed << setprecision(2)
       [line 941]  fixed << setprecision(2)
       [line 943]  fixed << setprecision(2)
       [line 949]  fixed << setprecision(2)
       [line 1151]  Select the matrix series to be using 
        if (option > 0 && option < menu.noptions)
       [line 1156] 
        else if (option == menu.noptions)
       [line 1165] 
        else
        switch (toupper(choice)
       [line 1243] 
        else if(userParameters->getDoRemoveFirstIteration()
       [line 1256]  Tree based iteration (iterates each profile alignment step)
       [line 1257]  Alignment iteration (iterates final alignment only)
  |- InteractiveMenu.o

[DIRECTORY] src/interface/.deps
  |- .dirstamp
  |- InteractiveMenu.Po
  |- CommandLineParser.Po

[DIRECTORY] src/multipleAlign
  |- ProfileAlignAlgorithm.h
    -> Found 2 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 17] 
    virtual int profileAlign(Alignment* alnPtr, DistMatrix* distMat, vector<int>* group, 
                             int* aligned)
  |- MyersMillerProfileAlign.o
  |- ProfileStandard.o
  |- ProfileWithSub.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 19] 
        void resetPrf1()
       [line 20] 
        void calcProfileWithSub(SeqArray* seqArray, vector<int>* gaps, 
                                int matrix[NUMRES][NUMRES], vector<int>* seqWeight)
  |- MyersMillerProfileAlign.h
    -> Found 16 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 20] 
        virtual int profileAlign(Alignment* alnPtr, DistMatrix* distMat, 
                                 vector<int>* group, int* aligned)
       [line 27] 
        void addGGaps(Alignment* alnPtr, SeqArray* seqArray)
       [line 28] 
        void addGGapsMask(vector<char>* mask,int len, vector<int>* path1, vector<int>* path2)
       [line 29] 
        int prfScore(int n, int m)
       [line 30] 
        int progTracepath()
       [line 31] 
        void progDel(int k)
       [line 32] 
        void progAdd(int k)
       [line 33] 
        void progAlign()
       [line 34] 
        int progDiff(int A, int B, int M, int N, int go1, int go2)
       [line 35] 

        int openPenalty1(int i, int j)
       [line 37] 
        int extPenalty1(int i, int j)
       [line 38] 
        int gapPenalty1(int i, int j, int k)
       [line 39] 
        int openPenalty2(int i, int j)
       [line 40] 
        int extPenalty2(int i, int j)
       [line 41] 
        int gapPenalty2(int i, int j, int k)
  |- MSA.o
  |- ProfileStandard.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- LowScoreSegProfile.o
  |- ProfileStandard.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 19] 
        void resetPrf2()
       [line 20] 
        void calcStandardProfile(SeqArray* alignment, vector<int>* seqWeight)
  |- ProfileWithSub.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- ProfileWithSub.o
  |- .dirstamp
  |- MyersMillerProfileAlign.cpp
    -> Found 10 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 84] 
        else if ((*group)
       [line 106] 
            else if ((*group)
       [line 285] 
            else if (len1 < len2)
       [line 325]  new ProfileWithSub(prfLength1, 0, nseqs1)
       [line 326]  new ProfileStandard(prfLength2, nseqs1, nseqs1 + nseqs2)
       [line 852] 
            else if (alnPath1[i] == 1)
       [line 895] 
            else if (alnPath2[i] == 1)
       [line 970] 
            else if ((*path1)
       [line 985] 
            else if ((*path2)
  |- ProfileBase.o
  |- ProfileBase.cpp
    -> Found 8 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 77]  Check for a gap penalty mask

    if (useStructPenalties != false)
       [line 83] 
    else if (userParameters->getNoVarPenalties()
       [line 155]  mark the residues close to an existing gap (set gaps[i] = -ve)
       [line 243]  apply the gap penalty mask
        
        if (useStructPenalties != NONE)
       [line 255]  positions
        
        if (profile[j + 1][GAPCOL] <= 0)
       [line 267]  set the penalties at the beginning and end of the profile
    if(userParameters->getEndGapPenalties()
       [line 399] 
    string _hydResidues(userParameters->getHydResidues()
  |- MSA.h
    -> Found 5 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 23] 
        int multiSeqAlign(Alignment* alnPtr, DistMatrix* distMat, 
            vector<int>* seqWeight, AlignmentSteps* progSteps, int iStart)
       [line 25] 
        int seqsAlignToProfile(Alignment* alnPtr, DistMatrix* distMat, vector<int>* seqWeight, int iStart, 
                              string phylipName)
       [line 27] 
        int calcPairwiseForProfileAlign(Alignment* alnPtr, DistMatrix* distMat)
       [line 28] 
        int doProfileAlign(Alignment* alnPtr, DistMatrix* distMat, vector<int>* prof1Weight,
                           vector<int>* prof2Weight)
  |- Iteration.o
  |- Iteration.h
    -> Found 4 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 17] 
        bool iterationOnTreeNode(int numSeqsProf1, int numSeqsProf2, int& prfLength1,
                                    int& prfLength2, SeqArray* seqArray)
       [line 19] 
        bool removeFirstIterate(Alignment* alnPtr)
       [line 20] 
    private:
        void printSeqArray(SeqArray* arrayToPrint)
  |- Iteration.cpp
    -> Found 4 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 69] 
            else if(j < numSeqsProf1 + numSeqsProf2)
       [line 84]  I need to recalculate the prfLength1 and prfLength2
            (*seqArray)
       [line 240]  new MSA()
  |- LowScoreSegProfile.cpp
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- ProfileBase.h
    -> Found 9 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 23] 
        void calcGapCoeff(SeqArray* seqArray, vector<int>* gaps,  bool useStructPenalties,
                          vector<char>* gapPenaltyMask, int gapCoef, int lenCoef)
       [line 25] 
        const SeqArray* getProfilePtr()
       [line 26] 
        void resetProfile()
       [line 36] 
        void calcVPenalties(SeqArray* aln, vector<int>* weight)
       [line 37]  
        void calcResidueSpecificPen(SeqArray* aln, vector<int>* weight)
       [line 38]  
        void calcHydrophilicPen(SeqArray* aln, vector<int>* weight)
       [line 39]  
        int localPenalty(int penalty, int n, vector<int>* resWeight, vector<int>* hydWeight,
                         vector<int>* vWeight)
       [line 41]   
        float percentId(vector<int>* s1, vector<int>* s2)
  |- LowScoreSegProfile.h
    -> Found 3 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 22] 
        void calcLowScoreSegProfile(const SeqArray* seqArray, 
                                int matrix[NUMRES][NUMRES], vector<int>* seqWeight)
       [line 24] 
        const SeqArray* getProfilePtr()
  |- MSA.cpp
    -> Found 10 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 53] 
    
    vector<int> newOutputIndex(_numSeqs)
       [line 75]  group the sequences according to their relative divergence

    if (iStart == 0)
       [line 135]  DEBUGFULL
                    if(logObject && DEBUGLOG)
       [line 203]  two most closely related sequences now
    if (ix == 0)
       [line 264]  multiply sequence weights from tree by percent identity with new sequence 
        if (userParameters->getNoWeights()
       [line 313] 
            else if (iseq == j)
       [line 380]  weights in global variable seq_weight normalised to sum to 100
    vector<int> newOutputIndex(_numSeqs)
       [line 464] 
            else if (iseq == j)
       [line 475]  identity with new sequence 

        for (j = 0; j < _numSeqs; j++)

[DIRECTORY] src/multipleAlign/.deps
  |- ProfileBase.Po
  |- LowScoreSegProfile.Po
  |- .dirstamp
  |- ProfileWithSub.Po
  |- MyersMillerProfileAlign.Po
  |- MSA.Po
  |- Iteration.Po
  |- ProfileStandard.Po

[DIRECTORY] src/pairwise
  |- FastPairwiseAlign.o
  |- FastPairwiseAlign.cpp
    -> Found 9 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 147]  This is bad and will have to be changed (later)
       [line 150]  In the best case the results of the 
 * fast alignment (of DNA)
       [line 155]  This is awfull (it is not OO compliant)
       [line 158]  but this requires changes 
 * to (i)
       [line 162]                 A  B  C  D  E  F  G  H  I  K  L  M  0  N  P  Q  R  S 
 *                T  U  W  X  Y  Z (goodmeasuregoodmeasuregood)
       [line 209]  increment diagonal score for each k_tuple match 

    for (i = 1; i <= limit; ++i)
       [line 231]  choose the top SIGNIF diagonals 

    desQuickSort(displ, diagIndex, tl1)
       [line 241]  flag all diagonals within WINDOW of a top diagonal

    for (i = tl1; i >= j; i--)
  |- .dirstamp
  |- FullPairwiseAlign.cpp
    -> Found 4 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 473]  Divide: Find optimum midpoint (midi,midj)
       [line 588]  Conquer recursively around midpoint 


    if (type == 1)
       [line 593]  Type 1 gaps
        diff(A, B, midi, midj, tb, _gapOpen)
  |- FastPairwiseAlign.h
    -> Found 8 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18] 
        virtual void pairwiseAlign(Alignment *alignPtr, DistMatrix *distMat, int iStart, 
                                   int iEnd, int jStart, int jEnd)
       [line 24] 
        void pairAlign(const vector<int>* seq, int l1, int l2)
       [line 25]  
        void makePPtrs(vector<int>& tptr, vector<int>& pl, const vector<int>* seq, 
                       int length)
       [line 27]  
        void makeNPtrs(vector<int>& tptr, vector<int>& pl, const vector<int>* seq, 
                       int length)
       [line 29] 
        void putFrag(int fs, int v1, int v2, int flen)
       [line 30] 
        int fragRelPos(int a1, int b1, int a2, int b2)
       [line 31] 
        void desQuickSort(vector<int>& array1, vector<int>& array2, int arraySize)
  |- FullPairwiseAlign.h
    -> Found 12 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18] 
        virtual void pairwiseAlign(Alignment *alignPtr, DistMatrix *distMat, int iStart, 
                                   int iEnd, int jStart, int jEnd)
       [line 24] 
        void add(int v)
       [line 25] 
        int calcScore(int iat, int jat, int v1, int v2)
       [line 26]  
        float tracePath(int tsb1, int tsb2)
       [line 27] 
        void forwardPass(const vector<int>* seq1, const vector<int>* seq2, int n, int m)
       [line 28] 
        void reversePass(const vector<int>* ia, const vector<int>* ib)
       [line 29] 
        int diff(int A, int B, int M, int N, int tb, int te)
       [line 30] 
        void del(int k)
       [line 31] 
        int gap(int k)
       [line 32] 
        int tbgap(int k, int tb)
       [line 33] 
        int tegap(int k, int te)
  |- FullPairwiseAlign.o
  |- PairwiseAlignBase.h
    -> Found 2 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18] 
        virtual void pairwiseAlign(Alignment *alignPtr, DistMatrix *distMat, int iStart, 
                                   int iEnd, int jStart, int jEnd)

[DIRECTORY] src/pairwise/.deps
  |- .dirstamp
  |- FastPairwiseAlign.Po
  |- FullPairwiseAlign.Po

[DIRECTORY] src/paralel
  |- 100_1800.dnd
  |- 100_1800.fa
  |- 100_1000.dnd
  |- 100_500.fa
  |- 100_1800.aln
  |- 100_500.aln
  |- 100_1000.aln
  |- 100_1000.fa
  |- 100_500.dnd

[DIRECTORY] src/.deps
  |- RSFFileParser.Po
  |- ProfileBase.Po
  |- InFileStream.Po
  |- Utility.Po
  |- PIRFileParser.Po
  |- FileReader.Po
  |- main.Po
  |- Help.Po
  |- SubMatrix.Po
  |- EMBLFileParser.Po
  |- LowScoreSegProfile.Po
  |- AlignmentOutput.Po
  |- Alignment.Po
  |- OutputFile.Po
  |- RootedClusterTree.Po
  |- AlignmentSteps.Po
  |- NJTree.Po
  |- TreeInterface.Po
  |- .dirstamp
  |- VectorOutOfRange.Po
  |- InteractiveMenu.Po
  |- Stats.Po
  |- FastPairwiseAlign.Po
  |- GDEFileParser.Po
  |- PearsonFileParser.Po
  |- UnRootedClusterTree.Po
  |- InvalidCombination.Po
  |- SymMatrix.Po
  |- ObjectiveScore.Po
  |- ProfileWithSub.Po
  |- UPGMAAlgorithm.Po
  |- MyersMillerProfileAlign.Po
  |- RootedTreeOutput.Po
  |- Clustal.Po
  |- MSA.Po
  |- FileParser.Po
  |- Iteration.Po
  |- Tree.Po
  |- CommandLineParser.Po
  |- MSFFileParser.Po
  |- ClusterTreeOutput.Po
  |- Sequence.Po
  |- RandomGenerator.Po
  |- ClusterTree.Po
  |- ClustalWResources.Po
  |- UserParameters.Po
  |- FullPairwiseAlign.Po
  |- DebugLog.Po
  |- ProfileStandard.Po
  |- Node.Po
  |- RootedGuideTree.Po
  |- cudaMultiSeqAlign.Po
  |- ClustalFileParser.Po

[DIRECTORY] src/substitutionMatrix
  |- .dirstamp
  |- SubMatrix.cpp
    -> Found 87 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 41]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 54]  new Matrix(blosum30mt, blosum30mt + sizenAAMatrix)
       [line 55]  new Matrix(blosum40mt, blosum40mt + sizenAAMatrix)
       [line 56]  new Matrix(blosum45mt, blosum45mt + sizenAAMatrix)
       [line 57]  new Matrix(blosum62mt2, blosum62mt2 + sizenAAMatrix)
       [line 58]  new Matrix(blosum80mt, blosum80mt + sizenAAMatrix)
       [line 59]  new Matrix(pam20mt, pam20mt + sizenAAMatrix)
       [line 60]  new Matrix(pam60mt, pam60mt + sizenAAMatrix)
       [line 61]  new Matrix(pam120mt, pam120mt + sizenAAMatrix)
       [line 62]  new Matrix(pam350mt, pam350mt + sizenAAMatrix)
       [line 63]  new Matrix(idmat, idmat + sizenAAMatrix)
       [line 64]  new Matrix(gon40mt, gon40mt + sizenAAMatrix)
       [line 65]  new Matrix(gon80mt, gon80mt + sizenAAMatrix)
       [line 66]  new Matrix(gon120mt, gon120mt + sizenAAMatrix)
       [line 67]  new Matrix(gon160mt, gon160mt + sizenAAMatrix)
       [line 68]  new Matrix(gon250mt, gon250mt + sizenAAMatrix)
       [line 69]  new Matrix(gon350mt, gon350mt + sizenAAMatrix)
       [line 70]  new Matrix(clustalvdnamt, clustalvdnamt + sizeDNAMatrix)
       [line 71]  new Matrix(swgapdnamt, swgapdnamt + sizeDNAMatrix)
       [line 110]  new string("gonnet")
       [line 112]  new string("iub")
       [line 114]  new string("gonnet")
       [line 116]  new string("iub")
       [line 264]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 283]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 295] 
        else if (pwDNAMatrixName->compare("clustalw")
       [line 328]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 341] 
        else if (pwMatrixName->compare("pam")
       [line 347] 
        else if (pwMatrixName->compare("gonnet")
       [line 354] 
        else if (pwMatrixName->compare("id")
       [line 376]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 415]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 423]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 437] 
        else if (DNAMatrixName->compare("clustalw")
       [line 477]  DEBUGFULL 
            if(logObject && DEBUGLOG)
       [line 494] 
            else if (pcid > 80.0)
       [line 499] 
            else if (pcid > 60.0)
       [line 504] 
            else if (pcid > 40.0)
       [line 509] 
            else if (pcid > 30.0)
       [line 515] 
            else if (pcid > 20.0)
       [line 530] 
        else if (matrixName->compare("pam")
       [line 538] 
            else if (pcid > 80.0)
       [line 543] 
            else if (pcid > 60.0)
       [line 548] 
            else if (pcid > 40.0)
       [line 561] 
        else if (matrixName->compare("gonnet")
       [line 569] 
            else if (pcid > 35.0)
       [line 575] 
            else if (pcid > 25.0)
       [line 605] 
        else if (matrixName->compare("id")
       [line 612] 
        else if (userSeries)
       [line 663]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 817]  DO THE SAGA MATRIX
        for (i = 0; i <= userParameters->getMaxAA()
       [line 925] 
    ofstream outfile("getmatrix.out")
       [line 1063]  lower limit is greater than upper (%d-%d)
       [line 1153]  j < strlen(inline1)
       [line 1236]  i < strlen(args[farg])
       [line 1353]  new string(_matrixName)
       [line 1354] 
    else if((alignResidueType == Protein)
       [line 1359]  new string(_matrixName)
       [line 1360] 
    else if((alignResidueType == DNA)
       [line 1365]  new string(_matrixName)
       [line 1366] 
    else if((alignResidueType == DNA)
       [line 1371]  new string(_matrixName)
       [line 1375]  DEBUGFULL 
        if(logObject && DEBUGLOG)
       [line 1400] 
    else if((alignResidueType == Protein)
       [line 1404] 
    else if((alignResidueType == DNA)
       [line 1408] 
    else if((alignResidueType == DNA)
       [line 1451] 

    ofstream outfile(nameOfFile)
       [line 1481]  Check to see if the next element is the last element
        if((i + 1)
       [line 1495] 
    
    ofstream outfile2("temp.out")
       [line 1514] 

    ofstream outfile(nameOfFile)
       [line 1547] 
    else if((alignResidueType == Protein)
       [line 1551] 
    else if((alignResidueType == DNA)
       [line 1555] 
    else if((alignResidueType == DNA)
       [line 1574] 
    else if((alignResidueType == Protein)
       [line 1578] 
    else if((alignResidueType == DNA)
       [line 1582] 
    else if((alignResidueType == DNA)
       [line 1599] 
        InvalidCombination ex(alignResidueType, alignType)
       [line 1670] 
        else if (QTDNAHistMatNum == DNACLUSTALW)
       [line 1688] 
        else if (QTAAHistMatNum == AAHISTGONNETPAM80)
       [line 1693] 
        else if (QTAAHistMatNum == AAHISTGONNETPAM120)
       [line 1698] 
        else if (QTAAHistMatNum == AAHISTUSER)
       [line 1703] 
        else if (QTAAHistMatNum == AAHISTGONNETPAM350)
       [line 1734] 
        else if (QTsegmentDNAMatNum == DNACLUSTALW)
       [line 1776] 
        else if (QTsegmentAAMatNum == QTAASEGGONNETPAM120)
       [line 1781] 
        else if (QTsegmentAAMatNum == QTAASEGUSER)
       [line 1786] 
        else if (QTsegmentAAMatNum == QTAASEGGONNETPAM350)
  |- SubMatrix.h
    -> Found 41 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 12]  or they can select one of the matrix series (e.g Blosum)
       [line 45] 
        
        bool getUserMatFromFile(char *str, int alignResidueType, int alignType)
       [line 47] 
        bool getAAScoreMatFromFile(char *str)
       [line 48] 
        bool getDNAScoreMatFromFile(char *str)
       [line 49] 
        bool getQTLowScoreMatFromFile(char *fileName, bool dna)
       [line 50] 
        bool getUserMatSeriesFromFile(char *str)
       [line 51] 
        void setCurrentNameAndNum(string _matrixName, int _matrixNum, int alignResidueType,
                                  int alignType)
       [line 53] 
        int getMatrixNumForMenu(int alignResidueType, int alignType)
       [line 54] 
        int getPairwiseMatrix(int matrix[NUMRES][NUMRES], PairScaleValues& scale, 
                              int& matAvg)
       [line 56] 
        int getProfileAlignMatrix(int matrix[NUMRES][NUMRES], double pcid, int minLen, 
                                  PrfScaleValues& scaleParam, int& matAvg)
       [line 58] 
        int getAlnScoreMatrix(int matrix[NUMRES][NUMRES])
       [line 60]  
        int getMatrixNum()
       [line 61] 
        int getDNAMatrixNum()
       [line 62] 
        int getPWMatrixNum()
       [line 63] 
        int getPWDNAMatrixNum()
       [line 64] 
        void getQTMatrixForHistogram(int matrix[NUMRES][NUMRES])
       [line 66]  NOTE Qt
        int getQTAAHistMatNum()
       [line 67] 
        int getQTDNAHistMatNum()
       [line 68] 
        void setQTAAHistMatNum(int num)
       [line 69] 
        void setQTDNAHistMatNum(int num)
       [line 70] 

        void getQTMatrixForLowScoreSeg(int matrix[NUMRES][NUMRES])
       [line 72] 
        int getQTsegmentDNAMatNum()
       [line 73] 
        void setQTsegmentDNAMatNum(int dnaMat)
       [line 74] 
        int getQTsegmentAAMatNum()
       [line 75] 
        void setQTsegmentAAMatNum(int aaMat)
       [line 76] 
        
        void tempInterface(int alignResidueType, int alignType)
       [line 78] 
        void setValuesToDefault()
       [line 84] 
        int getMatrix(Matrix* matPtr, Xref* xref, int matrix[NUMRES][NUMRES],
                      bool negFlag, int scale, bool minimise = false)
       [line 86]  
        int readMatrixSeries(const char *fileName, Matrix& userMat, Xref& xref)
       [line 87] 
        int readUserMatrix(const char *fileName, Matrix& userMat, Xref& xref)
       [line 88] 
        int getArgs(char *inline1, char *args[], int max)
       [line 89] 
        void setUpCrossReferences()
       [line 90] 
        bool commentline(char* line)
       [line 93] 
        void printGetMatrixResults(int mat[NUMRES][NUMRES])
       [line 94]  
        void compareMatrices(int mat1[NUMRES][NUMRES], int mat2[NUMRES][NUMRES])
       [line 95]  
        void printInFormat(vector<short>& temp, char* name = "tempfile.out")
       [line 96] 
        void printVectorToFile(vector<short>& temp, char* name = "tempfile.out")
       [line 97] 
        Matrix* getUserMatAddress(int alignResidueType, int alignType)
       [line 98] 
        Xref* getUserXrefAddress(int alignResidueType, int alignType)
       [line 99] 
        void checkResidueAndAlignType(int alignResidueType, int alignType)
  |- matrices.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
  |- SubMatrix.o
  |- globalmatrix.h
    -> Found 1 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)

[DIRECTORY] src/substitutionMatrix/.deps
  |- SubMatrix.Po
  |- .dirstamp

[DIRECTORY] src/alignment
  |- Sequence.h
    -> Found 11 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 34] 
        void encodeSequence()
       [line 35] 
        void printSequence()
       [line 36] 
        std::vector<int>* getSequence()
       [line 37] 
        bool isEmpty()
       [line 38] 
        std::string getName()
       [line 39] 
        std::string getTitle()
       [line 40] 
        bool checkDNAFlag()
       [line 41] 
        unsigned long getIdentifier()
       [line 46] 
        void checkIntegrity()
       [line 47] 
        void copyStringIntoVector(std::vector<char>* _vectorTo, std::string* _stringFrom)
  |- Alignment.cpp
    -> Found 43 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 12]  modified searchForString()
       [line 16]  added testUniqueNames()
       [line 43]  Andreas Wilm (UCD)
       [line 44]  remove gaps from older alignments (code = gap_pos1)
       [line 109]  Andreas Wilm (UCD)
       [line 119]  Andreas Wilm (UCD)
       [line 186]  Andreas Wilm (UCD)
       [line 211]  Check if the size is correct
    if(outputIndexToAdd->size()
       [line 232]  Check if the size is correct
    if((outputIndexToAppend->size()
       [line 377] 
        return string()
       [line 379] 
        return string()
       [line 400]  over new candidate names
    for (newName = seqVector->begin()
       [line 402]  over old stored names
        for (oldName = names.begin()
       [line 611]  remove gaps from older alignments (code = gap_pos1)
       [line 642]  Andreas Wilm (UCD)
       [line 658]  j < getSeqLength(1)
       [line 669]  j < getSeqLength(1)
       [line 909]  std::left << setw(maxNames)
       [line 910]  std::right << setw(6)
       [line 921]  std::left << setw(maxNames)
       [line 922]  std::right << setw(6)
       [line 1009] 
        throw VectorOutOfRange(string("secStructMask1")
       [line 1021] 
        throw VectorOutOfRange(string("secStructMask2")
       [line 1033] 
        throw VectorOutOfRange(string("gapPenaltyMask1")
       [line 1045] 
        throw VectorOutOfRange(string("gapPenaltyMask2")
       [line 1057] 
        throw VectorOutOfRange(string("names")
       [line 1073] 
        throw VectorOutOfRange(string("sequenceIds")
       [line 1085] 
        throw VectorOutOfRange(string("titles")
       [line 1097] 
        throw VectorOutOfRange(string("outputIndex")
       [line 1109] 
        throw VectorOutOfRange(string("seqWeight")
       [line 1254] 
        else if(n % 2 == 0)
       [line 1286] 
            else if(t - (int)
       [line 1312]  p < getSeqLength(s + 1)
       [line 1389]  nige
            for(int i = 0; i < searchSize && (i + res)
       [line 1396] 
                else if (seqArray[seq][res + i] == 31 || seqArray[seq][res + i] == 30)
       [line 1632] 
            Sequence SeqToCut(&seqArray[i - numCutSoFar], *namesIterator, *titlesIterator, 
                              *sequenceIdsIterator)
       [line 1687]  endPos > getLengthLongestSequence()
       [line 1700]  recalculate the maxLengths
    calculateMaxLengths()
       [line 1706]  reset the weights
    resetAllSeqWeights()
       [line 1961]  Remove all the elements from the old ones and set them to be these arrays
    clearSeqArray()
       [line 1977] 
            return getSequence(i)
       [line 1982] 
    throw SequenceNotFoundException()
  |- .dirstamp
  |- AlignmentOutput.o
  |- AlignmentOutput.cpp
    -> Found 60 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 11]  clustalx code used (firsRes, length)
       [line 12]  while the port uses (firsRes, lastRes)
       [line 555] 
    else if (userParameters->getMenuFlag()
       [line 600]  round to a multiple of 10
        if (lineLength > LINELENGTH || lineLength <= 0)
       [line 611]  nige
            for(j = firstRes; j <= lastRes; j++)
       [line 626] 
                else if((val < 0)
       [line 715]  nige
            for(j = firstRes; j <= lastRes; j++)
       [line 730] 
                else if((val < 0)
       [line 741]  to make all sequences the same length 
            for(; j <= firstRes + lastRes - 1; j++)
       [line 772]  nige

        for(ii = firstSeq; ii <= lastSeq; ii++)
       [line 780]  nige
                          << setw(5)
       [line 782]  fixed << setprecision(1)
       [line 786]  nige
        if(length % GCG_LINELENGTH != 0)
       [line 796]  nige
            
            for(ii = firstSeq; ii <= lastSeq; ii++)
       [line 826]  characters to end 
            
                    if (j + firstRes - 1 <= alignPtr->getSeqLength(i)
       [line 840] 
                    else if((val < 0)
       [line 939]  nige
        if(length % GCG_LINELENGTH != 0)
       [line 1000] 
                    else if((val < 0)
       [line 1058]  nige
        if(length % GCG_LINELENGTH != 0)
       [line 1086]  nige
            for(ii = firstSeq; ii <= lastSeq; ii++)
       [line 1127] 
                    else if((val < 0)
       [line 1192]  round to a multiple of 10
        if (lineLength > LINELENGTH || lineLength <= 0)
       [line 1198]  set it up
        if (userParameters->getStructPenalties1()
       [line 1213]  set it up
        if (userParameters->getStructPenalties2()
       [line 1249]  nige
            for(j = firstRes; j <= lastRes; j++)
       [line 1264] 
                else if((val < 0)
       [line 1302]  nige
                for(i = firstRes; i <= lastRes; i++)
       [line 1333]  nige
                for(i = firstRes; i <= lastRes; i++)
       [line 1348]  nige
                for(i = 1; i <= length; i++)
       [line 1352]  nige
                    if((i % lineLength == 0)
       [line 1370]  nige
                for(i = firstRes; i <= lastRes; i++)
       [line 1385]  nige
                for(i = 1; i <= length; i++)
       [line 1389]  nige
                    if((i % lineLength == 0)
       [line 1403]  nige
                for(i = firstRes; i < length; i++)
       [line 1418]  nige
                for(i = 1; i <= length; i++)
       [line 1422]  nige
                    if((i % lineLength == 0)
       [line 1475]  round to a multiple of 10
        if (lineLength > LINELENGTH || lineLength <= 0)
       [line 1486]  nige

        for(ii = firstSeq; ii <= lastSeq; ii++)
       [line 1507]  nige
            for(j = firstRes; j <= lastRes; j++)
       [line 1523] 
                else if((val < 0)
       [line 1607]  _numSequences
        if(lastSeq > _numSequences)
       [line 1619]  NOTE june29
                if((val >= 0)
       [line 1671]  round to a multiple of 10
        if (lineLength > LINELENGTH || lineLength <= 0)
       [line 1679]  nige
        if(length % lineLength != 0)
       [line 1711]  Check if we can access mask position first
                        if(ss_mask1.size()
       [line 1892] 
                    else if((val < 0)
       [line 1986]  NOTE june29
                        if(((*alignment)
       [line 1991]  Count how many are identical to the first sequence
                            if((*alignment)
       [line 2036] 
                else if (!userParameters->getDNAFlag()
       [line 2114]  NOTE I have had to use (*structMask)
       [line 2162] 
            else if (tolower(mask->at(i)
       [line 2264]  NOTE june29
            if ((val < 0)
       [line 2286] 
            else if((val < 0)
       [line 2415] 
    else if(userParameters->getOutputNbrf()
       [line 2419] 
    else if(userParameters->getOutputGCG()
       [line 2423] 
    else if(userParameters->getOutputPhylip()
       [line 2427] 
    else if(userParameters->getOutputGde()
       [line 2431] 
    else if(userParameters->getOutputNexus()
       [line 2435] 
    else if(userParameters->getOutputFasta()
  |- Sequence.o
  |- Sequence.cpp
    -> Found 2 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 192]  of all characters (except -)
  |- Alignment.o
  |- ObjectiveScore.h
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 27]    
    public:
        ObjectiveScore()
       [line 29] 
        long getScore(const Alignment* alnToScore)
       [line 30]     
    private:
        
        float scoreLetters(int seq1, int seq2)
       [line 33] 
        float scoreGaps(int seq1, int seq2)
       [line 34] 
        void calcNormalisedSeqWeights(const vector<int>* seqWeight, 
                                      vector<float>* normSeqWeight)
  |- Alignment.h
    -> Found 91 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 23]  added testUniqueNames()
       [line 49]  sequences it would be nice to have a isAligned flag here (AW)
       [line 62] 
        void addSequences(vector<Sequence>* seqVector)
       [line 63] 
        void addSequences(SeqArray* seqVector)
       [line 64] 
        void appendSequences(vector<Sequence>* seqVector)
       [line 65] 
        vector<Sequence> cutSelectedSequencesFromAlignment(vector<int>* selected)
       [line 66]         
        void pasteSequencesIntoPosition(vector<Sequence>* seqVector, int pos, 
                                        bool explicitPasteToProfile2 = false)
       [line 68] 
                                        
        void resizeSeqArray(int size)
       [line 72] 
        bool addOutputIndex(vector<int>* outputIndexToAdd)
       [line 73] 
        bool appendOutputIndex(vector<int>* outputIndexToAppend)
       [line 74] 
        void addSecStructMask1(vector<char>* secStructMaskToAdd)
       [line 75] 
        void addSecStructMask2(vector<char>* secStructMaskToAdd)
       [line 76] 
        void addSeqWeight(vector<int>* _seqWeight)
       [line 77] 
        void addGapPenaltyMask1(vector<char>* gapPenaltyMaskToAdd)
       [line 78] 
        void addGapPenaltyMask2(vector<char>* gapPenaltyMaskToAdd)
       [line 79] 
        vector<char>* getSecStructMask1()
       [line 80] 
        vector<char>* getSecStructMask2()
       [line 81] 
        const vector<int>* getOutputIndex()
       [line 82] 
        vector<char>* getGapPenaltyMask1()
       [line 83] 
        vector<char>* getGapPenaltyMask2()
       [line 84]      
        void addSecStructName1(string nameToAdd)
       [line 85] 
        void addSecStructName2(string nameToAdd)
       [line 86] 
        int alignScore(void)
       [line 87] 
        int countGaps(int s1, int s2, int l)
       [line 88] 
        void resetAlign()
       [line 89] 
        void fixGaps()
       [line 90] 
        float countid(int s1, int s2)
       [line 91] 
        
        const vector<int>* getSequence(int index)
       [line 93] 
        const vector<int>* getSequence(int index)
       [line 94] 
        const vector<int>* getSequenceFromUniqueId(unsigned long id)
       [line 95]  For iteration        
        const SeqArray* getSeqArray()
       [line 96] 
        SeqArray* getSeqArrayForRealloc()
       [line 97] 
        void updateSequence(int index, const vector<int>* seq)
       [line 98] 
        
        void printSequences()
       [line 100] 
        bool checkAllNamesDifferent()
       [line 101] 
        bool testUniqueNames(vector<Sequence>* seqVector)
       [line 102] 
        void clearAlignment()
       [line 103] 
        void clearSecStruct1()
       [line 104] 
        void clearSecStruct2()
       [line 105] 
        void printAllNames()
       [line 106] 
        void printSequencesAddedInfo()
       [line 107] 
        
        string getSecStructName1()
       [line 109] 
        string getSecStructName2()
       [line 110]         
        int getNumSeqs()
       [line 111] 
        int getMaxNames()
       [line 112] 
        int getMaxAlnLength()
       [line 113] 
        void setMaxAlnLength(int len)
       [line 114]          
        int getLengthLongestSequence()
       [line 115] 
        int getLengthLongestSequence(int firstSeq, int lastSeq)
       [line 116] 
        int getSeqLength(int index)
       [line 117] 
        int getSecStructMask1Element(int index)
       [line 118] 
        int getSecStructMask2Element(int index)
       [line 119] 
        int getGapPenaltyMask1Element(int index)
       [line 120] 
        int getGapPenaltyMask2Element(int index)
       [line 121] 
        int getOutputIndex(int index)
       [line 122] 
        int getSeqWeight(int index)
       [line 123] 
        const vector<int>* getSeqWeights()
       [line 124] 
        string getName(int index)
       [line 125] 
        string getTitle(int index)
       [line 126] 
        vector<int>* QTcalcHistColumnHeights(int firstSeq, int nSeqs, 
                                           Array2D<int>* exceptionalRes)
       [line 132] 
        void resetProfile1()
       [line 133] 
        void resetProfile2()
       [line 134] 
        void resetAllSeqWeights()
       [line 135] 
        
        int searchForString(bool* found, int seq, int beginRes, string search)
       [line 137] 
        void removeGapsFromSelectedSeqs(vector<int>* selected)
       [line 138] 
        void removeGapOnlyColsFromSelectedSeqs(vector<int>* selected)
       [line 139] 
        void removeAllGapOnlyColumns(int fSeq, int lSeq, int profileNum)
       [line 140] 
        void setDefaultOutputIndex()
       [line 141] 
        bool removeAllOutsideRange(int beginPos, int endPos)
       [line 142] 
        bool updateRealignedRange(SeqArray realignedSeqs, int beginPos, int endPos)
       [line 143] 
        bool reloadAlignment()
       [line 144] 
        
        int getProfile1NumSeqs()
       [line 146] 
        void setProfile1NumSeqs(int value)
       [line 147] 
        bool isGap(int seq, int col)
       [line 151] 
        unsigned long getUniqueId(int seq)
       [line 152] 
        void printArray()
       [line 153] 
        void printSeqArray(SeqArray* arrayToPrint)
       [line 154] 
        void printProfile1()
       [line 155] 
        void printProfile2()
       [line 156] 
        void debugPrintOutAlignInfo()
       [line 157] 
        void calculateMaxLengths()
       [line 169] 
            public:
                void begin(Alignment *alignment)
       [line 171] 
                const string next()
       [line 172] 
                bool end()
       [line 177] 
        
        void addSequencesToVector(vector<Sequence>* seqVector)
       [line 179] 
        int getSequenceLength(int index)
       [line 180] 
        void sortScores(vector<float>* scores, int f, int l)
       [line 181] 
        void swap(vector<float>* scores, int s1, int s2)
       [line 182] 
        bool keepPortionOfSeqArray(int beginRangeIndex, int endRangeIndex)
       [line 183] 
        
        void clearSeqArray()
    -> Referências importantes (com snippet):
       [Marcador de problema] line 48: 'FIXME'
         [  45] #include "../general/SequenceNotFoundException.h"
         [  46] 
         [  47] 
         [  48] // FIXME because this object is used for aligned and unaligned
         [  49] // sequences it would be nice to have a isAligned flag here (AW)
         [  50] 
         [  51] using namespace std;
  |- AlignmentOutput.h
    -> Found 18 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 48] 
        bool openAlignmentOutput(string path)
       [line 49] 
        bool QTOpenFilesForOutput(AlignmentFileNames fileNames)
       [line 50] 
        void createAlignmentOutput(Alignment* alignPtr, int firstSeq, int lastSeq)
       [line 51] 
        void printSecStructMask(int prfLength, vector<char>* mask, vector<char>* structMask)
       [line 56] 
        void fastaOut(Alignment* alignPtr, outputRegion partToOutput)
       [line 57] 
        void clustalOut(Alignment* alignPtr, outputRegion partToOutput)
       [line 58] 
        void gcgOut(Alignment* alignPtr, outputRegion partToOutput)
       [line 59] 
        void nexusOut(Alignment* alignPtr, outputRegion partToOutput)
       [line 60] 
        void phylipOut(Alignment* alignPtr, outputRegion partToOutput)
       [line 61] 
        void nbrfOut(Alignment* alignPtr, outputRegion partToOutput)
       [line 62] 
        void gdeOut(Alignment* alignPtr, outputRegion partToOutput)
       [line 63] 
        string nameonly(string s)
       [line 64] 
        
        void findRangeValues(Alignment* alignPtr, rangeNum *rnum, int firstRes, int lastRes, 
                             int firstSeq)
       [line 67] 
        bool openExplicitFile(auto_ptr<ofstream>& outFile, string fileName)
       [line 68] 
        string openOutputFile(auto_ptr<ofstream>& outFile, string prompt, string path, 
                              string fileExtension)
       [line 70] 
        int SeqGCGCheckSum(vector<char>* sequence, int length)
       [line 71] 
        void showAlign()
  |- ObjectiveScore.cpp
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 31]  DEBUGFULL
        if(logObject && DEBUGLOG)
       [line 83]  DEBUGFULL
                if(logObject && DEBUGLOG)
       [line 99]  DEBUGFULL
        if(logObject && DEBUGLOG)
       [line 243] 
        else if(gap2)
       [line 283]  DEBUGFULL
        if(logObject && DEBUGLOG)
  |- ObjectiveScore.o

[DIRECTORY] src/alignment/.deps
  |- AlignmentOutput.Po
  |- Alignment.Po
  |- .dirstamp
  |- ObjectiveScore.Po
  |- Sequence.Po

[DIRECTORY] src/fileInput
  |- RSFFileParser.cpp
    -> Found 16 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 83] 
                    return Sequence(blank, blank, blank)
       [line 100] 
                return Sequence(blank, blank, blank)
       [line 111]  remember entryname
        for (i = 0; i <= strlen(_sname)
       [line 131] 
                return Sequence(blank, blank, blank)
       [line 145]  EOL
                if (c == '.')
       [line 166]  return empty seq
            return Sequence(blank, blank, blank)
       [line 168] 
        return Sequence(characterSeq, name, title)
       [line 194]  start at the beginning
                
        if(!_fileIn->is_open()
       [line 201]  skip the comments 
        while (_fileIn->getline(_line, MAXLINE + 1)
       [line 257]  skip the comments 
        while (_fileIn->getline(_line, MAXLINE + 1)
       [line 266]  find the start of the sequence entry 
        for (;;)
       [line 291]  remember entryname
            for (i = 0; i <= strlen(_sname)
       [line 304]  gap penalty mask
            while (_fileIn->getline(_line, MAXLINE + 1)
       [line 343] 
                else if (keyword(_line, "sequence")
       [line 390] 
        else if (strcmp(feature, "STRAND")
  |- FileReader.h
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 33] 
        int seqInput(Alignment* alignPtr, bool append)
       [line 34] 
        int readSeqs(Alignment* alignPtr, int firstSeq)
       [line 35] 
        int profileInput(Alignment* alignPtr)
       [line 41] 
        void checkInfile(int* nseqs, auto_ptr<FileParser>& fileParser)
       [line 44] 
        bool noEmptySequence(vector<Sequence> seqRangeVector)
  |- ClustalFileParser.h
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 20] 
        virtual Sequence getSeq(int seqNum)
       [line 21] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 22] 
        virtual int countSeqs()
       [line 23] 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                vector<char>& secStructMask,
               string& secStructName, int &structPenalties, int length)
       [line 31] 
        bool clustalBlankline(char* line)
  |- GDEFileParser.o
  |- InFileStream.h
    -> Found 6 function(s):
       [line 2]  Author: Nigel Brown
 * 
 * Copyright (c)
       [line 8]  This is then used by the getline()
       [line 23] 
  public:
    InFileStream()
       [line 27] 

    void open(const char *filename)
       [line 29] 
    void close()
       [line 38] 

  protected:
    char findDelimiter()
  |- EMBLFileParser.h
    -> Found 7 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 20] 
        virtual Sequence getSeq(int seqNum)
       [line 21] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 22] 
        virtual int countSeqs()
       [line 23] 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                vector<char>& secStructMask,
               string& secStructName, int &structPenalties, int length)
       [line 31] 
        void getSwissFeature(char* line, vector<char>& secStructMask, int length)
       [line 32] 
        void getSwissMask(char* line, vector<char>& gapPenaltyMask, int length)
  |- FileParser.h
    -> Found 10 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 15]  Removed delimiter and findDelimiter()
       [line 35] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 36]  VIRTUAL
        virtual Sequence getSeq(int seqNum)
       [line 37]  VIRTUAL
        virtual int countSeqs()
       [line 38]  VIRTUAL 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                                     vector<char>& secStructMask,
                                     string& secStructName, int &structPenalties, int length)
       [line 41] 
        void fillCharTab(void)
       [line 42] 
        char getDelimiter(string filename)
       [line 45] 
        int getParseExitCode()
       [line 46] 
        
    protected:
        void freeFileResources(InFileStream* filePtr)
  |- PIRFileParser.h
    -> Found 5 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 19] 
        virtual Sequence getSeq(int seqNum)
       [line 20] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 21] 
        virtual int countSeqs()
       [line 22] 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                                     vector<char>& secStructMask, string& secStructName, 
                                     int &structPenalties, int length)
  |- InFileStream.o
  |- PearsonFileParser.h
    -> Found 5 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 24] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 25] 
        virtual Sequence getSeq(int seqNum)
       [line 26] 
        virtual int countSeqs()
       [line 27] 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                                     vector<char>& secStructMask, string& secStructName, 
                                     int &structPenalties, int length)
  |- ClustalFileParser.o
  |- .dirstamp
  |- FileParser.o
  |- MSFFileParser.cpp
    -> Found 7 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 83] 
                return Sequence(blank, blank, blank)
       [line 86]  read the title
            if (utilityObject->lineType(_line, "//")
       [line 117]  Get the name of the sequence
                strncpy(_sname, _line + j, utilityObject->MIN(MAXNAMES, k - j)
       [line 151] 
                        return Sequence(characterSeq, name, title)
       [line 166]  return empty seq
            return Sequence(blank, blank, blank)
       [line 168] 
        return Sequence(characterSeq, name, title)
  |- PearsonFileParser.o
  |- GDEFileParser.cpp
    -> Found 9 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 91] 
                    return Sequence(blank, blank, blank)
       [line 157]  return empty seq
            return Sequence(blank, blank, blank)
       [line 159] 
        return Sequence(characterSeq, name, title)
       [line 195] 
            else if ((*line == '#')
       [line 240]  search for the next comment line
            while (*_line != '"')
       [line 266]  if _line contains ( then we break and dont put it into _sname
                // So how can sname have it???????
                if (_sname[i - 1] == '(')
       [line 334] 
            else if (strncmp(&_line[1], "GM_", 3)
       [line 349]  Again I dont think it is possible for _sname to have ( !!!!
                if (_sname[i - 1] == '(')
  |- PIRFileParser.o
  |- RSFFileParser.h
    -> Found 7 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 19] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 20] 
        virtual Sequence getSeq(int seqNum)
       [line 21] 
        virtual int countSeqs()
       [line 22] 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                                     vector<char>& secStructMask, string& secStructName, 
                                     int &structPenalties, int length)
       [line 30] 
        void getRSFFeature(char* line, vector<char>& secStructMask, int length)
       [line 31] 
        bool keyword(char *line,char *code)
  |- PIRFileParser.cpp
    -> Found 8 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 88] 
                    return Sequence(blank, blank, blank)
       [line 101]  line contains the name of the sequence
        for (i = 4; i <= strlen(_line)
       [line 152]  return empty seq
            return Sequence(blank, blank, blank)
       [line 154] 
        return Sequence(characterSeq, name, title)
       [line 200]  Look for end of first seq
            if (*line == '>')
       [line 212]  EOL 
                if (c == '\n' || c == EOS)
       [line 241]  Look for end of seq
                    if (*line == '>')
  |- PearsonFileParser.cpp
    -> Found 16 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 90]  get sequence name from current line (excluded '>' and read up to first ' ' or MAXNAMES
            // remove the first char i.e. '>'
            name=line.substr(1,MAXNAMES)
       [line 112]  No title information
            
            while(std::getline(_fileIn,line,delim)
       [line 119]  Andreas Wilm (UCD)
       [line 119]  exit if  angle brackets within sequence
                    if(*iterator1=='>' && iterator1!=line.begin()
       [line 149]  check sequence
            if (characterSeq.length()
       [line 157] 
            else if (characterSeq.length()
       [line 242]  get sequence name from current line (excluded '>' and read up to first ' ' or MAXNAMES
        // remove the first char i.e. '>'
        name=line.substr(1,MAXNAMES)
       [line 262]  PMcG replace char array with string processing
        while (_currentSeqNum != seqNum)
       [line 269] 
                    return Sequence(blank, blank, blank)
       [line 282]  line contains the name of the sequence
        for (i = 1; i <= strlen(_line)
       [line 290]  remember entryname 
        for (i = 1; i <= strlen(sname)
       [line 358]  return empty seq
            return Sequence(blank, blank, blank)
       [line 360] 
        else if (characterSeq.length()
       [line 364]  return empty seq
            return Sequence(blank, blank, blank)
       [line 366] 
        
        return Sequence(characterSeq, name, title)
    -> Referências importantes (com snippet):
       [Marcador de problema] line 47: 'FIXME'
         [  44]  * reads fasta/pearson file in one go instead of calling getSeq for
         [  45]  * each single sequence.
         [  46]  *
         [  47]  * FIXME AW: only PearsonFileParser::getSeqRange is special, rest is the
         [  48]  * same. should be defined in FileParser and then overloaded in special
         [  49]  * cases like here
         [  50]  */
       [Marcador de problema] line 47: 'AW:'
         [  44]  * reads fasta/pearson file in one go instead of calling getSeq for
         [  45]  * each single sequence.
         [  46]  *
         [  47]  * FIXME AW: only PearsonFileParser::getSeqRange is special, rest is the
         [  48]  * same. should be defined in FileParser and then overloaded in special
         [  49]  * cases like here
         [  50]  */
  |- InFileStream.cpp
    -> Found 7 function(s):
       [line 2]  Author: Nigel Brown
 * 
 * Copyright (c)
       [line 8]  This is then used by the getline()
       [line 66]  but for symmetry to open()
       [line 109]  for CR or LF or CRLF (or LFCR)
       [line 114] 
            else if (c == LF)
       [line 116] 
            else if (type)
       [line 137]  is UNIX (default)
  |- ClustalFileParser.cpp
    -> Found 23 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 12]  Mark Larkin (UCD)
       [line 81]  it
    
        while (_fileIn->getline(line, MAXLINE + 1)
       [line 135]  return empty seq
                                return Sequence(blank, blank, blank)
       [line 137] 
                     return Sequence(characterSeq, name, title)
       [line 152]  return empty seq
            return Sequence(blank, blank, blank)
       [line 154] 
        return Sequence(characterSeq, name, title)
       [line 264]  initialise length to zero 
    
        if (!_fileIn->getline(line, MAXLINE + 1)
       [line 271]  it 

        if (!_fileIn->getline(line, MAXLINE + 1)
       [line 279]  skip any blank lines 
        for (;;)
       [line 346]  EOL
                        if (!isspace(c)
       [line 356] 
            else if (strncmp(line, "!GM", 3)
       [line 401]  EOL
                        if (!isspace(c)
       [line 428]  skip any more comment lines
        while (line[0] == '!')
       [line 438]  skip the sequence lines and any comments after the alignment 
        for (;;)
       [line 453]  read the rest of the alignment

        for (;;)
       [line 457]  skip any blank lines
            for (;;)
       [line 470]  get structure table line 
            for (ix = 0; ix < struct_index; ix++)
       [line 510]  EOL
                    if (!isspace(c)
       [line 516] 
            else if (structPenalties == GMASK)
       [line 534]  EOL
                if (!isspace(c)
       [line 542]  skip any more comment lines
        while (line[0] == '!')
       [line 552]  skip the sequence lines
            for (;;)
  |- FileReader.o
  |- MSFFileParser.o
  |- GDEFileParser.h
    -> Found 5 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 20] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 21] 
        virtual Sequence getSeq(int seqNum)
       [line 22] 
        virtual int countSeqs()
       [line 23] 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                vector<char>& secStructMask,
               string& secStructName, int &structPenalties, int length)
  |- FileParser.cpp
    -> Found 6 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 7]  Removed delimiter and findDelimiter()
       [line 69]  for CR or LF or CRLF (or LFCR)
       [line 74] 
            else if (c == LF)
       [line 76] 
            else if (type)
       [line 97]  is UNIX (default)
  |- RSFFileParser.o
  |- EMBLFileParser.cpp
    -> Found 12 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 94] 
                    return Sequence(blank, blank, blank)
       [line 114]  remember entryname 
        for (i = 0; i <= strlen(_sname)
       [line 128]  Andreas Wilm (UCD)
       [line 135] 
                return Sequence(blank, name, blank)
       [line 179]  return empty seq
            return Sequence(blank, blank, blank)
       [line 181] 
        return Sequence(characterSeq, name, title)
       [line 259]  find the start of the sequence entry 
        for (;;)
       [line 278]  remember entryname
            for (i = 0; i <= strlen(_sname)
       [line 291]  gap penalty mask 
            while (_fileIn->getline(_line, MAXLINE + 1)
       [line 335] 
                else if (utilityObject->lineType(_line, "GM")
       [line 415] 
        else if (strcmp(feature, "STRAND")
    -> Referências importantes (com snippet):
       [Marcador de problema] line 135: 'FIXME'
         [ 132]             if(!_fileIn->getline(_line, MAXLINE + 1)) // If we cannot get anymore!
         [ 133]             {
         [ 134]                 _fileIn->close();
         [ 135]                 // FIXME AW: why return with a name but otherwise empty seq?
         [ 136]                 return Sequence(blank, name, blank);
         [ 137]             }
         [ 138]         }
       [Marcador de problema] line 135: 'AW:'
         [ 132]             if(!_fileIn->getline(_line, MAXLINE + 1)) // If we cannot get anymore!
         [ 133]             {
         [ 134]                 _fileIn->close();
         [ 135]                 // FIXME AW: why return with a name but otherwise empty seq?
         [ 136]                 return Sequence(blank, name, blank);
         [ 137]             }
         [ 138]         }
  |- EMBLFileParser.o
  |- MSFFileParser.h
    -> Found 5 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 19] 
        virtual Sequence getSeq(int seqNum)
       [line 20] 
        virtual vector<Sequence> getSeqRange(int firstSeq, int num)
       [line 21] 
        virtual int countSeqs()
       [line 22] 
        virtual void getSecStructure(vector<char>& gapPenaltyMask, 
                                     vector<char>& secStructMask, string& secStructName, 
                                     int &structPenalties, int length)
  |- FileReader.cpp
    -> Found 29 function(s):
       [line 2]  Author: Mark Larkin
 * 
 * Copyright (c)
       [line 18]  warnings in seqInput()
       [line 18]  and profileInput()
       [line 21]  because some state (what exactly?)
       [line 118] 
    else if(code == NOSEQUENCESINFILE)
       [line 188]  open input file (%s)
       [line 199] 
    else if(userParameters->getProfileNum()
       [line 218]  FIXME AW: noEmptySequence check should be done internally by FileParser instances
    if (noEmptySequence(seqRangeVector)
       [line 224]  Andreas Wilm (UCD)
       [line 225]  which important when no alignment (convert!)
       [line 252]  names after saving
        if(alignPtr->checkAllNamesDifferent()
       [line 265]  names before appending
        if (! alignPtr->testUniqueNames(&seqVector)
       [line 281]  gap penalty mask (only if this is a profile)
       [line 292]  Andreas Wilm (UCD)
       [line 332]  Clear old info

            if (structPenalties != NONE)
       [line 352] 
        else if(code == NOSEQUENCESINFILE)
       [line 374]  Clear old info
            
            if (structPenalties != NONE)
       [line 391] 
        else if(code == CANNOTOPENFILE)
       [line 395] 
        else if(code == NOSEQUENCESINFILE)
       [line 484] 
    else if (utilityObject->lineType(_lineIn, "CLUSTAL")
       [line 490] 
    else if (utilityObject->lineType(_lineIn, "PILEUP")
       [line 496] 
    else if (utilityObject->lineType(_lineIn, "!!AA_MULTIPLE_ALIGNMENT")
       [line 503] 
    else if (utilityObject->lineType(_lineIn, "!!NA_MULTIPLE_ALIGNMENT")
       [line 510] 
    else if (strstr(_lineIn, "MSF")
       [line 517] 
    else if (utilityObject->lineType(_lineIn, "!!RICH_SEQUENCE")
       [line 523] 
    else if (utilityObject->lineType(_lineIn, "#NEXUS")
       [line 528] 
    else if (*_lineIn == '>')
       [line 547] 
    else if ((*_lineIn == '"')
       [line 558] 
        else if (*_lineIn == '#')
    -> Referências importantes (com snippet):
       [Marcador de problema] line 218: 'FIXME'
         [ 215]     seqRangeVector = fileParser->getSeqRange(1, noSeqs);
         [ 216]     if (seqRangeVector.size()==0)
         [ 217]         return fileParser->getParseExitCode();
         [ 218]     // FIXME AW: noEmptySequence check should be done internally by FileParser instances
         [ 219]     if (noEmptySequence(seqRangeVector) == false)
         [ 220]         return EMPTYSEQUENCE; // Error there are same names.
         [ 221] 
       [Marcador de problema] line 218: 'AW:'
         [ 215]     seqRangeVector = fileParser->getSeqRange(1, noSeqs);
         [ 216]     if (seqRangeVector.size()==0)
         [ 217]         return fileParser->getParseExitCode();
         [ 218]     // FIXME AW: noEmptySequence check should be done internally by FileParser instances
         [ 219]     if (noEmptySequence(seqRangeVector) == false)
         [ 220]         return EMPTYSEQUENCE; // Error there are same names.
         [ 221] 

[DIRECTORY] src/fileInput/.deps
  |- RSFFileParser.Po
  |- InFileStream.Po
  |- PIRFileParser.Po
  |- FileReader.Po
  |- EMBLFileParser.Po
  |- .dirstamp
  |- GDEFileParser.Po
  |- PearsonFileParser.Po
  |- FileParser.Po
  |- MSFFileParser.Po
  |- ClustalFileParser.Po

=== Execução do 'make' ===

Código de retorno do 'make': 0

>> RAW MAKE OUTPUT <<

Making all in m4
make[1]: Entering directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/m4'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/m4'
Making all in src
make[1]: Entering directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/src'
make  all-recursive
make[2]: Entering directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/src'
make[3]: Entering directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/src'
make[3]: Leaving directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/src'
make[2]: Leaving directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/src'
make[1]: Leaving directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final/src'
make[1]: Entering directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final'
make[1]: Nothing to be done for 'all-am'.
make[1]: Leaving directory '/dados/home/tesla-dados/CUDA-clustalW/GPU/cuda_clustalw_final'

=== Warnings Coletados ===

(nenhum warning encontrado)

=== Errors Coletados ===

(nenhum erro encontrado)


=== SUMÁRIO DE CONTAGEM DE ITENS DETECTADOS ===

- FUNCTIONS: 1917
- CUDA Arch / Flags: 326
- Marcador de problema: 299
- API CUDA Obsoleta: 36